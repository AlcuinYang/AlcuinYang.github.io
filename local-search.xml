<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Carl Algorithm day 39 | LC62. Unique Paths, 63. Unique Paths II</title>
    <link href="/2023/03/27/CarlDay39/"/>
    <url>/2023/03/27/CarlDay39/</url>
    
    <content type="html"><![CDATA[<p>LC62. Unique Paths, 63. Unique Paths II<br><span id="more"></span></p><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>It is one of my OJ in CISCO interview. It is not hard.</p><h1 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h1><ol><li>Determine the meaning of the dp array (dp table) and the subscript</li><li>Determine the recursive formula</li><li>try to initialize dp array</li><li>Determine traversal order</li><li>Example derivation dp array</li></ol><h1 id="LC62-Unique-Paths"><a href="#LC62-Unique-Paths" class="headerlink" title="LC62. Unique Paths"></a>LC62. Unique Paths</h1><p>In this question, it shows me the different way to initiate dp array.  </p><ol><li>the meaning of dp table: number of routes to (n,m)</li><li>formulat: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</li><li>every point at first row and colum is 1</li><li>post order<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br><br>        <span class="hljs-comment">//dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>                dp[i][j] =dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="LC63-Unique-Paths-II"><a href="#LC63-Unique-Paths-II" class="headerlink" title="LC63. Unique Paths II"></a>LC63. Unique Paths II</h1><p>This is the exact question I did in the OA<br><a href="https://leetcode.cn/problems/unique-paths-ii/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-keyword">if</span>(obstacleGrid[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] != <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-comment">//when init array, we should identify when 1 appears in first row or col</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][i] != <span class="hljs-number">1</span>; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-comment">// System.out.println(&quot;i=&quot;+i);</span><br>                <span class="hljs-comment">// System.out.println(&quot;j=&quot;+j);</span><br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// System.out.println(dp[i][j]);</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br>For the initiate the </p><h2 id="OA"><a href="#OA" class="headerlink" title="OA"></a>OA</h2><p>A forklift worker moves products from one place to the other in an automotive parts warehouse. There a map in the dashboard that shows, in real time, the open and blocked sections inside the warehouse. The map is displayed as an n x m matrix of 1’s and 0’s which represent open and blocked sections respectively. A forklift driver always starts at the upper left corner of the map at warehouse[0][0] and tries to reach the bottom right section of the map or ware house[n-1][m-1]/ Each movement must be in increasing value along a row or column but not both. Given the warehouse map, determine the number of discinct path to get from warehouse[0][0] to warehouse[n-1][m-1]. The number maybe larger, so return the value module (10^9+7)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Warehouse</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfDistinctPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] warehouse)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> warehouse.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> warehouse[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// If the starting or ending point is blocked, return 0</span><br>        <span class="hljs-keyword">if</span> (warehouse[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || warehouse[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Initialize the first row and first column of the dp array</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (warehouse[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// we can add this part into &#x27;for&#x27;s condition&#x27;</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (warehouse[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Fill in the remaining dp array</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (warehouse[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = (dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 38 | LC509. Fibonacci Number, LC746. Min Cost Climbing Stairs, LC746. Min Cost Climbing Stairs</title>
    <link href="/2023/03/27/CarlDay38/"/>
    <url>/2023/03/27/CarlDay38/</url>
    
    <content type="html"><![CDATA[<p>Dynamic Programming Basic and LC509. Fibonacci Number, LC746. Min Cost Climbing Stairs, LC746. Min Cost Climbing Stairs<br><span id="more"></span></p><h1 id="Dynamic-Programming-Basic"><a href="#Dynamic-Programming-Basic" class="headerlink" title="Dynamic Programming Basic"></a>Dynamic Programming Basic</h1><p>What is Dynamic Programming?<br>The key in DP is <strong>Exhaustive</strong>, we have to identify the state transfer function to solve</p><h2 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h2><p><strong>We have to know the transfer function first then we can know it  is a dynamic problem</strong></p><ol><li>Determine the meaning of the dp array (dp table) and the subscript</li><li>Determine the recursive formula</li><li>try to initialize dp array</li><li>Determine traversal order</li><li>Example derivation dp array</li></ol><h2 id="LC509-Fibonacci-Number"><a href="#LC509-Fibonacci-Number" class="headerlink" title="LC509. Fibonacci Number"></a>LC509. Fibonacci Number</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/">Question</a><br>It is a very calssic problem in dp. Helpful to identify the process of dp   </p><ol><li>identify the meaning of dp[i]: value of No. i fib</li><li>transfer function: dp[i] = dp[i - 1] + dp[i - 2]</li><li>initiate the base case: dp[0] = 0, dp[1] = 1</li><li>set the order of traverse: it is from the front to end  </li><li>examples for dp of array: it is for when the answer is wrong, we can print the DP array</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n )</span> &#123;<br>    <span class="hljs-type">int</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LC70-Climbing-Stairs"><a href="#LC70-Climbing-Stairs" class="headerlink" title="LC70. Climbing Stairs"></a>LC70. Climbing Stairs</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp(n);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">//base case</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">// transfer function</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LC746-Min-Cost-Climbing-Stairs"><a href="#LC746-Min-Cost-Climbing-Stairs" class="headerlink" title="LC746. Min Cost Climbing Stairs"></a>LC746. Min Cost Climbing Stairs</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">Question</a><br>In this question, we have to<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp(cost);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[l + <span class="hljs-number">1</span>];<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= l; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>            System.out.println(dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[l];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linkedarray &amp; Array algorithm</title>
    <link href="/2023/03/25/array/"/>
    <url>/2023/03/25/array/</url>
    
    <content type="html"><![CDATA[<p>Array and linkedarray method, mainly two pointer<br><span id="more"></span></p><h1 id="two-pointer"><a href="#two-pointer" class="headerlink" title="two-pointer"></a>two-pointer</h1><p>Two pointer is an efficient way to solve array, linkedarray, and String prolems. it can be divided into 4 ways</p><ol><li>Seperate pointers</li><li>slow-fast pointers</li><li>left-right pointers</li><li>sliding window<h2 id="Seperate-pointers"><a href="#Seperate-pointers" class="headerlink" title="Seperate pointers"></a>Seperate pointers</h2>Seperate-pointers is quite useful in split and merge arraylist.<br>Note: In linkedlist why may use the <strong>Dummy node</strong> as the start of.   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3></li><li><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">Merge two sorted Lists</a><br>it is an easy question but many details in it. In this question, we use a <em>dummy</em> node as start and a <em>p</em> pointer to control. Use <em>p1</em> and <em>p2</em> to control <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>        ListNode p1, p2;<br>        p1 = list1;<br>        p2 = list2;<br>        <span class="hljs-comment">// the main judge of the value, the smaller one will be attack to the *p.next*</span><br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span> &amp;&amp; p2 != <span class="hljs-literal">null</span>)&#123;<br>             <span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;<br>                p.next = p2;<br>                p2 = p2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p.next = p1;<br>                p1 = p1.next;<br>            &#125;<br><br>            p = p.next; <span class="hljs-comment">// keep moving the p pointer </span><br><br>        &#125;<br>        <span class="hljs-comment">// when one list comes to end, we should attach the rest of other list to the new list</span><br>        <span class="hljs-keyword">if</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>            p.next = p1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p2 != <span class="hljs-literal">null</span>)&#123;<br>            p.next = p2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><a href="https://leetcode.cn/problems/partition-list/">Partition List</a></li><li><h2 id="Slow-Fast-pointers"><a href="#Slow-Fast-pointers" class="headerlink" title="Slow - Fast pointers"></a>Slow - Fast pointers</h2>the slow - fast pointer is useful in indetifying cycles in linkedlist and the N th node from end of list.   <h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3></li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List</a></li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">Middle of the Linked List</a></li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">Intersection of Two Linked Lists</a></li></ol><h2 id="left-and-right-two-pointer"><a href="#left-and-right-two-pointer" class="headerlink" title="left and right two-pointer"></a>left and right two-pointer</h2><p>The most common example of left and right pointers is <strong>binary search algorithm</strong><br>For a binary search, we need some conditions:</p><ol><li>the array or linkedarray should be in order</li><li>what we are looking for is single instead of multiple </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm, Binary search, two-pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network Theory Lecture Notes Lec 7 8 9</title>
    <link href="/2023/03/22/NetworkTheory789/"/>
    <url>/2023/03/22/NetworkTheory789/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-7-Introduction-to-Network-Optimisation"><a href="#Lecture-7-Introduction-to-Network-Optimisation" class="headerlink" title="Lecture 7: Introduction to Network Optimisation"></a>Lecture 7: Introduction to Network Optimisation</h1><h2 id="What-is-Optimisation"><a href="#What-is-Optimisation" class="headerlink" title="What is Optimisation"></a>What is Optimisation</h2><ul><li>def: select the best element from a set of alternatives</li></ul><h3 id="When-the-function-is-complex"><a href="#When-the-function-is-complex" class="headerlink" title="When the function is complex"></a>When the function is complex</h3><ul><li>by constrained optimisation<ul><li>on the input</li><li>output</li><li>input and output</li></ul></li></ul><h2 id="network-optimisation"><a href="#network-optimisation" class="headerlink" title="network optimisation"></a>network optimisation</h2><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><ul><li>to avoid the congestion and thus latency, jitter and packet loss in network</li></ul><h3 id="what-to-we-need-to-know"><a href="#what-to-we-need-to-know" class="headerlink" title="what to we need to know?"></a>what to we need to know?</h3><ul><li>traffic demand</li><li>capabilities of each node</li><li><p>capabilities of each link</p></li><li><p>Goal: to ensure, with the given set of constraints, an optimal network design with<strong> lowest cost structure</strong> and <strong>best performance</strong></p></li></ul><h2 id="KPIs"><a href="#KPIs" class="headerlink" title="KPIs"></a>KPIs</h2><ul><li>the target functions to optimise</li><li>performance<ul><li>Throughtput: effective speed (Mbps)</li><li>latency: delay from when a packet is sent to when it is received</li><li>jitter: variation of delays</li><li>paket loss</li><li>congestion</li></ul></li></ul><h2 id="Steps-of-network-optimisation"><a href="#Steps-of-network-optimisation" class="headerlink" title="Steps of network optimisation"></a>Steps of network optimisation</h2><ol><li>building a mathematical model<ul><li>linear, convex, concave model</li></ul></li><li>existence of optimao solution for the model<ul><li>fesaible solution: a vector x that satisfies all constrains</li><li>optimal solution: A feasible solution that gives the best value for objective function among all feasible solutions.</li></ul></li><li>characterisation of optimal solutions</li><li>algorithms for computing optimal solutions</li></ol><h3 id="Building-a-mathematical-model"><a href="#Building-a-mathematical-model" class="headerlink" title="Building a mathematical model"></a>Building a mathematical model</h3><ul><li>identifications:<ul><li>variables<ul><li>can use “Dummy” variable can make model more readable or to facilitate algorithmic solution</li></ul></li><li>object function</li><li>constrains<ul><li>Equality constraints (latency = 10ms) are too restrictive, better avoiding</li></ul></li></ul></li></ul><h4 id="how-to-build-model"><a href="#how-to-build-model" class="headerlink" title="how to build model"></a>how to build model</h4><ul><li>idendify all decision var<br>* </li><li>identify objective function<ul><li>Cost function or profit function</li></ul></li><li>identify all Constraints on Decision Variables</li></ul><h2 id="Minimum-cost-flow-problem"><a href="#Minimum-cost-flow-problem" class="headerlink" title="Minimum cost flow problem"></a>Minimum cost flow problem</h2><ul><li>aim:  finding the <strong>cheapest possible way</strong> of sending a certain amount of flow through a network.<ul><li>$x_{ij} =$amount transferred on edge (i,j)</li><li>$u_{ij} =$  capacity of edge</li><li>$c_{ij} =$ unit cost of shipping flow from node i to node j on (i,j) </li><li>$b_i =$ flow to be transmitted over the network<script type="math/tex; mode=display">minimise \sum_{(i,j)\in A}{c_{ij}x_{ij}}</script><script type="math/tex; mode=display">subject to \sum_j{x_{i,j}}-\sum_j{x_{j,i}} = b_i</script><img src="/img/MinimumCostFlowProblem.png" alt="Minimum Cost Flow Problem"></li></ul></li></ul><h1 id="Lecture-8-Solving-optimisation-problems"><a href="#Lecture-8-Solving-optimisation-problems" class="headerlink" title="Lecture 8: Solving optimisation problems"></a>Lecture 8: Solving optimisation problems</h1><h2 id="convex-optimisation-problems"><a href="#convex-optimisation-problems" class="headerlink" title="convex optimisation problems"></a>convex optimisation problems</h2><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><ul><li>Unconstrained problems: <ul><li>Newton’s method</li></ul></li><li>constrained problems:     <ul><li>Lagrangian dual problem</li><li>Penalty method<ul><li>Barrier method</li><li>logarithmic barrier</li></ul></li></ul></li></ul><h3 id="convexity"><a href="#convexity" class="headerlink" title="convexity"></a>convexity</h3><p>Use $H(x)$, Hessian(second grad) of $f(x)$, if $H(x)$ is positive semi definite for all x<br><strong>M</strong> is positive semi definite if $x^tMx\geq0$ for all $x\in R^n$</p><h2 id="Newton’s-method"><a href="#Newton’s-method" class="headerlink" title="Newton’s method"></a>Newton’s method</h2><p>it can only get local min instead of global</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h3><ol><li>choose start point $x_0$</li><li>obtain better approximation<script type="math/tex; mode=display">x_1 = x_0-\frac{f(x_0)}{f'(x_0)}</script></li><li>The process is repeated until a more accurate<br>approximation is found</li></ol>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network Theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 30 | LC51. N Queens</title>
    <link href="/2023/03/16/CarlDay30/"/>
    <url>/2023/03/16/CarlDay30/</url>
    
    <content type="html"><![CDATA[<p>N-Queens<br><span id="more"></span></p><h1 id="LC51-N-Queens"><a href="#LC51-N-Queens" class="headerlink" title="LC51. N Queens"></a>LC51. N Queens</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/n-queens/">Question</a><br>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.  </p><p>Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.  </p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Input</span>: n = <span class="hljs-number">4</span><br><span class="hljs-symbol">Output</span>: [[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br></code></pre></td></tr></table></figure><br><img src="/img/NQueens.png" alt="NQueens"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Clearly this is a difficult but a typical question of backtracking.  </p><h3 id="3-steps"><a href="#3-steps" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters:<ol><li><code>List&lt;String&gt; board</code>: we should initialze the board by the n</li><li>row</li></ol></li><li>end condition<ol><li><code>row == board.size()</code>: if row reach the last row, the end </li></ol></li><li>single layer<ol><li>function <code>isValid</code> to judge whether it is valid to place a queen here: inlcuding <strong>column</strong>, <strong>top right</strong>, <strong>top left</strong></li><li>set the queen</li></ol></li></ol><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// &#x27;.&#x27; means empty</span><br>        List&lt;String&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            board.add(sb.toString());<br>        &#125;<br>        backtrack(board, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == board.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(board));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.get(row).length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br><br>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">char</span>[] arr = board.get(row).toCharArray();<br>            arr[col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.set(row, String.valueOf(arr));<br><br>            backtrack(board, row + <span class="hljs-number">1</span>);<br><br>            arr[col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            board.set(row, String.valueOf(arr));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// check the validation of queens</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.size();<br><br>        <span class="hljs-comment">// check column</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(col) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// check top right</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// check top left</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BackTracking Algorithm</title>
    <link href="/2023/03/15/backtracking/"/>
    <url>/2023/03/15/backtracking/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the <strong>brute force approach</strong>.<br>It consists of building <strong>a set of all the solutions</strong> incrementally. Since a problem would <strong>have constraints</strong>, the solutions that <strong>fail to satisfy</strong> them will be <strong>removed</strong>.  </p><h2 id="Aimed-questions"><a href="#Aimed-questions" class="headerlink" title="Aimed questions"></a>Aimed questions</h2><p><img src="/img/backtrack.png" alt="backtrack"></p><h1 id="skeleton"><a href="#skeleton" class="headerlink" title="skeleton"></a>skeleton</h1><p>For a bracktrack problem ,we have to consider 3 conditions:  </p><ol><li>path: the dicisions have been made </li><li>choices list: what we can choose</li><li>end condition<br>Here is the skeloton of it in pseudocode</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">reslut = []<br><br>def backtrack(<span class="hljs-type">path</span>, choicesList)&#123;<br>    <span class="hljs-keyword">if</span>(satisfy <span class="hljs-keyword">end</span> condition)&#123;<br>        result.<span class="hljs-keyword">add</span>(<span class="hljs-type">path</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(choice : choicesList)&#123;<br>        choose process<br>        backtrack(<span class="hljs-type">path</span>, choicesList);<br>        recall choose process<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>it is hard to determine the parameters at first, we can set the logic first and fullfill the parameters when we need it.  </p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="Leetcode-Permutations-https-leetcode-cn-problems-permutations"><a href="#Leetcode-Permutations-https-leetcode-cn-problems-permutations" class="headerlink" title="Leetcode: Permutations(https://leetcode.cn/problems/permutations/)"></a>Leetcode: Permutations(<a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a>)</h3><ul><li><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.  </p></li><li><p>Example 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></li><li>Example 2:<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure></li><li>Example 3:<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// result </span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<span class="hljs-comment">// to identify whether it has been used, like in graph traversing, we need a identifier to avoid loop</span><br><br>        backtrack(nums, path, used);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, LinkedList&lt;Integer&gt; path, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, path, used); <span class="hljs-comment">// recursion, we need to make decision before recursion and withdraw decision after recursion. It means we do pre-order thing first then post-order</span><br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 29 | LC46. Permutations, LC47. Permutations II</title>
    <link href="/2023/03/15/CarlDay29/"/>
    <url>/2023/03/15/CarlDay29/</url>
    
    <content type="html"><![CDATA[<p>LC46. Permutations, LC47. Permutations II<br><span id="more"></span></p><h1 id="LC46-Permutations"><a href="#LC46-Permutations" class="headerlink" title="LC46. Permutations"></a>LC46. Permutations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/permutations/">Question</a><br>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>the main difference between combiation and permutations is it  is should start from 0 instead of <code>start</code> .</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br><br>        backtrack(nums, path, used);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, LinkedList&lt;Integer&gt; path, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, path, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC47-Permutations-II"><a href="#LC47-Permutations-II" class="headerlink" title="LC47. Permutations II"></a>LC47. Permutations II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">Question</a><br>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,1,2]</span><br>Output:<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>In this question, it has dupicates, so we can use <code>nums[i] == nums[i-1]</code> to avoid it. However we have to ensure the input is in sorted.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<span class="hljs-comment">// sort the input</span><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtrack(nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<span class="hljs-comment">//nums[i] has been used</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 28 | LC78. Subsets, LC90. Subsets II, LC491. Non-decreasing Subsequences</title>
    <link href="/2023/03/14/CarlDay28/"/>
    <url>/2023/03/14/CarlDay28/</url>
    
    <content type="html"><![CDATA[<p>LC78. Subsets, LC90. Subsets II, LC491. Non-decreasing Subsequences<br><span id="more"></span></p><h1 id="LC78-Subsets"><a href="#LC78-Subsets" class="headerlink" title="LC78. Subsets"></a>LC78. Subsets</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums of unique elements, return all possible subsets (the power set).  </p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>]<br>Output: <span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>This is a brand new kind of question. If the subset problem, combination problem, and segmentation problem are all abstracted into a <strong>tree</strong>, then the combination problem and the segmentation problem are to <strong>collect the leaf nodes</strong> of the tree, and the subset problem is to <strong>find all the nodes</strong> of the tree!</p><h3 id="3-steps"><a href="#3-steps" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters: <ol><li><code>int[] nums</code>: input</li><li>start: avoid duplicate</li></ol></li><li>end statements<ol><li><code>start == nums.length</code>: reach the end of tree</li><li>add every nodes!</li></ol></li><li><p>single layer </p><ol><li>add and withdraw</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <br>        backtrack(nums, <span class="hljs-number">0</span>, path);<br>        <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, LinkedList path)</span>&#123;<br><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<span class="hljs-comment">// notice here , there is no if control as combination do, becasue we need to collect every nodes instead of leaves only</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>, path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC90-Subsets-II"><a href="#LC90-Subsets-II" class="headerlink" title="LC90. Subsets II"></a>LC90. Subsets II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,2]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>]<br>Output: <span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ol><li>parameters: <ol><li><code>int[] nums</code>: input</li><li>start: avoid duplicate</li></ol></li><li>end statements<ol><li><code>start == nums.length</code>: reach the end of tree</li><li>add every nodes!</li></ol></li><li>single layer <ol><li>add and withdraw</li><li>judge same elements</li></ol></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtrack(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC491-Non-decreasing-Subsequences"><a href="#LC491-Non-decreasing-Subsequences" class="headerlink" title="LC491. Non-decreasing Subsequences"></a>LC491. Non-decreasing Subsequences</h1><p>Given an integer array <code>nums</code>, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[4,6,7,7]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>it is quite like <a href="CarlDay27.md">LC40 CobinationII</a>.  To ensure the no decreasing property, we can use <code>getLast() &gt; nums[i]</code> to </p><h3 id="3-steps-1"><a href="#3-steps-1" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters:<ol><li>nums</li><li>start</li></ol></li><li>end conditions<ol><li>the end arrary with at least 2 elements: <code>path.size()&gt;1</code></li></ol></li><li>single layer<ol><li>since we have to avoid duplicate, so we can use <code>HashSet</code> to avoid</li><li>judge the path is empty or not and the last element is larger than nums[i]</li></ol></li></ol><h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtrack(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt; <span class="hljs-number">1</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        &#125;<br>        HashSet&lt;Integer&gt; used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!path.isEmpty() &amp;&amp; path.getLast() &gt; nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(used.contains(nums[i]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            used.add(nums[i]);<br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 27 | LC39. Combination Sum, LC40. Combination Sum II, LC93. Restore IP Addresses</title>
    <link href="/2023/03/13/CarlDay27/"/>
    <url>/2023/03/13/CarlDay27/</url>
    
    <content type="html"><![CDATA[<p>LC39. Combination Sum, LC40. Combination Sum II, LC93. Restore IP Addresses<br><span id="more"></span></p><h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum/">Question</a><br>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in <strong>any order</strong>.<br>The <strong>same</strong> number may be chosen from candidates an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.  </p><p>The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p><p>Example 1:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span><br>Output: <span class="hljs-string">[[2,2,3],[7]]</span><br></code></pre></td></tr></table></figure><p>Explanation:<br>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 = 7.<br>These are the only two combinations.<br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8  <br>Output: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> candidates = [<span class="hljs-number">2</span>], target = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">Output:</span> []<br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is quite same as <a href="">LC216. Combination Sum III</a></p><h3 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>input</li><li>sum: sum of elements in path s</li><li>start</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>sum = target</li><li>if <code>candidate[i] + sum &gt; target</code>, then stop the for loop, but if we wanna do so, we need to sort the array</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<span class="hljs-comment">//very important</span><br>        backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates &amp;&amp;(sum + candidates[i] &lt;= target); i++)&#123;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br><br>            backtrack(candidates, target, sum, i);<br><br>            sum -= candidates[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="LC40-Combination-Sum-II"><a href="#LC40-Combination-Sum-II" class="headerlink" title="LC40. Combination Sum II"></a>LC40. Combination Sum II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">Question</a><br>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.  </p><p>Each number in candidates may only be used once in the combination.</p><p>Note: The solution set must not contain duplicate combinations.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8<br>Output: <br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5<br>Output: <br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>The difference between this question and former question is that: <strong>Each number in candidates may only be used once in the combination.</strong><br>So we have to process the dupilcate </p><h3 id="3-Steps-1"><a href="#3-Steps-1" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>input</li><li>sum: sum of elements in path s</li><li>start</li><li>used:int[]. it is used to avoid duplicate</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>sum = target</li><li>if <code>candidate[i] + sum &gt; target</code>, then stop the for loop, but if we wanna do so, we need to sort the array</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        Arrays.sort(candidates);<br>        Arrays.fill(used, <span class="hljs-literal">false</span>);<br>        backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length ; i++)&#123;<br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>              <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br><br>            backtrack(candidates, target, sum, i + <span class="hljs-number">1</span>);<br>            <br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="LC131-Palindrome-Partitioning"><a href="#LC131-Palindrome-Partitioning" class="headerlink" title="LC131. Palindrome Partitioning"></a>LC131. Palindrome Partitioning</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">Question</a><br>Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.<br>Example 1:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Input</span>: s = <span class="hljs-string">&quot;aab&quot;</span><br><span class="hljs-symbol">Output</span>: [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: s = <span class="hljs-string">&quot;a&quot;</span><br>Output: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><h3 id="3-Steps-2"><a href="#3-Steps-2" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>parameters:<ol><li>res</li><li>path</li><li>start : to avoid duplicate seletection</li></ol></li><li>end statements<ol><li><code>start == s.length()</code>: reach the end, means we have found the solution</li></ol></li><li>Single laler process<ol><li>judge whether it is a palindrome: use two-pointers to judge. If it is not, then jump it. </li><li>add result substring to <code>path</code></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtrack(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == s.length())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!isPalindrome(s, start, i))&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// not a palindrome, can be splited</span><br>            &#125;<br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtrack(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span>&#123;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(lo) != s.charAt(hi))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            lo++;<br>            hi--;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC93-Restore-IP-Addresses"><a href="#LC93-Restore-IP-Addresses" class="headerlink" title="LC93. Restore IP Addresses"></a>LC93. Restore IP Addresses</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">Question</a><br>A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.  </p><p>Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in <strong>any</strong> order.<br>Example 1:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;25525511135&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;0000&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;101023&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]<br></code></pre></td></tr></table></figure></p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>Like Palindrome Partitioning. The difference is the function <code>isValid</code> is used to judge whether the ip address is valid. And the tree has 4 layers.</p><h3 id="3-Steps-3"><a href="#3-Steps-3" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>parameters of <code>backtrack</code> function: <ol><li>String s</li><li>int start: void duplicate</li></ol></li><li>end statements:<ol><li>path.length &gt;= 4</li><li>the string is not valid</li></ol></li><li>single layer process:<ol><li>take a substring between <strong>start</strong> and <strong>i</strong></li><li>Judge valid:<ol><li>0 start</li><li>length not 1~3</li><li>lager than 255</li></ol></li></ol></li></ol><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>      <br>        backtrack(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == s.length() &amp;&amp; path.size() == <span class="hljs-number">4</span>)&#123;<br>            res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!isValid(s, start, i))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(path.size() &gt;= <span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtrack(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> end - start + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span> || length &gt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<span class="hljs-comment">//mind here, it should be a char 0 instead of int 0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(length &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Integer.parseInt(s.substring(start, start + length)) &gt; <span class="hljs-number">255</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 25 | LC216. Combination Sum III, LC17. Letter Combinations of a Phone Number</title>
    <link href="/2023/03/11/CarlDay25/"/>
    <url>/2023/03/11/CarlDay25/</url>
    
    <content type="html"><![CDATA[<p>LC216. Combination Sum III, LC17. Letter Combinations of a Phone Number<br><span id="more"></span></p><h1 id="LC216-Combination-Sum-III"><a href="#LC216-Combination-Sum-III" class="headerlink" title="LC216. Combination Sum III"></a>LC216. Combination Sum III</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">Question</a>  </p><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:  </p><ul><li>Only numbers 1 through 9 are used.</li><li>Each number is used at most once.  </li></ul><p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.  </p><p>Example 1:<br>    <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>Output: <span class="hljs-string">[[1,2,4]]</span><br></code></pre></td></tr></table></figure><br>    Explanation:<br>    1 + 2 + 4 = 7<br>    There are no other valid combinations.<br>Example 2:<br>    <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">9</span><br>Output: <span class="hljs-string">[[1,2,6],[1,3,5],[2,3,4]]</span><br></code></pre></td></tr></table></figure><br>    Explanation:<br>    1 + 2 + 6 = 9<br>    1 + 3 + 5 = 9<br>    2 + 3 + 4 = 9<br>    There are no other valid combinations.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is quite same as LC77. The differences are :</p><ol><li>The set size is constant: 9</li><li>end condition has two: <code>sum &gt; targertSum</code> or <code>k == path.size</code></li><li>Need to calculate sum when choosing and withdraw the decision of path</li></ol><h3 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps:"></a>3 Steps:</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>k</li><li>sum: sum of elements in path s</li><li>start</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>reach the end of tree</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate</li></ul></li></ol><p>So the solution is:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br><br>        backtrack(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span>&#123;<br>  <br>        <span class="hljs-keyword">if</span>(sum &gt; n)&#123;         <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k == path.size())&#123;<br>            <span class="hljs-keyword">if</span> (sum == n)&#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            sum += i;<br>            path.add(i);<br>            backtrack(k, n, i + <span class="hljs-number">1</span>, sum);<br>            path.removeLast();<br>            sum -= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC17-Letter-Combinations-of-a-Phone-Number"><a href="#LC17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="LC17. Letter Combinations of a Phone Number"></a>LC17. Letter Combinations of a Phone Number</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">Question</a><br>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.  </p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>Example 1:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;23&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>Example 2:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">Output:</span> []<br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><h3 id="3-step"><a href="#3-step" class="headerlink" title="3 step"></a>3 step</h3><ol><li>paramenters: <ol><li>digits</li><li>start: record which number has been recursive</li></ol></li><li>end statement<ol><li>if <code>start == digit.size</code>: means how many numbers needed</li></ol></li><li>single layer:<ol><li>target index to number and mapping it. </li><li>record the path</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>            <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>            &#125;;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span>(digits.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        backtrack(digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> start, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() == digits.length()) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; digits.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> digits.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : mapping[digit].toCharArray()) &#123;<br>                sb.append(c);<br>                backtrack(digits, i + <span class="hljs-number">1</span>, sb);<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 24 | LC77. Combinations</title>
    <link href="/2023/03/10/CarlDay24/"/>
    <url>/2023/03/10/CarlDay24/</url>
    
    <content type="html"><![CDATA[<p>Backtracking algorithm basic and LC77. Combinations<br><span id="more"></span></p><h1 id="Backtracking-algorithm-basic"><a href="#Backtracking-algorithm-basic" class="headerlink" title="Backtracking algorithm basic"></a>Backtracking algorithm basic</h1><p>see in <a href="backtracking.md">Backtrack algorithm</a></p><h1 id="LC77-Combinations"><a href="#LC77-Combinations" class="headerlink" title="LC77. Combinations"></a>LC77. Combinations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combinations/">Question</a>  </p><p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].  </p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: n = 4, k = 2<br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[3,4]</span>]</span><br></code></pre></td></tr></table></figure><br>Explanation: There are 4 choose 2 = 6 total combinations.<br>Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.<br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><br>Explanation: There is 1 choose 1 = 1 total combination. </p><ul><li>Constraints:<br>1 &lt;= n &lt;= 20<br>1 &lt;= k &lt;= n  </li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>For a backtrack problem, we can consider it as a binary tree, then we can draw a map to illustrate the question<br><img src="/img/combinationeg.jpeg" alt="combination"><br>In this map we can know that <em>k</em> limits the depth of tree and <em>n</em> limits the broad of tree.<br>So for the <code>backtrack</code> function, the end condition is <strong>reach the depth of tree</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        backtrack(n, k, <span class="hljs-number">1</span>, track);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start, List&lt;Integer&gt; track)</span>&#123;<span class="hljs-comment">// the start is used to avoid dupicate</span><br>        <span class="hljs-keyword">if</span>(k == track.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; i++)&#123;<br>            track.add(i);<br>            backtrack(n, k, i + <span class="hljs-number">1</span>, track); <span class="hljs-comment">// notice here, the start is i + 1 instead of start + 1</span><br><br>            track.remove(track.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>For this quesiton, we can optimize it by <strong>pruning</strong>. Let’s see the previous image<br><img src="/img/combinationeg.jpeg" alt="combination"><br>we can notice that the selection for layer2 at 4, it is null, so it is useless, then we can modify it by adjusting <em>for loop</em>. Let’s analyze it </p><ol><li>elements already selected: <code>track.size()</code></li><li>elements needed: <code>k-track.size()</code></li><li>elements left in the list: <code>n - 1</code> &gt;= element needed <code>k-path.size()</code></li><li>In the set n at most from the starting position: <code>i &lt;= n - (k - path.size()) + 1</code>, start to recuisive  </li></ol><p>so we can change the <em>for loop</em> into<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.add(i);<br>            combineHelper(n, k, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure><br>The final code is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>      List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <br>        backtrack(n, k, <span class="hljs-number">1</span>,track);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start, List&lt;Integer&gt; track)</span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(k == track.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - track.size()) + <span class="hljs-number">1</span>;i++)&#123;<br>            track.add(i);<br>            <br>            backtrack(n, k, i + <span class="hljs-number">1</span>, track); <span class="hljs-comment">// i + 1instead of </span><br>            <br>            track.remove(track.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Backtracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 23 | LC538. Convert BST to Greater Tree</title>
    <link href="/2023/03/09/CarlDay23/"/>
    <url>/2023/03/09/CarlDay23/</url>
    
    <content type="html"><![CDATA[<p>LC538. Convert BST to Greater Tree<br><span id="more"></span></p><h1 id="LC538-Convert-BST-to-Greater-Tree"><a href="#LC538-Convert-BST-to-Greater-Tree" class="headerlink" title="LC538. Convert BST to Greater Tree"></a>LC538. Convert BST to Greater Tree</h1><p>tranverse from right to left<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traverse(root.right);<span class="hljs-comment">//since we need the sum of all keys greater than the original key in BST, so we traverse right node first then left</span><br>        sum += root.val;<br>        root.val = sum;<br>        traverse(root.left);<br><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 22 | LC701. Insert into a Binary Search Tree, LC450. Delete Node in a BST</title>
    <link href="/2023/03/08/CarlDay22/"/>
    <url>/2023/03/08/CarlDay22/</url>
    
    <content type="html"><![CDATA[<p>LC701. Insert into a Binary Search Tree, LC450. Delete Node in a BST<br><span id="more"></span></p><h1 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h1><p>Inserting one value into BST is easym just compare it with root value, if larger then insert it in right, else insert it to left.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(val &gt; root.val)&#123;<br>          root.right = insertIntoBST(root.right, val); <span class="hljs-comment">//it must be root.right</span><br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; root.val)&#123;<br>          root.left = insertIntoBST(root.left, val);<br>      &#125;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a>450. Delete Node in a BST</h1><p>When ever we wanna delete or insert an element, we have to <strong>search it first</strong>, so the skeleton is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-title function_">if</span><span class="hljs-params">(root.val == key)</span>&#123;<span class="hljs-comment">//found the node</span><br>        ···<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<span class="hljs-comment">//key smaller, search left subtree</span><br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<span class="hljs-comment">// key larger, search right subtree</span><br>            root.right = deleteNode(root.right, key);<br>    &#125;<br>        <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><br>Then, we have to identify the situations for delete ndoe.  </p><ol><li>it is the leef: just remove it</li><li>it only has left node: then let it be its left node</li><li>it only has right node: be right</li><li>it has left and right node, then we need to find the <strong>minimum</strong> in its left subtree to replace itselft to maintain the validation of BST. </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br><br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);<span class="hljs-comment">//find min of right</span><br>            <br>                root.val = minNode.val;<br>                <br>                root.right = deleteNode(root.right, minNode.val);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<br>            root.right = deleteNode(root.right, key);<br>    &#125;<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>    TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">while</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            root = root.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 21 | LC530. Minimum Absolute Difference in BST, LC501. Find Mode in Binary Search Tree, LC236. Lowest Common Ancestor of a Binary Tree, 236. Lowest Common Ancestor of a Binary Tree</title>
    <link href="/2023/03/07/CarlDay21/"/>
    <url>/2023/03/07/CarlDay21/</url>
    
    <content type="html"><![CDATA[<p>LC530. Minimum Absolute Difference in BST, LC501. Find Mode in Binary Search Tree, LC236. Lowest Common Ancestor of a Binary Tree, 236. Lowest Common Ancestor of a Binary Tree<br><span id="more"></span></p><h1 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">Question</a><br>For every BST question, we have to remember <strong>the inorder traverse of BST is a monotonically increase array</strong>. Using this character, we can solve many problems.<br>In this question, we can have study a new method: the <code>prev</code>node, using this can process the prev node so that we can process it with <code>cur</code> node.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// prev node </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        traverse(root.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>)&#123;<br>            min = Math.min(min,root.val - pre.val);<br>        &#125;<br>        pre = root;<br>        traverse(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a>501. Find Mode in Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">Question</a><br>Same as before, <strong>inorder traverse + prev ndoe processing</strong>. Just we have to do some <code>if else</code> in the in-order traverse.   And one Key is <strong>when new mode happens, we have to clear the previouse result and add new mode</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// using for record previouse node </span><br>    ArrayList&lt;Integer&gt; mode= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) &#123;<br>        traverse(root);<br><br>        <span class="hljs-type">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mode.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; res.length; i++)&#123;<br>            res[i] = mode.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        traverse(root.left);<br>        <span class="hljs-keyword">if</span>(prev == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">// process the root ndoe</span><br>            curCount = <span class="hljs-number">1</span>;<br>            maxCount = <span class="hljs-number">1</span>;<br>            mode.add(root.val);<br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>            <span class="hljs-keyword">if</span>(root.val == prev.val)&#123;<span class="hljs-comment">//if value equivalent</span><br>                curCount ++;<br>                <span class="hljs-keyword">if</span>(curCount == maxCount)&#123;<br>                    mode.add(root.val);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curCount &gt; maxCount)&#123;<span class="hljs-comment">//new mode appears</span><br>                    mode.clear();<span class="hljs-comment">//clear the og array, because this is the new mode</span><br>                    maxCount = curCount;<br>                    mode.add(root.val);<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(root.val != prev.val)&#123;<span class="hljs-comment">//</span><br>                curCount = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(curCount == maxCount)&#123;<br>                    mode.add(root.val);<br>            &#125;<br>            &#125;<br><br>        &#125;        <br>        prev = root;<br>        traverse(root.right);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">Question</a><br>The LCA of two nodes is actually the intersection point of the “extension line” of the two nodes to the root node.<br>There are two common situation<br><img src="/img/LCA.jpeg" alt="LCA"><br>So <strong>if one node can find node p &amp; q in its left and right subtree, then it is LCA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(root, p ,q);<br>    &#125;<br><br>    TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root == p || root == q)&#123; <span class="hljs-comment">// for the 2nd situation </span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> find(root.left,  p,  q);<br>        TreeNode right= find(root.right,  p,  q);<br><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">// for the 1st situation</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left != <span class="hljs-literal">null</span> ? left : right;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><code>return left != null ? left : right;</code> means if cant find the node in left subtree, then find the right subtree.<br><code>if(root == p || root == q)&#123; return root;&#125;</code>, why we can locate the root as LCA? Because <code>p</code> and <code>q</code> will exist in the tree.</p><h1 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">Question</a><br>Since it is a BST, we can use its propety: <strong>left node &gt; right node</strong>. If <code>root.val &gt; max</code>, then try to find it in left subtree, if <code>root.val &lt; min</code>, then find it in right subtree. It is not very hard to work out this, but we have to know how to implement it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(p.val, q.val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(p.val, q.val);<br><br>        <span class="hljs-keyword">return</span> find(root, min, max);<br>    &#125;<br><br>    TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span>(root.val &gt; max)&#123;<br>            <span class="hljs-keyword">return</span> find(root.left, min, max);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; min)&#123;<br>            <span class="hljs-keyword">return</span> find(root.right, min, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 20 | LC654. Maximum Binary Tree, LC617 Merge Two Binary Trees, LC700 Search in a Binary Search Tree, LC98 Validate Binary Search Tree</title>
    <link href="/2023/03/06/CarlDay20/"/>
    <url>/2023/03/06/CarlDay20/</url>
    
    <content type="html"><![CDATA[<p>LC654. Maximum Binary Tree, LC617 Merge Two Binary Trees, LC700 Search in a Binary Search Tree, LC98 Validate Binary Search Tree<br><span id="more"></span></p><h1 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">Question</a><br>Same method as <a href="CarlDay18.md">106. Construct Binary Tree from Inorder and Postorder Traversal</a>. Find the max value, tag its location and split it into subtrees. Then construct them seperately by recursion.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxTag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; max)&#123;<br>                max = nums[i];<br>                maxTag = i;<span class="hljs-comment">//Find the location of max value</span><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(max);<br>        root.left = build(nums, start, maxTag - <span class="hljs-number">1</span>);<br>        root.right = build(nums, maxTag + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">Question</a><br>These question has one same point is <strong>we need to focus on the meaning of funtion itself, which can save a lot of trouble</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br><br>        root1.left = mergeTrees(root1.left, root2.left);<br>        root1.right = mergeTrees(root1.right, root2.right);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a>700. Search in a Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">Question</a><br><img src="/img/bst.HEIC" alt="notes"><br>Welcome to BST. As the notes show the basic logic, we can searc the tree<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">if</span>(root.val &gt; val)&#123;<br>           <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(root.val &lt; val)&#123;<br>           <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>       &#125;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode max;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span> (!left) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (max != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= max.val) &#123;<span class="hljs-comment">//focus on this part bcs it make sure the validation of tree.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        max = root;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 18 | LC513 Find Bottom Left Tree Value, LC2 Path Sum, LC106 Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="/2023/03/04/CarlDay18/"/>
    <url>/2023/03/04/CarlDay18/</url>
    
    <content type="html"><![CDATA[<p>LC513 Find Bottom Left Tree Value, LC2 Path Sum, LC106 Construct Binary Tree from Inorder and Postorder Traversal<br><span id="more"></span></p><h1 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">Question</a><br>easy to solve by level traverse.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>      que.offer(root);<br><br>      <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>              <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> que.poll();<br>              <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                  res = cur.val;<br>              &#125;<br>              <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                  que.offer(cur.left);<br><br>              &#125;<br>              <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                  que.offer(cur.right);<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h1 id="2-Path-Sum"><a href="#2-Path-Sum" class="headerlink" title="2. Path Sum"></a>2. Path Sum</h1><p><a href="https://leetcode.cn/problems/path-sum/">Question</a><br>Easy question, just figure out the logic: ‘targetSum-root.val’ is next recursion’s input.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> targetSum == root.val;<br>       &#125;<br><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">leftPath</span> <span class="hljs-operator">=</span> hasPathSum(root.left,targetSum - root.val);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">rightPath</span> <span class="hljs-operator">=</span> hasPathSum(root.right, targetSum - root.val);<br>       <span class="hljs-keyword">return</span> (leftPath||rightPath);<br>   &#125;   <br></code></pre></td></tr></table></figure></p><h1 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h1><p><strong>The construction problem of binary tree generally uses the idea of “decomposition problem”: constructing the whole tree = root node + constructing left subtree + constructing right subtree.</strong><br>In post-order traverse, the last value is the root node. Then we can split the left subtree and right subtree by root. Then we can calculate the no nodes in left subtree and then recursive. The key in this question is <strong>how to identify the start and end in both postorder and inorder array to build subtrees</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>     HashMap&lt;Integer, Integer&gt; inHash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> [] inorder, <span class="hljs-type">int</span>[] postorder)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            inHash.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd )</span>&#123;<br>         <span class="hljs-keyword">if</span>(inStart &gt; inEnd)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>         &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> postorder[postEnd];<span class="hljs-comment">//the root is the last node in postorder</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> inHash.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index - inStart; <br><br>         <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>         root.left = build(inorder, inStart, index - <span class="hljs-number">1</span>, postorder, postStart, postStart + leftSize - <span class="hljs-number">1</span>);<br>         root.right = build(inorder, index + <span class="hljs-number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="hljs-number">1</span>);<span class="hljs-comment">//mind the end of postorder is og end-1 bcs it is used for root</span><br>         <span class="hljs-keyword">return</span> root;<br><br><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;Integer, Integer&gt; inHash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-comment">//将中序遍历存入hashmap可以降低查找对应index的时间复杂度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            inHash.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> [] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span> [] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span>&#123;<br>        <span class="hljs-keyword">if</span>(inStart &gt; inEnd)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 为什么只考虑中序遍历的时候，不考虑前序</span><br>        <span class="hljs-type">int</span> rootVal= preorder[preStart];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> inHash.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSieze</span> <span class="hljs-operator">=</span> index - inStart;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        <br>        root.left = build(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftSieze, inorder, inStart, index - <span class="hljs-number">1</span>);<br>        root.right = build(preorder, preStart + leftSieze + <span class="hljs-number">1</span>, preEnd, inorder,index+<span class="hljs-number">1</span>, inEnd);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 17 | LC110 Balanced Binary Tree, LC257 Binary Tree Paths, LC404 Sum of Left Leaves</title>
    <link href="/2023/03/03/CarlDay17/"/>
    <url>/2023/03/03/CarlDay17/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">Question</a><br>It is labeled as an easy question, but there are some important points: create a new function for the question, how to choose the <strong>return value</strong>, lambda formular.<br>Firtly, what is a <strong>Balanced tree</strong>. By <a href="https://www.geeksforgeeks.org/balanced-binary-tree/">geeksforgeeks</a><br><strong>balanced binary tree</strong> is a binary tree that follows the 3 conditions: </p><ul><li>The height of the left and right tree for any node does not differ by more than 1</li><li>The left subtree of that node is also balanced.</li><li>The right subtree of that node is also balanced.<br>And, what is height? <strong>Heigth</strong> is the shortest simple route from the node to leef node. If we want to obtain its height, we have to use the <strong>post-order traverse</strong>.  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> calcuHeight(root) !=-<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcuHeight</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lh</span> <span class="hljs-operator">=</span> calcuHeight(root.left);<br>        <span class="hljs-keyword">if</span>(lh == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> calcuHeight(root.right);<br>        <span class="hljs-keyword">if</span>(rh == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (Math.abs(lh-rh)&gt;<span class="hljs-number">1</span>)? -<span class="hljs-number">1</span>: Math.max(lh,rh) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="For-tree-recurive-question"><a href="#For-tree-recurive-question" class="headerlink" title="For tree recurive question"></a>For tree recurive question</h1><p>For a recursive problem, we can follow 5 steps:</p><ol><li>Need a new function?</li><li>which traverse should we take: in-order, post-order, pre-order.</li><li>identify input and return</li><li>identify the end condition</li><li>identify the process in single recurion</li></ol><h1 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a>257. Binary Tree Paths</h1><p>In this question we Have to focus on the <strong>input</strong> of <em>traverse function</em> and how to use the <em>StringBuilder()</em><br>It is a DFS question, and it is a pre-order question. we need to consider <strong>whether the node is leaf or not</strong>, if leaf, then add the path to <em>res</em>, if not then add to <em>path</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>     <br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        traverse(root, <span class="hljs-string">&quot;&quot;</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root,String path, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path);<br>            sb.append(Integer.toString(root.val));<br>            <br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp;root.right == <span class="hljs-literal">null</span>)&#123;<br>                res.add(sb.toString());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            traverse(root.left, sb.toString(), res);<br>            traverse(root.right, sb.toString(),res);<br>        &#125;<br>        <span class="hljs-comment">//pre-order</span><br>    &#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">Question</a><br>Same as the depth of a tree, if we clearly figure out what is the meaning of the function, it is easier to write solution  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.right);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> leftValue + rightValue;<br>    <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.left.left == <span class="hljs-literal">null</span> &amp;&amp; root.left.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//means the node is a leaf</span><br>        sum += root.left.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 16 | LC104 Maximum Depth of Binary Tree, LC111 Minimum Depth of Binary Tree</title>
    <link href="/2023/03/02/CarlDay16/"/>
    <url>/2023/03/02/CarlDay16/</url>
    
    <content type="html"><![CDATA[<p>LC104 Maximum Depth of Binary Tree, LC111 Minimum Depth of Binary Tree<br><span id="more"></span></p><h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>there are two solution to this problems, one is Iterative by Layer-order traverse. When reach one layer, then <em>result++</em>. Then we can use the template to finish it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    que.offer(root);<br><br>    <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) que.offer(cur.left);<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) que.offer(cur.right);<br><br>        &#125;<br>        depth++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><br>But there is an easier way to fixit is recursive method. As we can identify, the meaning of function is the maximum of tree. So we can compute its child-tree’s depth and choose the max of them then plus one.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(leftMax, rightMax)+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h1><p>At first glance we might simply think it uses the same method as <em>Maximum Depth of Binary Tree</em>. However, it is not that easy, there are more details inside it. We can easily think of the traversal method. Then the end condition is <strong>reach the leaf node of any tree</strong>, which is <code>cur.left == null &amp;&amp; cur.right == null</code>. So the answer is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>         q.offer(root);<br><br>         <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>             <br>             <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>             <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ; i++)&#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                 <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base: reach the leaf node of any tree</span><br>                     <span class="hljs-keyword">return</span> depth;<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.left);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.right);<br>                 &#125;<br>             &#125;<br>             depth++;<br>             <br>         &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><br>What if we try the recursive method as the <em>maxDepth</em>?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> minDepth(root.right);<br><br>       <span class="hljs-keyword">return</span> Math.min(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><br>Sadly it occurs error when input a tree with only right or left tree like the figure shows.<br><img src="/img/minDepth.png" alt="minDepth"><br>So we have to deal with it by adding some terms.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> minDepth(root.right);<br><br>       <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;<br>       &#125;<br><br>         <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> Math.min(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">Question</a><br>Firstly, we shold distinct the full <strong>binary tree</strong> and <strong>complete tree</strong><br>according to <a href="https://en.wikipedia.org/wiki/Binary_tree">wikipedia</a> </p><ul><li><strong>full tree</strong> : is a tree in which every node has either 0 or 2 children.</li></ul><p><img src="/img/Full_binary.svg" alt="Full_binary"></p><ul><li><p><strong>Comlete binary tree</strong> : a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.<br><img src="/img/Complete_binary2.svg" alt="Complete_binary2"></p></li><li><p><strong>perfect binary tree</strong>: a binary tree in which all interior nodes have two children and all leaves have the same depth or same level  </p></li></ul><p>So if the subtree has same depth, then it is a full binary tree, we can calculate the node by $n = 2^{depth} - 1$<br><img src="/img/Count Complete Tree Nodes.png" alt="Count Complete Tree Nodes"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> root, r = root;<br>    <span class="hljs-comment">// height of left and right tree</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hl</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l != <span class="hljs-literal">null</span>) &#123;<br>        l = l.left;<br>        hl++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (r != <span class="hljs-literal">null</span>) &#123;<br>        r = r.right;<br>        hr++;<br>    &#125;<br>    <span class="hljs-comment">// height same --&gt; full</span><br>    <span class="hljs-keyword">if</span> (hl == hr) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, hl) - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 15 | LC107, LC199, LC637, LC515, LC116, LC 117, LC103, LC226, LC 101</title>
    <link href="/2023/03/01/CarlDay15/"/>
    <url>/2023/03/01/CarlDay15/</url>
    
    <content type="html"><![CDATA[<p>LC107 Binary Tree Level Order Traversal II, LC199 Binary Tree Right Side View, LC637 Average of Levels in Binary Tree, LC515 Find Largest Value in Each Tree Row, LC116. Populating Next Right Pointers in Each Node, LC117. Populating Next Right Pointers in Each Node II, LC104 Maximum Depth of Binary Tree, LC226 Invert Binary Tree, LC101 Symmetric Tree<br><span id="more"></span></p><h1 id="Template-for-layer-order-traverse"><a href="#Template-for-layer-order-traverse" class="headerlink" title="Template for layer-order traverse"></a>Template for layer-order traverse</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFun02</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">///base</span><br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        que.offer(node);<span class="hljs-comment">//add the root node</span><br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();/<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<span class="hljs-comment">//notice this should not be in the loop</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123; <br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> que.poll();<br>                itemList.add(tmpNode.val);<br><br>                <span class="hljs-keyword">if</span> (tmpNode.left != <span class="hljs-literal">null</span>) que.offer(tmpNode.left);<br>                <span class="hljs-keyword">if</span> (tmpNode.right != <span class="hljs-literal">null</span>) que.offer(tmpNode.right);<br>            &#125;<br><br>            resList.add(itemList);<span class="hljs-comment">//add each layers result</span><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="LC107-Binary-Tree-Level-Order-Traversal-II"><a href="#LC107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="LC107 Binary Tree Level Order Traversal II"></a>LC107 Binary Tree Level Order Traversal II</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//必须是linkedlist 否则不能addFirst</span><br>       <br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span>  res;<br>       &#125;<br>       Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<span class="hljs-comment">//注意sz在这理而不是在for里，不然每次循环sz都会变</span><br>           <br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               <br>               level.add(cur.val);<br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br><br>           &#125;<br>           res.addFirst(level);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;  <br></code></pre></td></tr></table></figure><h1 id="LC199-Binary-Tree-Right-Side-View"><a href="#LC199-Binary-Tree-Right-Side-View" class="headerlink" title="LC199 Binary Tree Right Side View"></a>LC199 Binary Tree Right Side View</h1><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br><br>       Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz ; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(i == sz - <span class="hljs-number">1</span>)&#123;<br>                   <span class="hljs-comment">// System.out.println(i);</span><br>                   res.add(cur.val);<br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC637-Average-of-Levels-in-Binary-Tree"><a href="#LC637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="LC637 Average of Levels in Binary Tree"></a>LC637 Average of Levels in Binary Tree</h1><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">Question</a><br>In this question, we have to identify where is the start of level traverse. The <em>while</em> loop is used to traverse from top to botom. <em>for</em> loop is used to traverse from left to right, so if we wanna process each node’s value, we have to do it before it offers its right and left nodes<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title function_">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Double&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.offer(root);<br><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                sum += cur.val;<br><br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.right);<br>                &#125;<br><br>                &#125;<br>            res.add(sum/sz);<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>     &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span> &lt;&gt;();<br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ;i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                level.add(cur.val);<br>                <span class="hljs-keyword">for</span> (Node child : cur.children) &#123;<br>                    q.offer(child);<br>            &#125;<br>            <br>        &#125;<br>        <br>        res.add(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC515-Find-Largest-Value-in-Each-Tree-Row"><a href="#LC515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="LC515 Find Largest Value in Each Tree Row"></a>LC515 Find Largest Value in Each Tree Row</h1><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br>       Queue &lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               max = Math.max(max,cur.val);<br>               <br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br>            <br>           &#125;<br>           res.add(max);<span class="hljs-comment">//add maximum after each level </span><br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LC116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LC116. Populating Next Right Pointers in Each Node"></a>LC116. Populating Next Right Pointers in Each Node</h1><p>This question, the difficulty is how to connect two seperate treenodes. We can consider it  as a Ternary Tree and then traverse the whole tree, which link left node to right inside one tree and link nodes between trees<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        traverse(root.left, root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(Node node1, Node node2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span>|| node2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        node1.next = node2;<br>        traverse(node1.left, node1.right);<br>        traverse(node2.left, node2.right);<br>        traverse(node1.right, node2.left );<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#LC117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="LC117. Populating Next Right Pointers in Each Node II"></a>LC117. Populating Next Right Pointers in Each Node II</h1><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>        Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// use a prenode to identify whether this is the first node of each level. Just like the Dummy node in linkedlist</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                <br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>)&#123;<br>                    pre.next = cur;<br>                &#125;<br>                pre = cur;<br><br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.right);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC104-Maximum-Depth-of-Binary-Tree"><a href="#LC104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LC104 Maximum Depth of Binary Tree"></a>LC104 Maximum Depth of Binary Tree</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">Question</a><br>In this question, I prefer the recursion instead of traverse each level.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>    <span class="hljs-keyword">return</span> Math.max(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>It is quite simple isnt it? Just figure out what’s the recursion doing. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>         q.offer(root);<br><br>         <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>             <br>             <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>             <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ; i++)&#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                 <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base: reach the leaf node of any tree</span><br>                     <span class="hljs-keyword">return</span> depth;<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.left);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.right);<br>                 &#125;<br>             &#125;<br>             depth++;<br>             <br>         &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="LC226-Invert-Binary-Tree"><a href="#LC226-Invert-Binary-Tree" class="headerlink" title="LC226 Invert Binary Tree"></a>LC226 Invert Binary Tree</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">Question</a><br>An easy question. What we should do is </p><ol><li>indentify the return value and input parameters</li><li>the end base </li><li>logic in each recursion<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightTree</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftTree</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>       <br>       root.left = rightTree;<br>       root.right = leftTree;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="LC101-Symmetric-Tree"><a href="#LC101-Symmetric-Tree" class="headerlink" title="LC101 Symmetric Tree"></a>LC101 Symmetric Tree</h1><a href="https://leetcode.cn/problems/symmetric-tree/">Question</a>  </li></ol><p>The most important note in this question is how to identify the end. We have to seperately consider the 4 situations. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">return</span> compare(root.left, root.right);<br>   &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>       <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right  != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right !=<span class="hljs-literal">null</span> &amp;&amp; left.val != right.val)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">compareOutside</span> <span class="hljs-operator">=</span> compare(left.left, right.right);<br>       <br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">compareInside</span> <span class="hljs-operator">=</span> compare(left.right, right.left);<br>       <span class="hljs-keyword">return</span> compareOutside &amp;&amp; compareInside;<br><br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 14 | Binary tree basis</title>
    <link href="/2023/03/01/CarlDay14/"/>
    <url>/2023/03/01/CarlDay14/</url>
    
    <content type="html"><![CDATA[<p>Binary tree basis<br><span id="more"></span></p><h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><p>In Java the TreeNode is defined<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode()&#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val)&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right)&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h1><p>No matter preorder, inorder or postordder traverse, the main different is whill should we do some process, here is the skeleton<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// pre order process</span><br>    traverse(root.left);<br>    <span class="hljs-comment">//in order process</span><br>    traverse(root.right);<br><br>    <span class="hljs-comment">// post order</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br>According to <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-334dd/">Labuladong</a>, when we try to figure out a tree problem when shold consider  </p><pre><code class="hljs">1. Is it possible to get the answer by traversing the binary tree? If possible, implement it with a traverse function with external variables.2. Is it possible to define a recursive function to derive the answer to the original question through the answer to the sub-question (subtree)? If possible, write the definition of this recursive function, and make full use of the return value of this function.3. No matter which thinking mode you use, you must understand what each node of the binary tree needs to do, and when it needs to be done (front, middle, and back order).</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 13 | LC239 Sliding Window Maximum, LC347 Top K Frequent Elements（Unfinished)</title>
    <link href="/2023/02/28/CarlDay13/"/>
    <url>/2023/02/28/CarlDay13/</url>
    
    <content type="html"><![CDATA[<p>Using monotonic queue to solve LC239 &amp; 347<br><span id="more"></span></p><h1 id="LC239-Sliding-Window-Maximum"><a href="#LC239-Sliding-Window-Maximum" class="headerlink" title="LC239 Sliding Window Maximum"></a>LC239 Sliding Window Maximum</h1><p>When we tried to move the window, it really like we are <em>poping</em> and <em>pushing</em> element in a queue. But using the direct solution to check the maximum will be a <strong>O(n*k)</strong> time cost. So we can maintain a monotonic queue. Unlike the normal big stack and small stack, it maintains a queue that may become the maximum value in a sliding window.    </p><h4 id="The-difference-between-add-and-offer-in-Queue"><a href="#The-difference-between-add-and-offer-in-Queue" class="headerlink" title="The difference between add() and offer in Queue:"></a>The difference between <code>add()</code> and <code>offer</code> in Queue:</h4><ul><li><code>add()</code>,<code>remove</code>,<code>element</code>: throws an exception</li><li><code>offer()</code>,<code>poll()</code>,<code>peek</code>: returns a special value: null or false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">MonotonicQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicQueue</span>();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; k - <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// fullfill first k -1 queue, if fullfill the window then will miss the first maxvalue</span><br>                mq.offer(nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mq.offer(nums[i]);<br>                res.add(mq.maxValue());<br>                mq.poll(nums[i - k + <span class="hljs-number">1</span>]);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            arr[i] = res.get(i);<br>    &#125;<br>     <span class="hljs-keyword">return</span> arr;<br>       <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    Deque&lt;Integer&gt; de = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">while</span>(!de.isEmpty() &amp;&amp; de.peekLast() &lt; n)&#123;<span class="hljs-comment">// when we add a new element, we have to compare it with the Last element instead of First bcs we need to maintain is mono</span><br>            de.pollLast();<br>        &#125;<br>        de.offerLast(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> de.peekFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span> (n == de.getFirst()) &#123;<br>            de.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 11 | LC20 Valid parentheses, LC1047 Remove All Adjacent Duplicates In String, LC150. Evaluate Reverse Polish Notation</title>
    <link href="/2023/02/25/CarlDay11/"/>
    <url>/2023/02/25/CarlDay11/</url>
    
    <content type="html"><![CDATA[<p>LC20,1047,150<br><span id="more"></span><br>When we handle the elemination question, it will be useful to use stack.<br>But one thing is important that <strong>stack</strong> is not recommended in Java becasue of its low efficiency. We prefer <em>deque</em>. But for better understanding, we use stack in this blog.</p><h1 id="LC20-Valid-parentheses"><a href="#LC20-Valid-parentheses" class="headerlink" title="LC20 Valid parentheses"></a>LC20 Valid parentheses</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">Question</a><br>In this question, we have to pair the parenthese. We can use stack to pair them. If we meet left par, them push its right one into stack. When we go through all the string, if meet its one, then pop it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span>hexo &#123;<br>       Stack&lt;Character&gt; x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-comment">//    Deque&lt;Character&gt; x = new LinkedList&lt;&gt;()</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>           <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.isEmpty()||x.peek()!=c)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               x.pop();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x.isEmpty();<span class="hljs-comment">//notice the return value</span><br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h1><p>Like LC20, easy but will use <em>Stringbuffer</em>. Check every char, when it is the peek of stack, then pop stack.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque &lt;Character&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>           ch = s.charAt(i) ;<br>           <br>           <span class="hljs-keyword">if</span>(que.isEmpty()||que.peek() != ch)&#123;<br>               que.push(ch);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               que.pop();<br>           &#125;<br>           <br>        &#125;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            res.append(que.pollLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC150-Evaluate-Reverse-Polish-Notation"><a href="#LC150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="LC150. Evaluate Reverse Polish Notation"></a>LC150. Evaluate Reverse Polish Notation</h1><p>The Reverse polish notation is proposed for the Stack calculation in computer. it is very easy that, we push <em>intereger</em> into stack, if we meet a calculator, we pop 2 elements and calculate. Then push the result into stack.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>      Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span>(String token: tokens)&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;+-/*&quot;</span>.contains(token))&#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> s.pop(), b = s.pop();<br>              <span class="hljs-keyword">switch</span>(token)&#123;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    s.push(a + b);<br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    s.push(b - a);<span class="hljs-comment">// notice that it is b-a instead of a-b</span><br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    s.push(a * b);<br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                  s.push(b / a); <span class="hljs-comment">// b/a instead of a/b</span><br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              s.push(Integer.parseInt(token));<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> s.pop();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 10 | LC232 Implement Queue using Stacks LC225 Implement Stack using Queues</title>
    <link href="/2023/02/25/CarlDay10/"/>
    <url>/2023/02/25/CarlDay10/</url>
    
    <content type="html"><![CDATA[<h1 id="Stack-and-queue"><a href="#Stack-and-queue" class="headerlink" title="Stack and queue"></a>Stack and queue</h1><p>In this part, the most important thing is to know what is the differences between queue and stack. Besides We have to get familiar with methods in stack and queue.<br>In stack, it is FILO, queue is FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Stack</span><br>Stack&lt;Integer&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span> &lt;&gt;();<br>s1.push();<br>s1.pop();<br>s1.peek();<br>s1.empty() <span class="hljs-comment">//check whether it is empty </span><br><br><span class="hljs-comment">//Deque. it can be used in FIFO and FILO</span><br>Deque&lt;Integer&gt; de = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>&lt;Integer&gt;();<br>de.addLast();<br>de.offerLast();<br>de.removeFirst();<br>de.poll <span class="hljs-title function_">first</span><span class="hljs-params">()</span>;<br>de.getFirst();<br>de.peekFirst();<br><br></code></pre></td></tr></table></figure></p><h1 id="LC232-Implement-Queue-using-Stacks"><a href="#LC232-Implement-Queue-using-Stacks" class="headerlink" title="LC232 Implement Queue using Stacks"></a>LC232 Implement Queue using Stacks</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">Question</a><br>As said before, the differences between queue and stack is FIFO or FILO.<br>So to implement a queue, we can implement 2 stacks. One for in-put and one for out-put.<br>When new element is pushed in the queue, it enter <em>inStack</em>. If we wanna pop one element, we have to pop element from <em>inStack</em> to <em>outStack</em>, then pop from <em>outStack</em>, so as to <em>peek()</em>.<br>So the answer is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; in, out;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        in.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(out.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!in.isEmpty())&#123;<br>                out.push(in.pop());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> out.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(out.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!in.isEmpty())&#123;<br>                out.push(in.pop());<br>            &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> out.peek();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC225-Implement-Stack-using-Queues"><a href="#LC225-Implement-Stack-using-Queues" class="headerlink" title="LC225. Implement Stack using Queues"></a>LC225. Implement Stack using Queues</h1><p>From FIFO to FILO. To implement it, we can offer the first ele in queue and push in to queue again, then we can get a FILO. But we have to maintain a variable <em>top</em> to save the top element of queue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123;<br>    Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        q.offer(x);<br>        top = x;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> top;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> q.size();<br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">2</span>)&#123;<br>            q.offer(q.poll());<br>            size--;<br>        &#125;<br>        <br>        top = q.peek();<br>        q.offer(q.poll());<br>        <span class="hljs-keyword">return</span> q.poll();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> q.isEmpty();<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network Theory Lecture Notes Lec 1&amp;2</title>
    <link href="/2023/02/23/NetworkTheory1&amp;2/"/>
    <url>/2023/02/23/NetworkTheory1&amp;2/</url>
    
    <content type="html"><![CDATA[<h1 id="Lec-1-Networks-and-Graphs"><a href="#Lec-1-Networks-and-Graphs" class="headerlink" title="Lec 1 Networks and Graphs"></a>Lec 1 Networks and Graphs</h1><h2 id="Some-definition"><a href="#Some-definition" class="headerlink" title="Some definition"></a>Some definition</h2><ul><li>Network</li><li>Adjacency matrix </li><li>Directed graph &amp; undirected graph</li><li>degree of node: how many edges connected to the node </li><li>connected graph and disconnected node: depend on <em>isolate node</em></li><li>Connectivity of Directed graph<ul><li>strongly connected: any node can reach any node via directed path</li><li>Direceted Acyclic Graph(DAG): has no cycles</li></ul></li><li>$no. edge \geq no.Vertices - no.components$</li><li><strong>DFS</strong> can be used to explore the graph repeatedly until the entire graph has been traversed </li><li><strong>BFS</strong> can</li><li>Weighted graph </li><li>complete graph: has maximum number of edges— node that has $n(n-1)/2$ edges</li><li>Bipartite graph<ul><li>ndoes can be divided into two disjoint sets, these two sets are independent</li><li>every link connects a node in U to one node in V</li></ul></li><li>Tree: a connected (undirected) graph with no cycles<ul><li>has only n-1 edges</li><li>unique path between any two nodes</li></ul></li></ul><h2 id="Measures-to-describe-Network"><a href="#Measures-to-describe-Network" class="headerlink" title="Measures to describe Network"></a>Measures to describe Network</h2><ul><li>Degree distributions:$P(k) = N(k)/n$, N(k) is number of nodes with degree k.</li><li>Distance:the number of edges along the shortest path connecting those nodes.</li><li>Diameter: the largest distance between any two nodes</li><li>average path length</li><li><p>Clustering coefficient</p><ul><li><p>for node i with degree $k_i$, the coefficient is </p><script type="math/tex; mode=display">C_i = \frac{2e_i}{k_i(k_i - 1)}e_i is the number of edges between the neighbors of node i</script></li><li><p>Average clustering: $C = \frac{1}{N}\sum{C_i}$</p></li></ul></li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><ul><li>for any connected graph there is a spanning tree that maintains connectivity but contains no cycle(close loop)<h3 id="Construction-a-spanning-tree"><a href="#Construction-a-spanning-tree" class="headerlink" title="Construction a spanning tree"></a>Construction a spanning tree</h3></li></ul><ol><li>select any node in N; N’ = {n}; E’={}</li><li>if N’ = N, stop</li><li>choose (i,j) $\in$ E, i $\in$ N’, j $\notin$ N’<ol><li>$N := N’ \cup {j}$</li><li>$E’ := E \cup {(i,j)}$</li><li>Go main  step 2</li></ol></li></ol><p><strong>The spanning tree is not unique</strong></p><h3 id="If-G-is-a-connected-graph-of-n-nodes"><a href="#If-G-is-a-connected-graph-of-n-nodes" class="headerlink" title="If G is a connected graph of n nodes"></a>If G is a connected graph of n nodes</h3><ul><li>G contains at least n-1 edges</li><li>G contains a spanning tree</li><li>if G contains exactly n-1 edges, G is a spanning tree</li></ul><h3 id="To-determine-a-Minimum-Spanning-Tree-MST"><a href="#To-determine-a-Minimum-Spanning-Tree-MST" class="headerlink" title="To determine a Minimum Spanning Tree(MST)"></a>To determine a Minimum Spanning Tree(MST)</h3><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html">文章</a></p><h4 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h4><p><strong>Start from an arbitrary vertex</strong><br>  Find u ∈ U and v ∈ V − U such that the edge (u, v) is a smallest edge between U and V − U.</p><h2 id="Distributed-Algorithm"><a href="#Distributed-Algorithm" class="headerlink" title="Distributed Algorithm"></a>Distributed Algorithm</h2><h3 id="Random-Graph-Model"><a href="#Random-Graph-Model" class="headerlink" title="Random Graph Model"></a>Random Graph Model</h3><p>Suppose: edge(u,v) is formed with probability $p \in (0,1)$, n is no. of nodes. Then <em>n</em> and <em>p</em> can’t define a unique graph</p><h3 id="Degree-distribution"><a href="#Degree-distribution" class="headerlink" title="Degree distribution"></a>Degree distribution</h3><ul><li>THe expected degree of a node </li></ul><script type="math/tex; mode=display">E[X_v] = (n - 1)p</script><p><img src="/img/Degree Distribution.png" alt="Degree Distribution"><br>As network size ++, distribution becomes <em>increasingly narrow</em></p><p><img src="/img/Clustering Coefficient in random graphs.png" alt="Clustering Coefficient in random graphs"></p><h1 id="Lecture-2-Small-World-phenomenon"><a href="#Lecture-2-Small-World-phenomenon" class="headerlink" title="Lecture 2 Small World phenomenon"></a>Lecture 2 Small World phenomenon</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><ul><li>Isolation of nodes: node that is not connected to the rest of the graph.</li><li>No. of Isolated nodes in a RG:<ul><li>$P[v has degree 0] = (1 - p)^{n-1} = e^{-c}(when n -&gt;\iint) $</li><li>we can obatin it by let $p = \frac{c}{n-1}$</li></ul></li><li>To have no islotated nodes<ul><li>To make $P(I) = ne^{-c} = 0$, we  can have<br><img src="/img/IsolatedNodes.png" alt="IsolatedNodes"><br><img src="/img/Graph structure.png" alt="Graph structure"></li></ul></li></ul><h2 id="Small-world-phenomena"><a href="#Small-world-phenomena" class="headerlink" title="Small world phenomena"></a>Small world phenomena</h2><ul><li>Def: Taking a connected graph and adding a very small number of edges randomly, the diameter tends to drop drastically.</li></ul><h2 id="Power-Law"><a href="#Power-Law" class="headerlink" title="Power Law"></a>Power Law</h2><ul><li>a functional relationship $p(k) = k^{-a}$ quantities, where one quantity varies as a power of another</li><li>与k负相关</li><li>Scale free network: Networks with a power law tail in their degree distribution<br><img src="/img/Scale-Free Nework.png" alt="Scale-Free Nework"></li><li>Power law is heavy tail</li><li><strong>Rich get richer:</strong> New nodes are more likely to link to nodes that already have high degree</li></ul><h1 id="Lecture-3-Probabilistic-models-of-Information-flow"><a href="#Lecture-3-Probabilistic-models-of-Information-flow" class="headerlink" title="Lecture 3 Probabilistic models of Information flow"></a>Lecture 3 Probabilistic models of Information flow</h1><ul><li>Information Cascade: When information nodes are connected by a network, it becomes possible to influence each other’s truth.</li></ul><h2 id="Diffusion"><a href="#Diffusion" class="headerlink" title="Diffusion"></a>Diffusion</h2><ul><li>Direct-benefit-effects<ul><li>simple self-interest will dictate that you should adopt the new behaviour o<strong>nce a sufficient proportion of the neighbours</strong> have done so</li></ul></li></ul><h2 id="Diffusion-Models"><a href="#Diffusion-Models" class="headerlink" title="Diffusion Models"></a>Diffusion Models</h2><h3 id="Decision-based-models"><a href="#Decision-based-models" class="headerlink" title="Decision based models"></a>Decision based models</h3><ul><li>Models of product adoption, decision making</li><li>A node observes decisions of its neighbours and makes its own decision</li><li>EG: You watch a movie if k of your friends told you about it<h3 id="Probabilistic-models"><a href="#Probabilistic-models" class="headerlink" title="Probabilistic models"></a>Probabilistic models</h3></li><li>Models of influence or disease spreading</li><li>eg: you got Covid with some probability from each active neighbour in the network</li></ul><h3 id="Cascades"><a href="#Cascades" class="headerlink" title="Cascades"></a>Cascades</h3><ul><li>limits: what causes stop<ul><li>structure</li><li>choice of initial adopters</li><li>value of the threshold<ul><li>1/2 is the golden choice: <strong>There is no (infinite) G where cascade capacity could exceed 1⁄2</strong> .</li></ul></li></ul></li><li>Capacity: largest q for which some finite set S can cause a cascade.</li></ul><h1 id="Lecture-4-Probabilistic-models-of-Information-flow"><a href="#Lecture-4-Probabilistic-models-of-Information-flow" class="headerlink" title="Lecture 4 Probabilistic models of Information flow"></a>Lecture 4 Probabilistic models of Information flow</h1><h2 id="SIR-Epidemic-Model"><a href="#SIR-Epidemic-Model" class="headerlink" title="SIR Epidemic Model"></a>SIR Epidemic Model</h2><ul><li><strong>S</strong>usceptible</li><li><strong>I</strong>nfectious</li><li><strong>R</strong>emoved: after the full infectious period, this node is removed from consideration and<br><img src="/public/img/SIRModel.png" alt="SIRModel"></li><li>In SIR model, once your are recovered you can never get infecte again<br><img src="/img/SIRModel2.png" alt="SIRModel2"></li></ul><h2 id="SIS-model"><a href="#SIS-model" class="headerlink" title="SIS model"></a>SIS model</h2><ul><li><strong>Recovered nodes immediately become susceptible</strong><br><img src="/img/SISModel.png" alt="SISModel"><br><img src="/img/SISModel2.png" alt="SISModel2"></li></ul><h2 id="Independent-Cascade-model"><a href="#Independent-Cascade-model" class="headerlink" title="Independent Cascade model"></a>Independent Cascade model</h2><ul><li>Init some nodes active and each aedge(u,v) has probability(weight)  </li><li>It is hard to estimate it, wo we can <ul><li>make all edges has same weight</li></ul></li></ul><h2 id="Exposure-and-Adaptation"><a href="#Exposure-and-Adaptation" class="headerlink" title="Exposure and Adaptation"></a>Exposure and Adaptation</h2><ul><li>Exposure: Node’s neighbour exposes the node to the information <ul><li>Probability of adopting new behaviour depends on the number of connection/friends who have already adopted</li></ul></li><li>Adoption: The node acts on the information</li></ul><h1 id="Lecture-5-Queueing-and-Modelling-Delay-in-the-Networks"><a href="#Lecture-5-Queueing-and-Modelling-Delay-in-the-Networks" class="headerlink" title="Lecture 5 Queueing and Modelling Delay in the Networks"></a>Lecture 5 Queueing and Modelling Delay in the Networks</h1><p>Queueing Systems: used for analysing network performance</p><h2 id="delay-models"><a href="#delay-models" class="headerlink" title="delay models"></a>delay models</h2><p><img src="/img/DelayModel.png" alt="DelayModel"></p><ul><li>Quantities<ul><li>Arrival rate of customers ( λ)</li><li>Service rate (μ)</li><li>Queue Utilisation (ρ = λ/μ)</li></ul></li></ul><h3 id="Little’s-Theorem"><a href="#Little’s-Theorem" class="headerlink" title="Little’s Theorem"></a>Little’s Theorem</h3><p><img src="/img/Little&#39;s Theorem" alt="Little&#39;s Theorem"><br>Can be applied to entire system or part of it.</p><h2 id="Single-Server-Queues"><a href="#Single-Server-Queues" class="headerlink" title="Single Server Queues"></a>Single Server Queues</h2><ul><li><p>M/M/1</p><ul><li>Poisson arrivals, exponential service  times</li></ul></li><li><p>Poinsson Process</p></li></ul><script type="math/tex; mode=display">P(n arrivals in interval T) = \frac{(λT)^ne^{-λT}}{n!}</script><ul><li>$E[n] (first moment of arrival)= λT$</li><li>$E[n^2] (second moment of arrival)= λT +(λT)^2$</li><li>$σ^2= λT$</li></ul><h2 id="Markov-Chain"><a href="#Markov-Chain" class="headerlink" title="Markov Chain"></a>Markov Chain</h2><ul><li>a memory-less: predictions about its future state without consulting past states.</li><li>$\Pr(X<em>NaN=x\mid X</em>{1}=x<em>{1},X</em>{2}=x<em>{2},\ldots ,X</em>{n}=x<em>{n})=\Pr(X</em>NaN=x\mid X<em>{n}=x</em>{n})$</li></ul><h2 id="Markov-for-M-M-1"><a href="#Markov-for-M-M-1" class="headerlink" title="Markov for M/M/1"></a>Markov for M/M/1</h2><p><img src="/img/Markov for M/M/1" alt="Markov for M/M/1"></p><ul><li>The probability of being in each state<script type="math/tex; mode=display">P(n) = ρ^n(1-ρ)</script>when n = 0, it means idel state</li></ul><h3 id="Average-Queue-size"><a href="#Average-Queue-size" class="headerlink" title="Average Queue size"></a>Average Queue size</h3><p><img src="/img/Average Queue size.png" alt="Average Queue size"></p><ul><li>Example<br><img src="/img/Average Queue sizeeg.png" alt="Average Queue sizeeg"></li></ul><h2 id="M-server-systems-M-M-m"><a href="#M-server-systems-M-M-m" class="headerlink" title="M server systems: M/M/m"></a>M server systems: M/M/m</h2><p><img src="/img/mmm.png" alt="mmm"><br>utilization factor</p><script type="math/tex; mode=display">ρ= λ/mμ</script><ul><li>all idel:<script type="math/tex; mode=display">P(0) = (1+ρ+)</script><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3>We can model the system as a Markov chain with three states:</li></ul><ol><li>State 0: Both servers are idle</li><li>State 1: One server is busy, one server is idle</li><li>State 2: Both servers are busy</li></ol>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network Theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 6 | KMP(complete later)</title>
    <link href="/2023/02/23/CarlDay9/"/>
    <url>/2023/02/23/CarlDay9/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>Where F and b do not match, it will return to the place where it matched before</p><ul><li>prefix table<br>Prefix: all strings including the first letter but not the last letter<br>Suffix: Contains only the last letter and does not contain the initial letter<br>longest equal suffix</li></ul><p>During the matching process, record the longest equal suffix and suffix. When a conflict occurs, the index returned by the pointer is the position of the longest suffix and suffix</p><p>When there is a string mismatch, you can know a part of the text content that has been matched before, and you can use this information to avoid matching from scratch</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm, carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 8 | LC344 reverse String, LC541 Rever se String II, LC151 Reverse Words in a String, Offer58 Reverse Left Words</title>
    <link href="/2023/02/22/CarlDay8/"/>
    <url>/2023/02/22/CarlDay8/</url>
    
    <content type="html"><![CDATA[<p>When we want to solve string problems, we can think of it as some kind of linked list. The topic will be simpler<br><span id="more"></span></p><h1 id="LC344-reverse-String"><a href="#LC344-reverse-String" class="headerlink" title="LC344 reverse String"></a>LC344 reverse String</h1><p><a href="https://leetcode.cn/problems/reverse-string/">Question</a><br>Just like reverse a linked array, use two-pointer <em>left</em> and <em>right</em>, point to start and end of the char. Then swap them.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC541-Reverse-String-II"><a href="#LC541-Reverse-String-II" class="headerlink" title="LC541 Reverse String II"></a>LC541 Reverse String II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">Question</a><br>Unlike LC 344, this problem is to reversed in groups. Reverse the first k every 2k, and reverse all when the mantissa is not enough k<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span> [] ch = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; ch.length; i +=<span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-keyword">if</span>(i + k &lt;= ch.length)&#123;<br>                reverse(ch, i, i + k - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            reverse(ch, i, ch.length - <span class="hljs-number">1</span>);            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> [] ch, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">for</span>(;i &lt; j; i++,j--)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ch[i];<br>            ch[i] = ch[j];<br>            ch[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="offer05-Replace-Space"><a href="#offer05-Replace-Space" class="headerlink" title="offer05: Replace Space"></a>offer05: Replace Space</h1><p>The topic is very simple, you only need to traverse it once. If you encounter a space, append a <em>%20</em>. For this question, you need to learn how to use <strong>StringBuilder</strong> and <strong>charAt()</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sb.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h1 id="LC151-Reverse-Words-in-a-String"><a href="#LC151-Reverse-Words-in-a-String" class="headerlink" title="LC151 Reverse Words in a String"></a>LC151 Reverse Words in a String</h1><p>Remove extra spaces first. Then flip the entire string, and flip the letters in each word.<br>The idea of this question is not very difficult. The difficult part is that the details of the code need to be adjusted, especially when cleaning the data. The other is the start and end points when reversing words</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <br>    <span class="hljs-comment">// remove extra space</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br><br>            sb.append(c);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// string after cleaning</span><br>    <span class="hljs-type">char</span>[] chars = sb.toString().toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chars.length;<br>    <span class="hljs-comment">// reverse whole string </span><br>    reverse(chars, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// reverse each word</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> == n || chars[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <br>                reverse(chars, i, j);<br>               <br>                i = j + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>        i++;<br>        j--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Offer58-Reverse-Left-Words"><a href="#Offer58-Reverse-Left-Words" class="headerlink" title="Offer58 Reverse Left Words"></a>Offer58 Reverse Left Words</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">Question</a><br>Reverse Left Words is to transfer several characters in front of the string to the end of the string.<br>The simplest way is use API <code>s.substring(n) + s.substring(0,n);</code><br>But it is not the aim of practicing programming. so the solution is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>    StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>    reverseString(sb,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    reverseString(sb,n,len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sb.charAt(start);<br>        sb.setCharAt(start, sb.charAt(end));<br>        sb.setCharAt(end, temp);<br>        start++;<br>        end--;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://programmercarl.com/0151.翻转字符串里的单词.html#其他语言版本">代码随想录</a></li><li><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/">labuladong 的算法小抄</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nSum algorithm Problems</title>
    <link href="/2023/02/22/nsum/"/>
    <url>/2023/02/22/nsum/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>nSum problem is a type of very famous problem. On leetcode, we have <a href="https://leetcode.com/problems/two-sum/">two sum</a>, <a href="https://leetcode.com/problems/3sum/">3Sum</a>, <a href="https://leetcode.com/problems/4sum/">4Sum</a>. To solve these problems, we can use double-pointer method.<br>The basic way is <strong>Sort the array firstly, then double-pointer</strong>   </p><h2 id="two-sum"><a href="#two-sum" class="headerlink" title="two sum"></a>two sum</h2><p>The traditional method is using <strong>HashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Map&lt;Integer,Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(set1.containsKey(target-nums[i]))&#123;<br>                val = set1.get(target-nums[i]);<br>                res[<span class="hljs-number">0</span>] = val;<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            set1.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>But if we wanan return <strong>elements</strong> instead of <strong>index</strong>. Follow the main method, we should sort the array first and then use a <em>left</em> pointer and a <em>right</em> ponter to solve the problem.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[left], [right]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>To avoid the replicate elements like the input is <code>[1,1,1,2,2,3,3]</code>, we can jump the duplicate element when<code>sum == target</code><br>then we can have<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> nums[left], rValue = nums[right];<br><br>            <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == rValue)<br>                    right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                list.add(nums[left]);<br>                list.add(nums[right]);<br>                res.add(list);<br><br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == rValue)<br>                    right--;<br>               <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><p>After solving the generalization of two sum, we can easily extend the topic to 3 sum. The solution is to find the two sum of the remaining two numbers after the first number is determined.  As well, we generalize it into function with <em>int target</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>             List&lt;List&lt;Integer&gt;&gt; two = twoSum(nums, i+<span class="hljs-number">1</span>, target - nums[i]);<br>   <br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; x : two)&#123;<br>            x.add(nums[i]);<br>            res.add(x);<br>        &#125;<br>        <span class="hljs-comment">//To avoid the duplicate</span><br>        <span class="hljs-keyword">while</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>]) <br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// two sum</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start, right = nums.length - <span class="hljs-number">1</span>;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> nums[left], rValue = nums[right];<br><br>            <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == rValue)<br>                    right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                list.add(nums[left]);<br>                list.add(nums[right]);<br>                res.add(list);<br><br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == rValue)<br>                    right--;<br>               <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h2><p>Question: <a href="https://leetcode.com/problems/4sum/">4Sum</a><br>For 4 sum, we just need to calculate 3 sum first, and the left is like what 3sum does to 2 sum. But what has to be noticed is that we need to use <strong>long</strong>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/yi-ge-fang-894da/">labuladong的算法小抄</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 7 | LC454 4Sum II, LC383 Ransom Note, LC15 3sum, LC18 4sum</title>
    <link href="/2023/02/21/CarlDay7/"/>
    <url>/2023/02/21/CarlDay7/</url>
    
    <content type="html"><![CDATA[<p>LC454 4Sum II, LC383 Ransom Note, LC15 3sum, LC18 4sum<br><span id="more"></span></p><h1 id="LC454-4Sum-II"><a href="#LC454-4Sum-II" class="headerlink" title="LC454 4Sum II"></a>LC454 4Sum II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">Question</a><br>In this question, the most important thing is to get familiar with the methdo in <em>HashMap</em>, we can visit the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Oracle java document</a> to find the methods needed. The most common methods are<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/* methods</span><br><span class="hljs-comment">*/</span><br>    put(K key, V value)<br>        <span class="hljs-comment">//Associates the specified value with the specified key in this map</span><br>        get(Object key)<br>        <span class="hljs-comment">//Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.</span><br>        remove(Object key)<br>        size()<br>        isEmpty()<br>    containsKey(Object key)<br>        <span class="hljs-comment">//Returns true if this map contains a mapping for the specified key.    </span><br>        containsValue(Object value)<br>        <span class="hljs-comment">//Returns true if this map maps one or more keys to the specified value</span><br>        <br><br>        <span class="hljs-comment">/* Methods inherited from class java.util.AbstractMap</span><br><span class="hljs-comment">        */</span><br>        equals, hashCode, toString<br>        <br></code></pre></td></tr></table></figure><br>The solution of this question is easy. Use a HashMap to store sums of the first two arrays, and then check whether the sums of last two arrays are contained. In HashMap, <em>key</em> is the sum of number, <em>value</em> is times they showed.<br>Solution:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; sum1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">if</span>(sum1.containsKey(sum))&#123;<br>                    sum1.put(sum, sum1.get(sum) + <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sum1.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums4)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">if</span>(sum1.containsKey(<span class="hljs-number">0</span> - sum))&#123;<br>                    res += sum1.get(<span class="hljs-number">0</span> - sum);<br>                   <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC383-Ransom-Note"><a href="#LC383-Ransom-Note" class="headerlink" title="LC383 Ransom Note"></a>LC383 Ransom Note</h1><p>Same as LC242 Valid Anagram, check <a href="CarlDay6.md">former notes</a>. Just notice the <code>str.toCharArray()</code> method.<br>Here is the solution<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-type">int</span> [] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine.toCharArray())&#123;<br>            arr[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote.toCharArray())&#123;<br>            arr[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : arr)&#123;<br>            <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC15-3sum-LC18-4sum"><a href="#LC15-3sum-LC18-4sum" class="headerlink" title="LC15 3sum LC18 4sum"></a>LC15 3sum LC18 4sum</h1><p>see the <a href="https://alcuinyang.github.io/2023/02/22/nsum/">nSum</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PThread library Basic</title>
    <link href="/2023/02/21/PThread/"/>
    <url>/2023/02/21/PThread/</url>
    
    <content type="html"><![CDATA[<p>PThread library, including basics, thread creation and termination, stnchronization, shceduling, pitfalls, debugging<br><span id="more"></span></p><h1 id="PThread-Intro"><a href="#PThread-Intro" class="headerlink" title="PThread Intro"></a>PThread Intro</h1><p>POSIX threads are standards based thread API. It is used to  spawn a new concurrent process flow. Threads require less overhead than “forking” or spawning a new process because the system does not initialize a new system virtual memory space and environment for the process. arallel programming technologies such as MPI and PVM are used in a distributed computing environment while threads are limited to a single computer system.<br>All threads within a process sahre the same address space:</p><ul><li>Process instruction</li><li>most data</li><li>open files9descriptors)</li><li>signals and signal handlers </li><li>current working direc</li><li>user and group ID</li></ul><h2 id="Thread-Basics"><a href="#Thread-Basics" class="headerlink" title="Thread Basics"></a>Thread Basics</h2><p>Thread operations include <strong>thread creation</strong>, <strong>termination</strong>, <strong>synchronization</strong> (joins,blocking), <strong>scheduling</strong>, <strong>data management</strong> and <strong>process interaction</strong>.<br>each thread has unique:</p><ul><li>PID</li><li>set of register, stack pointer</li><li>stack for local variables, return address</li><li>signal mask </li><li>priority</li><li>return value</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">CMU tut</a>  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C, master, PThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 6 | LC242 Valid Anagram LC349 Intersection of Two Arrays LC202 Happy Number LC1 two sum</title>
    <link href="/2023/02/21/CarlDay6/"/>
    <url>/2023/02/21/CarlDay6/</url>
    
    <content type="html"><![CDATA[<p>HashTable. Including: LC242 Valid Anagram LC349 Intersection of Two Arrays LC202 Happy Number LC1 two sum<br><span id="more"></span></p><h1 id="Hash-Table-Intro"><a href="#Hash-Table-Intro" class="headerlink" title="Hash Table Intro"></a>Hash Table Intro</h1><p>Hash table is a map with <strong>Key</strong> and <strong>Value</strong>. It is an one2one mapping by using <strong>Hash function</strong>. In this way we can access the element in <strong>O(1)</strong> time.<br>To implement hash table, we often use <strong>array, set, map</strong></p><h2 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h2><ul><li>def: two values mapping one key.<h3 id="solution"><a href="#solution" class="headerlink" title="solution:"></a>solution:</h3><h4 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h4>It is usually implemented using linked lists. If there is any collision (i.e. two different elements have same hash value) then store both the elements in the same linked list.<h4 id="Linear-probing"><a href="#Linear-probing" class="headerlink" title="Linear probing"></a>Linear probing</h4></li></ul><h1 id="LC242-Valid-Anagram"><a href="#LC242-Valid-Anagram" class="headerlink" title="LC242 Valid Anagram"></a>LC242 Valid Anagram</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">Question</a><br>Using an array to store 26 characters. In string <em>s</em>, if one characters shows, then the related position add 1. After this, check <em>t</em>, if character shows, postion minus 1. Finally, check the array, if all 0, then true. Else, false.  </p><p><strong>Notice:</strong></p><ol><li>to identify the position, we can use <code>int pos = c - &#39;a&#39;</code></li><li>String cant be process dirctly, we should use <code>s.toCharArray()</code> to transfer it into char.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> [] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            count[n]++;<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: t.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            count[n]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; count.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i]!= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="LC349-Intersection-of-Two-Arrays"><a href="#LC349-Intersection-of-Two-Arrays" class="headerlink" title="LC349 Intersection of Two Arrays"></a>LC349 Intersection of Two Arrays</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">Question</a><br>For intersection, the result is an unordered set with no duplicate elements. So we use set to solve this problem. Use two sets. One to iterate over the first array. Then check whether the value of the second input is in this set, and if it exists, add it to the result set. Then convert the result set into an array<br><strong>Notice</strong>:</p><ul><li>we cant use set all the time because it needs more space to store and slower than array.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            set1.add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>            <span class="hljs-keyword">if</span>(set1.contains(j))&#123;<br>                set2.add(j);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// resArray = set2.toArray();</span><br>        <span class="hljs-comment">// int[] ints = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();</span><br>        <span class="hljs-keyword">return</span> set2.stream().mapToInt(Integer::valueOf).toArray();<span class="hljs-comment">//transfer to array</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="LC202-Happy-Number"><a href="#LC202-Happy-Number" class="headerlink" title="LC202 Happy Number"></a>LC202 Happy Number</h1><a href="https://leetcode.cn/problems/happy-number/">Question</a><br><strong>Happy number is not happy</strong><br>It is an interesting question. We just need to remember one thing: as long as there are repeated numbers, there will be an infinite loop. So if there are repeated numbers, return flase. Note: Repeat numbers. Let us think of using hash set.<br>Notice:<br>The implementation of get next number is good. especially the <code>while(n&gt;0)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !res.contains(n)) &#123;<br>            res.add(n);<br>            n = getNextNumber(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            res += temp * temp;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="LC1-two-sum"><a href="#LC1-two-sum" class="headerlink" title="LC1 two sum"></a>LC1 two sum</h1><p><a href="https://leetcode.cn/problems/two-sum/">Question</a>  </p><p>Have done so many times bcs it is the first question of leetcode. It can be solved by <strong>two-pointer</strong> and <strong>HashMap</strong>. The solution of two-pointer is <a href="nsum.md">here</a>. Now is the <strong>HashMap</strong> solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Map&lt;Integer,Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(set1.containsKey(target-nums[i]))&#123;<br>                val = set1.get(target-nums[i]);<br>                res[<span class="hljs-number">0</span>] = val;<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            set1.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/">Basics of Hash Tables</a></li><li><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">ProgrammerCarl</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CarlDay3,4 | LC203 Remove Nth Node From End of List, LC707Design Linked List, LC206 Reverse Linked List,</title>
    <link href="/2023/02/20/CarlDay3&amp;4/"/>
    <url>/2023/02/20/CarlDay3&amp;4/</url>
    
    <content type="html"><![CDATA[<p>Linked List related.<br><span id="more"></span></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>LinkedList is a simple but important data structure. we usually use two-pointer, recursion to handle those problems. </p><h2 id="LC203-Remove-Linked-List-Elements"><a href="#LC203-Remove-Linked-List-Elements" class="headerlink" title="LC203 Remove Linked List Elements"></a>LC203 Remove Linked List Elements</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">Question</a><br>For a linklist, if we want to remove an element, we should use the code <code>node.next = node.next.next</code>. In this question, what we should notice is that, we need a <strong>dummy node</strong> to record the result, so that we can handle all the nodes in same way. If not, when we want to remove head node, there is no former nodes to execute <code>node.next = node.next.next</code><br>Here is the solution<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java">   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>            cur.next = cur.next.next;<br>        &#125;<span class="hljs-keyword">else</span><br><br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC707-Design-Linked-List"><a href="#LC707-Design-Linked-List" class="headerlink" title="LC707 Design Linked List"></a>LC707 Design Linked List</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">Question</a><br>using dummy node to handle the head<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    <span class="hljs-type">int</span> size;<br>    ListNode head;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(size, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        index = Math.max(<span class="hljs-number">0</span>, index);<br>        size++;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">toAdd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        toAdd.next = pred.next;<br>        pred.next = toAdd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size--;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br>        pred.next = pred.next.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="LC-206-Reverse-Linked-List"><a href="#LC-206-Reverse-Linked-List" class="headerlink" title="LC 206 Reverse Linked List"></a>LC 206 Reverse Linked List</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">Question</a><br>This is the most typical recursive topic, which can show the power of recursive methods. When we using recursive method, we should not be stunk by every recurve, we just need to know the result of the recur. Here is the solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>       head.next.next = head;<span class="hljs-comment">// Illustrate by later figure</span><br>       head.next = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">return</span> last;<br>   &#125;<br></code></pre></td></tr></table></figure><br><img src="/img/reverseLinkedList.jpeg" alt="figure"></p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="LC-24-Swap-Nodes-in-Pairs"><a href="#LC-24-Swap-Nodes-in-Pairs" class="headerlink" title="LC 24 Swap Nodes in Pairs"></a>LC 24 Swap Nodes in Pairs</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">Question</a><br>In this case we can consider the recursive method. Identify the base case and swap <code>head</code> and <code>head.next</code>. Then let <code>head</code> point to the result of <code>reverse(head.next.next)</code> .Plot the process for better understanding.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<span class="hljs-comment">//base case</span><br><br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> head.next.next;<br>    <br>    second.next = head;<br><br>    head.next = swapPairs(left);<br><br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><img src="/img/lc24.jpeg" alt="lc24"></p><h2 id="LC-19-Remove-Nth-Node-From-End-of-List"><a href="#LC-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="LC 19 Remove Nth Node From End of List"></a>LC 19 Remove Nth Node From End of List</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">Question</a><br>This is a two-pointer problem. After considering the base case, we can use a fast pointer and a slow pointer. After the fast pointer moves n times, the slow pointer starts to move. When the fast pointer points to the last position, the next node of the slow pointer is the node to be deleted.<br><strong>Remind, using dummy node to handle the list</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>           ListNode slow, fast;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>           dummy.next = head;<br><br>           slow = dummy;<br>           fast = dummy;<br><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>               fast = fast.next;<br>           &#125;<span class="hljs-comment">//fast fowards n nodes</span><br><br>           <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span>)&#123;<br>               fast = fast.next;<br>               slow = slow.next;<br>           &#125;<span class="hljs-comment">// foward both pointers</span><br><br>            slow.next = slow.next.next;<span class="hljs-comment">//delete</span><br><br>            <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC-160-Intersection-of-Two-Linked-Lists-LCCI"><a href="#LC-160-Intersection-of-Two-Linked-Lists-LCCI" class="headerlink" title="LC 160  Intersection of Two Linked Lists LCCI"></a>LC 160  Intersection of Two Linked Lists LCCI</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">Question</a><br>Use two pointers to traverse from AB respectively, connect another linked list when the traversal is completed, and end when the two pointers meet, and it is an intersecting node<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>   <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-comment">// P1 takes steps, if it reaches the end of A linked list, go to B linked list</span><br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>           <br>         p1 = p1.next;<br>        <span class="hljs-comment">// so as p1</span><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            <br>        p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC-142-Linked-List-Cycle-II"><a href="#LC-142-Linked-List-Cycle-II" class="headerlink" title="LC 142 Linked List Cycle II"></a>LC 142 Linked List Cycle II</h2><p><a href="./linkedarray.md">Wrote before</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notice!!!</title>
    <link href="/2023/02/18/notice/"/>
    <url>/2023/02/18/notice/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-02-18"><a href="#2023-02-18" class="headerlink" title="2023-02-18"></a>2023-02-18</h1><h2 id="文档乱码"><a href="#文档乱码" class="headerlink" title="文档乱码"></a>文档乱码</h2><p><strong>因为前几天电脑泡水了，time machine的备份也罢工了导致所有本地数据都没了，目前可以看到的博文很多都是刚刚恢复的，所以会有很多乱码，maybe之后抽空会慢慢修复。</strong></p><h2 id="关于博客内容"><a href="#关于博客内容" class="headerlink" title="关于博客内容"></a>关于博客内容</h2><p>因为是留英选手，强迫自己用英文写博客, 为了更好的和local交流、分享博客，也让自己对术语更熟悉一些，所以用英文写了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList (to be fixed)</title>
    <link href="/2023/02/17/linkedarray/"/>
    <url>/2023/02/17/linkedarray/</url>
    
    <content type="html"><![CDATA[<p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">题目</a><br>一个很简单的链表题，第一次做老忘记将指针向下一个移动，即<code>p = p.next</code><br>会用到虚拟头节点，可以避免处理空指针的情况，降低代码的复杂性</p></p><p><h2 id="合并k个生序链表"><a href="#合并k个生序链表" class="headerlink" title="合并k个生序链表"></a>合并k个生序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">题目</a><br>解题思路依然是寻找最小的结点然后连接到dummy上，but因为是k个链表，如果用最朴素的比较方法，会比较的次数较多，时间复杂度高，<strong>所以采用优先级队列</strong>，把链表接电放进去即可获得k个节点里的最小节点. <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/2/22/64/">二叉堆</a> 在这里讲的挺好的，可以参考。  </p></p><p><h2 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目</a><br>可以使用双指针fast指针先走k步，然后fast和slow同事走n-k步，slow就指向倒数第k个节点了  </p></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回链表的倒数第 k 个节点</span><br>ListNode <span class="hljs-title function_">findFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 先走 k 步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 和 p2 同时走 n - k 步</span><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br>```  <br>用这个方法+dummy node即可正确删除节点  <br>## 单链表的中点<br>[题目](https:<span class="hljs-comment">//leetcode.cn/problems/middle-of-the-linked-list/)  </span><br>依然快慢指针。这个题与**链表是否包含环** 解法差不多，快指针一次走两步，慢指针一次走一步，当快指针走到头的时候，慢指针正好是中点  <br>```Java<br>ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步  注意循环结束的点</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>是否有环&amp;&amp;环的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码类似 hasCycle 函数</span><br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// fast 遇到空指针说明没有环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 重新指向头结点</span><br>    slow = head;<br>    <span class="hljs-comment">// 快慢指针同步前进，相交点就是环起点</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：  </p><p><img src="/img/Midcycle1.png" srcset="/img/loading.gif" lazyload alt="img1"></p><p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了<br><img src="/img/Midcycle2.png" srcset="/img/loading.gif" lazyload alt="img2"></p><h2 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a><br>用俩指针，分别从AB遍历，当便利完时接上另一个，当两个指针相遇时结束，并且是节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span><br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>            p1 = p1.next;<br>        <span class="hljs-comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><p><h2 id="递归反转链表"><a href="#递归反转链表" class="headerlink" title="递归反转链表"></a>递归反转链表</h2><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目</a><br>反转链表可以使用递归和迭代两种办法，首先说迭代。<br><img src="/img/reverse1.png" srcset="/img/loading.gif" lazyload alt="reverse1"><br>迭代的方法是要存储当前节点  </p></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(List Node head)</span>&#123;<br>    ListNode pre,nxt,cur;<br>    pre = <span class="hljs-literal">null</span>;<br>    nxt = cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        nxt = cur.next;<br>        cur.next = pre;<br><br>        pre = cur;<br>        cur = nxt<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>再有就是递归解法，递归很有趣，采用的是假设，假设出了第一个以外的节点已经反转了，这个该怎么处理呢</p><p>&#96;&#96;&#96; java<br>public ListNode reverse(ListNode head){<br>    if(head &#x3D;&#x3D; null|| head.next &#x3D;&#x3D; null){ &#x2F;&#x2F; 递归函数的base case，意思是链表为空或者只有自己的时候，直接返回<br>        return head;<br>    }<br>    ListNode last &#x3D; reverse(head.next);<br>    head.next.next &#x3D; head;<br>    head.next &#x3D; null;</p><div class="code-wrapper"><pre><code class="hljs">return last;</code></pre></div><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>array</title>
    <link href="/2023/02/17/arrayed/"/>
    <url>/2023/02/17/arrayed/</url>
    
    <content type="html"><![CDATA[<p>数组属于是最基本的数据结构了，二分查找、滑动窗口、双指针等都在这里有体现。<br><span id="more"></span></p><p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>双指针经常用在数组、链表中，主要分为：<strong>左右指针和快慢指针</strong>  ，当出现了数组有序的情况，就要考虑是不是要用双指针</p></p><p><ul></p><p><li>左右指针：两个指针由两边往内走或者从内往两边走  </li></p><p><li>快慢指针：往一个方向走</li><br>&lt;/ul&gt;</p><p><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">题目1</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">题目2</a><br>这是一个很有意思的题，关键点是 <strong>原地</strong>修改数组，也就是不能引入新的数组，不然就很简单了。<br>这个题用快慢指针很有趣的一点是，用fast去探路，如果是不重复的，就让slow走一步，如果是重复的，就把fast的值给slow，这样可以保[0,slow]都是不重复的， 非常有意思。</p></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>            slow++;<br>            <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-comment">// 数组长度为索引 + 1</span><br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找其实就是双指针，之后做题多了会写一篇各种二分法的博，写的更详细一点，在这里就只需要知道是个双指针就行了</p></p><p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">题目</a><br>也是一个不难考虑的题，首先考虑长度是0的情况，但是体感说了大于2，就不考虑了</p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length-<span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            sum = numbers[left]+numbers[right];<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target) &#123;<br>                right--;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p><h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><br>            &lt;/div&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day1,2 | LC 704 Binary Search, LC27 Remove element, LC977 Squares of a Sorted Array, LC209 Minumum size subarray sum, LC59 Spiral Matrix II</title>
    <link href="/2023/02/16/CarlDay1&amp;2/"/>
    <url>/2023/02/16/CarlDay1&amp;2/</url>
    
    <content type="html"><![CDATA[<p>1,2 day of Carl’s  Algorithm training. Array related<br><span id="more"></span></p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>因为是留英选手，强迫自己尽量用英文写博客。虽然用中文更好表达，但是为了更好的和local交流、分享博客，也让自己对术语更熟悉一些，所以用英文写了</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="BG"><a href="#BG" class="headerlink" title="BG"></a>BG</h2><ul><li>Arrary: a collection of elements, each identified by at least one array index or key. It is stored at continuous memory addresses.  </li><li>two dimension array<ul><li>first index is row, second is col</li><li>a[0][1] : 1st row, 2nd col</li></ul></li></ul><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>In fact, Binary search is one tye of two-pointer, what we should od it judge the end of while loop, it is important to handle the statement of while, &lt;= or &lt;. Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//prevent int from overflow</span><br><br>          <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>              <span class="hljs-comment">// here is what we will do to teh target</span><br>              <span class="hljs-keyword">return</span> mid;<br>          &#125;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>              right = mid - <span class="hljs-number">1</span>;<br>          &#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>              left = mid + <span class="hljs-number">1</span>;<br><br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h2 id="Remove-element"><a href="#Remove-element" class="headerlink" title="Remove element"></a>Remove element</h2><p>Its a two pointers methods as will.  What we should focus on is <strong>in-place</strong> which means we can’t create a new array to store the  array. So, we can set a fast pointer and a slow pointer, if the fast one doesn’t meet the value, set slow to nums[fast], move slow, move fast.<br>Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != val)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="LC977-Squares-of-a-Sorted-Array"><a href="#LC977-Squares-of-a-Sorted-Array" class="headerlink" title="LC977 Squares of a Sorted Array"></a>LC977 Squares of a Sorted Array</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">Question</a><br>Noticed  that it is a non-decreasing order array, so the absolute of the left and right are larger than the middle, so we can use the Math.abs() to judge which is larger. Then utilize two-pointer one is <em>left</em> and one is <em>right</em>, the create a result array to store the result.<br>Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">if</span>(Math.abs(nums[left]) &lt; Math.abs(nums[right]))&#123;<br>            res[p] = nums[right] * nums[right];<br>            right--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res[p] = nums[left] * nums[left];<br>            left++;<br>        &#125;<br>        p--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="LC209-Minumum-size-subarray-sum"><a href="#LC209-Minumum-size-subarray-sum" class="headerlink" title="LC209 Minumum size subarray sum"></a>LC209 Minumum size subarray sum</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question</a><br>Description: Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.  </p><p>In this question, it is a type of <strong>Sliding-window</strong> method. The most important thing in Sliding window is identifying the start position.<br>The main procedure of sliding windown is </p><ol><li>set the start position</li><li>enlarge the window size </li><li>according to the condition, judge whether should we shrink the window.</li><li>maintain the window and keep process</li></ol><p>In this question, what we should not is we need a variable <em>res</em> to store the result, we can set it as <em>Math.MAX_VALUE</em>, and in this way, we can update the <em>res</em> by compare the value of <em>res</em> and window size<br>Here is the code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++)&#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>                result = Integer.min(result,right-left+<span class="hljs-number">1</span>);<br>                <br>                sum -=nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE? <span class="hljs-number">0</span>:result;<br>        &#125;<br></code></pre></td></tr></table></figure><p>For the retrun thing, we use the <code>result == Integer.MAX_VALUE? 0:result</code> to judge whether the sum of all values in nums is larger than target. if not, return 0</p><h2 id="LC59-Spiral-Matrix-II"><a href="#LC59-Spiral-Matrix-II" class="headerlink" title="LC59 Spiral Matrix II"></a>LC59 Spiral Matrix II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">Question</a><br>It is a design question, what we should do is simulating a clockwise cycle. It is not very difficult but the details are annoying. Here is the solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> [][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, down = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(num &lt;= n * n)&#123;<span class="hljs-comment">//end case is maximum value of loop</span><br>            <span class="hljs-keyword">if</span>(up &lt;= down)&#123;<span class="hljs-comment">// from left to right</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;i &lt;= right;i++)&#123;<br>                    res[up][i] = num++;<br>                &#125;<br>                up++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<span class="hljs-comment">//right size, from top to down</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up;i &lt;= down;i++)&#123;<br>                    res[i][right] = num++;<br>                &#125;<br>                right--;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(up &lt;= down)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--)&#123;<br>                    res[down][i] = num++;<br>                &#125;<br>                down--;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<span class="hljs-comment">// ri</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--)&#123;<br>                    res[i][left] = num++;<br>                &#125;<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>carl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dns</title>
    <link href="/2022/11/17/dns/"/>
    <url>/2022/11/17/dns/</url>
    
    <content type="html"><![CDATA[<p>Intro of DNS<br><span id="more"></span></p><p><h1 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DNS任务<br>人们使用时更喜欢使用hostname但是router更喜欢使用IP。DNS其实主要是为了将域名转换为IP地址，也可以把IP转换为域名<br> DNS是：  </p></p><p><ul></p><p><li>一个由分层的dns服务器实现的分布式数据库。</li></p><p><li>一个让主机能够查询分布式数据库的应用层协议<h2 id="DNS服务"><ahe href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2></li></p><p><li>域名解析</li></p><p><li>主机别名</li></p><p><li>邮件服务器别名</li></p><p><li>负载分配：可用于冗余的服务器之间进行负载分配。<h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2>当一个用户主机的浏览器（HTTP用户）请求URL时</li><br>&lt;/ul&gt;</p><p><ol></p><p><li>同一台用户主机上运行着DNS应用的客户端</li></p><p><li>浏览器从URL中抽出主机名，并把主机名传给DNS应用的客户端</li></p><p><li>客户端想DNS发送一个包含主机名的请求。<strong>所有的DNS请求和回答报文都是UDP数据报通过端口53发送</strong></li></p><p><li>DNS client会收到一个回答报文，包含对应的IP</li></p><p><li>一旦浏览器收到了IP，就能够向改IP地址80端口的http服务器发起一个TCP链接</li><br>&lt;/ol&gt;</p><p><h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p><strong>DNS是分布式数据库的范例</strong>  </p></p><p><h3 id="分布式、分层次的数据库"><a href="#分布式、分层次的数据库" class="headerlink" title="分布式、分层次的数据库"></a>分布式、分层次的数据库</h3><p>目的：解决扩展性问题<br><img src="/img/dns.png" srcset="/img/loading.gif" lazyload alt="层次结构"><br>类型：<br>根DNS服务器：提供TLD服务器的IP地址<br>顶级域（TLD）DNS服务器:例如:com,org,net,edu,gov和国家顶级域如uk,fr,ca。<br>权威DNS服务器</p></p><p><h3 id="local-DNS"><a href="#local-DNS" class="headerlink" title="local DNS"></a>local DNS</h3><p>每个ISP都有一台 local dns 。主机和某个ISP链接时，ISP提供一台主机的IP。该主机具有一台或多台local dns server的IP（通过DHCP）。<br>来个简单的例子<br><img src="/img/dns2.png" srcset="/img/loading.gif" lazyload alt="DNS交互"><br>主机为了获得gaia.cs.umass.edu的IP地址需要进行图里的8次调用！八次！！，如果umass为每个系在增设一个dns服务器的话，将会成为10次。<br>其中用到了的递归查询和迭代查询。<br>递归查询：cse.nyu.edu刀dns.nyu.edu的查询，因为查询是已自己的名义请求dns获得映射。<br>迭代查询： 剩下的三个查询都是迭代查询，因为是把结果返回给dns.nyu.edu<br><strong>因为这样处理的话，实在太麻烦了，会造成所以就提出了DNS缓存的概念</strong></p></p><p><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>原理：在一个请求链中，当某个NDS服务器接收到一个DNS回答，能将映射缓存在本地服务器中</p></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3rd lecture of 7CCEMMLE Machine Learning</title>
    <link href="/2022/10/08/MLLec2/"/>
    <url>/2022/10/08/MLLec2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><p>Chapter 3 of Machine Learning. This lecture discuss the loss function, population loss, optimal hard&#x2F; soft predictors, log-loss, cross-entropy loss and cross entropy, entropy and conditional entropy, KL divergence, and mutual information.</p><br><span id="more"></span></p><p><h1 id="Defining-Inference-推理"><a href="#Defining-Inference-推理" class="headerlink" title="Defining Inference(推理)"></a>Defining Inference(推理)</h1><ul></p><li>In inference problems we got two types variables: <ul><li>input</li><li>output, or target</li><li>A model is given by $p(x,t)$</li><p><h2 id="Two-kinds-of-inference"><a href="#Two-kinds-of-inference" class="headerlink" title="Two kinds of inference"></a>Two kinds of inference</h2><ul></p><li>detection problems:  takes value in a discrete and finite set</li><li>estimation problems: target is continuous</li><p><h3 id="predictor"><a href="#predictor" class="headerlink" title="predictor"></a>predictor</h3><p>two types:</p></p><ul><li>Hard predictor: specifies a single predicted value $\hat t$ of t for every value of x$&#x3D; x$<ul><li>$\hat t(x)$</li><li>x &#x3D; 0, $\hat{t}&#x3D;0$</li></ul></li><li>soft predictor：specifies a “score” for each possible value of $t$ given  $x&#x3D;x$<ul><li>$q(t|x)$</li><li>when x &#x3D; 0, output distribution (0.8,0.2) 分别为t&#x3D;0或者t&#x3D;1 –&gt; $q(1|0) &#x3D; 0.2$<br>Example:<br><img src="/./img/predictortype.png" srcset="/img/loading.gif" lazyload alt="eg"></li></ul></li></ul><h1 id="Optimal-soft-prediction-or-Bayesian-inference"><a href="#Optimal-soft-prediction-or-Bayesian-inference" class="headerlink" title="Optimal soft prediction, or Bayesian inference"></a>Optimal soft prediction, or Bayesian inference</h1><ul><li><p>A natural choice for the soft predictor $q(t|x)$ of t given $x &#x3D; x$ is the posterior distribution $p(t|x)$.</p></li><li><p>With this choice, the “score” q(t|x) assigned to each value of t is its posterior probability given x &#x3D; x.  </p><h2 id="calculation"><a href="#calculation" class="headerlink" title="calculation"></a>calculation</h2><p>  pmf:</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.45</td><td>0.05</td></tr><tr><td>1</td><td>0.1</td><td>0.4</td></tr></tbody></table></li><li><p>Given pmf $p(x,t)$</p></li><li><p>calculate the posterior $p(t|x)$</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.9</td><td>$\frac{0.05}{(0.45+0.05)&#x3D;0.1}$</td></tr><tr><td>1</td><td>0.2</td><td>0.8</td></tr></tbody></table></li><li><p>got the Bayesian soft predictor as<br>$$<br>(t|x&#x3D;0) ~ q(t|0) &#x3D; p(t|0) &#x3D; Bern(t|x)<br>$$<br>and<br>$$(t |x&#x3D;1)~q(t|1) &#x3D; p(t|1) &#x3D; Bern(t|0.8)<br>$$</p></li><li><p>conclusion<br>Ifx&#x3D;0,we can offer the hard prediction $\hat{t}(0) &#x3D; 0$ with associated probability of error of 0.1</p><h1 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h1></li><li><p>to measure the quality of hard prediction $\hat t$, we introduce the loss function $L(t,\hat{t})$</p></li><li><p>$L(t,\hat{t}) &#x3D; 0$ if $t &#x3D; \hat{t}$ </p></li><li><p>For estimation, </p><ul><li>we use $L_k$ loss for integer $k&gt;0$, def as<br>$$<br>L(t,\hat{t}) &#x3D; L_k(t,\hat{t}) &#x3D; |t-\hat{t}|^k<br>$$<ul><li>k &#x3D; 2 normally</li></ul></li></ul></li><li><p>for detection </p><ul><li>0-1 loss, indicator</li></ul></li></ul><p>$$<br>I(a) &#x3D; \begin{cases}<br>1&amp; \text{if a &#x3D; true }\<br>0&amp; \text{if a &#x3D; false}\<br>\end{cases}<br>$$</p><h1 id="Population-loss"><a href="#Population-loss" class="headerlink" title="Population loss"></a>Population loss</h1><ul><li>for given predictor $\hat{t}(·)$, we define population loss as<br>$$<br>L_p(\hat{t}(·)) :&#x3D; E_{(x,t)～p(x,t)}[L(t,\hat{t})]<br>$$</li><li>it is the average lose over the joint distribution of input and target  </li><li>对loss函数取个平均值</li><li>For detection-error loss</li></ul><p>(:&#x3D;的意思是，左边的东西被定义为右边)  </p><p>for a loss functiom, <strong>optimal hard predictor</strong> minimizes the <strong>population loss</strong>.<br>$$<br>\hat t^* (·) :&#x3D; arg min_{\hat t(·)}{L_p(\hat t(·))} &#x3D; E[l(t,\hat t(x))]<br>$$</p><h2 id="Population-detection-error-loss"><a href="#Population-detection-error-loss" class="headerlink" title="Population detection-error loss"></a>Population detection-error loss</h2><ul><li>def: the prob of detection error.<br>$$<br>Pr_{(x,t)<del>p(x,t)}[t\neq\hat t(x)]&#x3D;1-Pr_{(x,t)</del>p(x,t)}[t&#x3D;\hat t(x)]&#x3D;1-\sum_p(x,\hat t(x))<br>$$</li></ul><h1 id="Optimal-Hard-Predictor"><a href="#Optimal-Hard-Predictor" class="headerlink" title="Optimal Hard Predictor"></a>Optimal Hard Predictor</h1><ul><li><p>def: an optimal hard predictor minimizes the populationloss</p><p>$$<br>\hat{t^\star(·)} :&#x3D; arg\space min_{\hat{t}^(·)}{L_p(\hat t^*(·) )}&#x3D;E_{(x,t)\sim p(x,t)}[l(t,\hat t(x))]<br>$$</p></li></ul><p>means: the “argument” that <strong>minimizes</strong> the function in<br>the brackets, that is, the minimizer of this function.</p><ul><li>for any given loss function l, the optimal predictor can be directly computed from the <strong>posterior distribution</strong><br>$$<br>p(t|x)&#x3D;\frac{p(x,t)}{p(x)}<br>$$<br>也就是说能用optimal soft predictor来获得</li></ul><p>$$\hat{t^\star(·)}&#x3D;arg\space min_{\hat t \in{0,1}}E_{t\sim p(t|x)}[l(t,\hat t)]$$</p><h2 id="Optimal-Hard-Prediction-Under-Detection-Error-Loss"><a href="#Optimal-Hard-Prediction-Under-Detection-Error-Loss" class="headerlink" title="Optimal Hard Prediction Under Detection-Error Loss"></a>Optimal Hard Prediction Under Detection-Error Loss</h2><ul><li>the optimal predictor is the maximum of the posterior distribution, i.e.the posterior mode<br>$$<br>\hat{t^\star(x)} &#x3D; arg\space max_{t}p(t|x)<br>$$<br>it is maximum a posterior(MAP)<h2 id="Under-l-2-Loss"><a href="#Under-l-2-Loss" class="headerlink" title="Under $l_2$ Loss"></a>Under $l_2$ Loss</h2></li><li>the optimal hard predictor is the posterior mean, that is, the mean of the posterior distribution</li></ul><h1 id="Cross-Entropy-Loss"><a href="#Cross-Entropy-Loss" class="headerlink" title="Cross-Entropy Loss"></a>Cross-Entropy Loss</h1><p><strong>熵：用来衡量事物的不确定性</strong>，熵越大，信息量越大，是五月不确定，事物越复杂</p><ul><li>assign a loss to soft predictor –&gt; measure how good it is </li><li>To measure the loss of the soft predictor q(t|x) on a pair$(x,t)$<br>using<br> $$l&#x3D;-log q(t|x)$$</li></ul><p><img src="/./img/loglossplot.png" srcset="/img/loading.gif" lazyload alt="plot"></p><ul><li>large when predictor gives low probability to the correct output t given x, which measere the <strong>“superise”</strong></li><li>if t is discrete, the score is constrained in the itnerval[0,1]</li><li>can be negative when t is continuous</li><li>log-loss is used to compare different predictors<h2 id="Population-log-loss"><a href="#Population-log-loss" class="headerlink" title="Population log-loss"></a>Population log-loss</h2>an optimal soft predictor can then be obtained by minimizing the population log-loss<br>$$<br>min_{q(·|·)}{L_p(q(·|·))}&#x3D;E_{(x,t)\sim p(x,t)}[-log q(t|x)]<br>$$</li><li>it the cross entropy between $p(t)$ and $q(t)$</li><li>only for soft predictor and depends on the entire soft predictor q(t|x) obtained by considering all values of x and t<br>$$<br>L_p(q(·))&#x3D;H(p,q)<br>$$</li><li>这反映了 divergence between distribution p and q</li><li>if p &#x3D; q, minimizes the population log-loss</li></ul><h1 id="KL-divergence-kl散度，相对熵"><a href="#KL-divergence-kl散度，相对熵" class="headerlink" title="KL divergence (kl散度，相对熵)"></a>KL divergence (kl散度，相对熵)</h1><p><strong>一个用来衡量两个概率分布的相似性的一个度量指标</strong>，随机分布相同时，为0。<br>$$<br>KL(p||q) &#x3D; E_{t \sim p(t)}[log{\frac{p(t)}{q(t)}}]<br>$$<br><img src="/./img/LLR.png" srcset="/img/loading.gif" lazyload alt="LLR"></p><ul><li>The KL divergence is generally asymmetric<ul><li>$KL(p||q) \neq KL(q||p)$</li></ul></li><li>LLR 越大则分布越不同<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2></li><li>binomial distribution<br><img src="/./img/KLeg.png" srcset="/img/loading.gif" lazyload alt="KLeg"></li><li>normal distribution<br><img src="/./img/normeg.png" srcset="/img/loading.gif" lazyload alt="normeg"><h2 id="relationship-between-Cross-entropy-and-KL"><a href="#relationship-between-Cross-entropy-and-KL" class="headerlink" title="relationship between Cross entropy and KL"></a>relationship between Cross entropy and KL</h2>KL div can be expressed as<br>$$<br>H(p,q):&#x3D;E_{t\sim p(t)}[-log(t)]<br>$$<br>which can have the equality<br>$$<br>KL(p||q)&#x3D;H(p,q)-H(p,p)<br>$$<h1 id="Differential-Entropy"><a href="#Differential-Entropy" class="headerlink" title="Differential Entropy"></a>Differential Entropy</h1></li><li>For Gaussian rv $t\sim N(\mu,\sigma ^2)&#x3D;\frac{1}{2}log(2\pi e\sigma^2)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec4</title>
    <link href="/2022/10/05/TeleLec4/"/>
    <url>/2022/10/05/TeleLec4/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><h1 id="LAN-Local-Area-Networks-局域网"><a href="#LAN-Local-Area-Networks-局域网" class="headerlink" title="LAN(Local Area Networks 局域网)"></a>LAN(Local Area Networks 局域网)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>LAN 里的每个成员都会收到任意一个成员发出的广播包，so如果想要通讯，必须获取对方的MAC地址（通过 ARP协议）。</p></p><p><ul></p><p><li><p>Characteristic </p></p><p><ul></p><p><li>scope small </li></p><p><li>high data rate</li></p><p><li>shared broadcast medium</li></p><p><li>under single management</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Facts </p></p><p><ul></p><p><li>protocol : MAC, LLC</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="IEEE-802-layers"><a href="#IEEE-802-layers" class="headerlink" title="IEEE 802 layers"></a>IEEE 802 layers</h2><p><img src="/./img/802.png" srcset="/img/loading.gif" lazyload alt="对比"><br>LLC 和MAC 对应了 OSI的data link, 也就是说只有下面三个parts和medium属于802可以约束的范围</p></p><p><h3 id="Physical-layer"><a href="#Physical-layer" class="headerlink" title="Physical layer"></a>Physical layer</h3><ul></p><p><li>Encoding&#x2F;Decoding of signals.</li></p><p><li>Preamble generation&#x2F;removal (synchronization).</li></p><p><li>Bit transmission&#x2F;reception.</li></p><p><li>Spec. of medium, topology<ul></p><p><li>topology: bus, ring, star<br><img src="/./img/LANTop.png" srcset="/img/loading.gif" lazyload alt="topologies"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="MAC-Medium-Access-Control-sublayer"><a href="#MAC-Medium-Access-Control-sublayer" class="headerlink" title="MAC(Medium Access Control sublayer)"></a>MAC(Medium Access Control sublayer)</h3><ul></p><p><li>framing, addressing, error detection</li></p><p><li>access to shared medium</li><br>&lt;/ul&gt;</p><p><h3 id="Logical-Link-Control-sublayer"><a href="#Logical-Link-Control-sublayer" class="headerlink" title="Logical Link Control sublayer"></a>Logical Link Control sublayer</h3><ul></p><p><li>interface to higher layers</li></p><p><li>flow and error control</li></p><p><li><h4 id="for-802-2"><a href="#for-802-2" class="headerlink" title="for 802.2"></a>for 802.2</h4></li></p><p><li>Provides a compatibility interface, irrespective of the MAC layer used.</li></p><p><li>Provides flow and error control services</li><br>&lt;/ul&gt;</p><p><h2 id="Multiple-access-protocols"><a href="#Multiple-access-protocols" class="headerlink" title="Multiple-access protocols"></a>Multiple-access protocols</h2><p><img src="/./img/MACprotocols.png" srcset="/img/loading.gif" lazyload alt="MACprotocols">  </p></p><p><h2 id="Random-access"><a href="#Random-access" class="headerlink" title="Random access"></a>Random access</h2><p>在随机接入协议中，一个传输节点总是以信道的全部速率（即Rbps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止  </p></p><p><p><em>这一部分要会计算</em>  </p></p><p><h3 id="aloha"><a href="#aloha" class="headerlink" title="aloha"></a>aloha</h3><p>Aloha 有两种，一个是纯aloha一个是slotted aloha，也就是时隙aloha  </p></p><p><ul></p><p><li><p>Pure aloha</p></p><p><ul></p><p><li>任何一个站在framing之后可以立即发送，但是看你会出现collision, 在监听时，等待ACK的时间等于round-trip传播时间。<br>最大利用率只有 $\frac{1}{2e}&#x3D;18%$,此时G&#x3D;1&#x2F;2</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>slotted aloha</p></p><p><ul></p><p><li>slot &#x3D; L&#x2F;R,一个时隙(时间片)等于传输一帧的时间</li></p><p><li>如果有frame要发<strong>it must wait for slot boundary</strong>, trans at the starting</li></p><p><li>如果有碰撞，<strong>该节点在时间片结束之前检测到这次碰撞</strong>。该节点<strong>以概率</strong>在后续的每个时间片中重传它的帧，直到该帧被无碰撞地传输出去。</li></p><p><li>一个给定节点成功传输的概率为$p(1-p)^{n-1}$。N个节点成功的概率为$Np(1-p)^{n-1}$</li></p><p><li>Maximum utilization&#x3D;1&#x2F;e&#x3D;37%</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p><img src="/./img/slottedAloha.png" srcset="/img/loading.gif" lazyload alt="slottedAloha"></p></p><p><h4 id="LAN-performance-计算"><a href="#LAN-performance-计算" class="headerlink" title="LAN performance 计算"></a>LAN performance 计算</h4><h3 id="CSMA-listen-before-talking"><a href="#CSMA-listen-before-talking" class="headerlink" title="CSMA (listen before talking)"></a>CSMA (listen before talking)</h3><p>cs的意思就是发送一个载波监听是否idle</p></p><p><ul></p><p><li><p>Non-persistent:<br><img src="/./img/CSMA.png" srcset="/img/loading.gif" lazyload alt="non"><br> but the capacity is wasted</p></li></p><p><li><p>1-persistent</p></p><p><ul></p><p><li>when medium is busy, **continue to listen **until channel is sensed idle</li></p><p><li></li></ul></li></p><p><li><p>p-persistent</p></p><p><ul></p><p><li>if idle-&gt;transmit with probability p and delay <strong>one time unit</strong> with (1-p)</li></p><p><li>when medium is busy, <strong>continue to listen</strong> until channel is idle</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><table></p><p><thead></p><p><tr></p><p><th></th></p><p><th>non-persistent</th></p><p><th>1-persistent</th></p><p><th>p-persistent</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p><p><tbody><tr></p><p><td>idle</td></p><p><td>asap</td></p><p><td>asap</td></p><p><td>p asap,(1-p) wait for next slot</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>busy</td></p><p><td>stop listening, re-listen after a random time</td></p><p><td>keep listening</td></p><p><td>stop listening, re-listen after a random time</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;&lt;/table&gt;</p><p><h3 id="CSMA-x2F-CD-collision-detection"><a href="#CSMA-x2F-CD-collision-detection" class="headerlink" title="CSMA&#x2F;CD (collision detection)"></a>CSMA&#x2F;CD (collision detection)</h3><p>变发送边监听，半双工  </p></p><p><ul></p><p><li><p>process: </p></p><p><ul></p><p><li>1,2 和1-persistent一样</li></p><p><li>3.if collision detected<ul></p><p><li>Transmit a jam signal for one slot.</li></p><p><li>Wait for a random time and reattempt (up to 16 times).</li></p><p><li>Random time generated according to (exponential backoff algorithm):<ul></p><p><li>If a packet is collided n times, where n &lt; 16, then the node waits for $T &#x3D; x \times 512$ bit period. Where $K &#x3D; uniform[0, 2^m − 1]$ , and $m &#x3D; Min[10 , n]$ .</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><ol start="4"></p><p><li>Collision is detected by monitoring the voltage, high voltage</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Problems</p></p><p><ol></p><p><li>Collisions of frames leads to** unpredictable delays**.</li></p><p><li>Minimum packet size required (wasteful of BW in case of many short messages). </li></p><p><li>Poor performance under very heavy load.</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="IEEE-802-3-Frame-format"><a href="#IEEE-802-3-Frame-format" class="headerlink" title="IEEE 802.3 Frame format"></a>IEEE 802.3 Frame format</h3><p><img src="/./img/8023frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h2><p>Star, bus, ring</p></p><p><h3 id="Star-LANs"><a href="#Star-LANs" class="headerlink" title="Star LANs"></a>Star LANs</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><ul></p><p><li>Active central element referred to as hub.</li></p><p><li>Stations connects to the hub by <strong>two twisted pair wires</strong>.</li></p><p><li>Hub acts as a repeater, <strong>repeats signal from a station on outgoing links of all stations</strong>.</li></p><p><li>If two stations transmit at the same time -&gt; collision.</li></p><p><li>Physically a star, logically a bus connection</li></p><p><li>Multiple levels of hops can cascaded in a hierarchical configuration (can build very large networks).</li><br>&lt;/ul&gt;</p><p><p><img src="/./img/busvsstar.png" srcset="/img/loading.gif" lazyload alt="busvsstar"></p></p><p><h3 id="Ring-topology"><a href="#Ring-topology" class="headerlink" title="Ring topology"></a>Ring topology</h3><ul></p><p><li>Network consist of set of repeaters.</li></p><p><li>Repeaters are connected by point to point links.</li></p><p><li>Unidirectional link.</li></p><p><li>Data is transferred from one repeater to next.</li></p><p><li>Repeaters perform <strong>data insertion, reception, and removal.</strong></li></p><p><li>if not data removal <ul></p><p><li>by sender:<ul></p><p><li>used as an ack</li></p><p><li>enable multicasting</li></p><p><li>more fair transmission scenario<br><img src="/./img/star.png" srcset="/img/loading.gif" lazyload alt="star"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Token-ring"><a href="#Token-ring" class="headerlink" title="Token ring"></a>Token ring</h3><p>很有趣的一个拓扑  </p></p><p><ul></p><p><li><p>会有一个token circulate around ring</p></li></p><p><li><p>all station idle-&gt;token is free</p></li></p><p><li><p>station只有检测到free token的时候才能传输，其他station必须等</p></li></p><p><li><p>The station then appends and transmits the remainder of the field to make a data frame.</p></li></p><p><li><p>station will insert a <strong>new free token</strong> after transmitting</p></li></p><p><li><p>什么时候release token</p></p><p><ul></p><p><li>You have to finish your transmission and the leading edge has to return</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p>总的来说，token像一把钥匙，谁要发送msg就需要占用token，发送的信息会发往所有的station但是只会被 dest station <strong>复制</strong>，然后传回src station之后将其删除，然后重新生成一个新的token</p></p><p><h4 id="frame-format"><a href="#frame-format" class="headerlink" title="frame format"></a>frame format</h4><p><img src="/./img/8024frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="LAN-performance"><a href="#LAN-performance" class="headerlink" title="LAN performance"></a>LAN performance</h2><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><ul></p><p><li>The probability that a station attempts to transmit in a slot is $P$</li></p><p><li>$A$ is the probability that some station can send a transmit in a slot successfully, and is given by:<br> $$<br>A &#x3D; NP(1-P)^{N-1}<br>$$</li><br>&lt;/ul&gt;</p><p><h3 id="Token-rings"><a href="#Token-rings" class="headerlink" title="Token rings"></a>Token rings</h3><ol></p><p><li><p>when$t_{tr} \geq t_{prop}$</p></p><p><p>  $S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{1+\frac{a}{N}}$<br>where $a &#x3D; \frac{t_{prop}}{t_{tr}}$  </p><br>&lt;/li&gt;</p><p><li><p>when $t_{tr} &lt;  t_{prop}$<br>$S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{a+\frac{a}{N}}$</p></li><br>&lt;/ol&gt;</p><p><h3 id="LAN-address-MAC-address"><a href="#LAN-address-MAC-address" class="headerlink" title="LAN address(MAC address)"></a>LAN address(MAC address)</h3><ul></p><p><li>a bytes long, unique address, </li></p><p><li>won’t change when the adapter moves</li></p><p><li>Mapped to IP address using ARP</li><br>&lt;/ul&gt;</p><p><h3 id="repeaters-bridges-routers"><a href="#repeaters-bridges-routers" class="headerlink" title="repeaters,bridges, routers"></a>repeaters,bridges, routers</h3><ul></p><p><li>repeater<ul></p><p><li>physical layer</li></p><p><li>extend physical length</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>bridge<ul></p><p><li>connects similar LANs</li></p><p><li>identical physical and link layer protocols</li></p><p><li>why<ul></p><p><li>reliability: several self-contained units</li></p><p><li>performance </li></p><p><li>security: isolate info on separate LANs</li></p><p><li>geography: connect LANs at diff locations</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>router<ul></p><p><li>interconnect various LANs and WANs</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Address-learning"><a href="#Address-learning" class="headerlink" title="Address learning"></a>Address learning</h3><p>会就行</p></p><p><h3 id="wireless-LANs"><a href="#wireless-LANs" class="headerlink" title="wireless LANs"></a>wireless LANs</h3><br>            &lt;/div&gt;</p>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec1&amp;2</title>
    <link href="/2022/09/28/TeleLec1/"/>
    <url>/2022/09/28/TeleLec1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本来以为这个课是小通原，还寻思又要被折磨了，结果发现是小计网，还是经典的不讲应用层的计网。  </p></p><p><h2 id="data-communications-vs-Network"><a href="#data-communications-vs-Network" class="headerlink" title="data communications vs Network"></a>data communications vs Network</h2><ul></p><p><li>communications: between 2 nodes. Only care the turnel</li></p><p><li>network: many nodes and links. No need link all nodes. take routing, addressing,congestion control into consideration.</li><br>&lt;/ul&gt;</p><p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><ul></p><p><li>def: millions of connected computing devices<ul></p><p><li>host: end systems</li></p><p><li>links:fiber,copper,ratio</li></p><p><li>packet switches: forward packets. <strong>routers and switches</strong></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="type-of-networks"><a href="#type-of-networks" class="headerlink" title="type of networks"></a>type of networks</h2><h3 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast:"></a>broadcast:</h3><ul></p><p><li>eg. bus mode–&gt; one can c others information</li><br>&lt;/ul&gt;</p><p><h3 id="swtiched-Networks"><a href="#swtiched-Networks" class="headerlink" title="swtiched Networks"></a>swtiched Networks</h3><h4 id="circuit-switched-Networks"><a href="#circuit-switched-Networks" class="headerlink" title="circuit-switched Networks"></a>circuit-switched Networks</h4><ul></p><p><li>a blocked network.</li></p><p><li>eg. old wired telephone. *end-end resources reserved.</li></p><p><li>link bandwidth, switch capacity.</li></p><p><li>dedicated resources</li><br>&lt;/ul&gt;</p><p><h3 id="packet-switched-network-non-blocking-network"><a href="#packet-switched-network-non-blocking-network" class="headerlink" title="packet switched network (non blocking network)"></a>packet switched network (non blocking network)</h3><ul></p><p><li>Each end-end data stream divided into <em>packets</em></li></p><p><li>no block but will delay till overflow. packet wait at router for output link</li><br>&lt;/ul&gt;</p><p><h4 id="virtual-circuit-vs-datagram-networks"><a href="#virtual-circuit-vs-datagram-networks" class="headerlink" title="virtual circuit vs datagram networks"></a>virtual circuit vs datagram networks</h4><ul></p><p><li><p>same goal: move packets tamgoung routers from src to dest</p></li></p><p><li><p>datagram: </p></p><ul><li>destination address determines next hop.</li><li>坐车时告诉司机目的地但是不一定nevigate路线，asking directions 所以 routes may change during session (取决于router的算法)</li><li></li></ul></li><li><p>virtual circuit</p><ul><li>has the map. tag determines next hop</li><li>fixed path determined at <strong>setup time</strong></li></ul></li></ul><h2 id="Loss-and-delay"><a href="#Loss-and-delay" class="headerlink" title="Loss and delay"></a>Loss and delay</h2><ul><li>loss:packet arrival rate to link (temporarily) exceeds output link capacity</li></ul><h3 id="type-of-delay"><a href="#type-of-delay" class="headerlink" title="type of delay"></a>type of delay</h3><ul><li>processing delay: negletive</li><li>queuing delay：$La&#x2F;R$, R-&gt;link bandwidth, a-.average packet arrival rate</li><li>transmission delay: 收费站排队进站.$t &#x3D; \frac{L}{R}$, R&#x3D;link bandwidth(bps), L &#x3D; packets(bits)</li><li>propagation delay: 开车时间, $delay &#x3D; \frac{d}{s}$</li></ul><h2 id="Portocol"><a href="#Portocol" class="headerlink" title="Portocol"></a>Portocol</h2><ul><li>def:set of rules governing the exchange of data between two entities in a system</li><li>Entities: users app, email facilities</li><li>Systems: computers, terminals, remote sensors</li><li>Protocol architectures: communication task broken up into modules<h3 id="Layerd-Network-Architecture"><a href="#Layerd-Network-Architecture" class="headerlink" title="Layerd Network Architecture"></a>Layerd Network Architecture</h3></li><li>define the commmunications abstractions defined by <strong>standardization bodies</strong></li><li>Layer N uses only service of Layer N-1, and only provides services to N+1</li></ul><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><ul><li>Control information is added to user data at each layer, add control inftomation(header) to data at each layer—&gt;封装</li><li>includ: destination SAP</li><li>Sequence number </li><li>Error detection code</li></ul><h3 id="TCP-x2F-IP-model-stack"><a href="#TCP-x2F-IP-model-stack" class="headerlink" title="TCP&#x2F;IP  model stack"></a>TCP&#x2F;IP  model stack</h3><p><img src="/img/teleTCPIPmodel.png" srcset="/img/loading.gif" lazyload alt="TCPIPmodel"></p><h2 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h2><p><img src="/img/teleEncap.png" srcset="/img/loading.gif" lazyload alt="encapsulation"></p><h1 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h1><h2 id="terminology"><a href="#terminology" class="headerlink" title="terminology"></a>terminology</h2><ul><li>Data transmission occurs between <strong>transmitter</strong> and <strong>receiver</strong> over some <strong>transmission medium</strong></li><li>Simplex: <strong>one direction</strong>,eg: TV</li><li>Half duplex: both transmit but not at a time. use full bandwidth</li><li>Full duplex: both dir, simultaneously</li></ul><h2 id="Analog-and-Digital-Data-Transmission"><a href="#Analog-and-Digital-Data-Transmission" class="headerlink" title="Analog and Digital Data Transmission"></a>Analog and Digital Data Transmission</h2><ul><li><p>advantages: cheaper and less susceptible to noise interference</p></li><li><p>Dis: suffer more from <strong>attenuation</strong>( the loss of signal strength in networking cables or connections)</p></li><li><p>signal has small band width. data is compressd to signal for trans<br><strong>analog signal</strong> is sampled to <strong>digital signal</strong></p></li></ul><h2 id="Transmission-Media"><a href="#Transmission-Media" class="headerlink" title="Transmission Media"></a>Transmission Media</h2><ul><li>guided - wire<ul><li>medium is more important</li></ul></li><li>unguided- wireless<ul><li>bandwidth produced by the antenna(天线) is more important</li></ul></li></ul><h3 id="Guided-transmission-media"><a href="#Guided-transmission-media" class="headerlink" title="Guided transmission media"></a>Guided transmission media</h3><h4 id="twisted-pair"><a href="#twisted-pair" class="headerlink" title="twisted pair"></a>twisted pair</h4><ul><li>application: Most common <ul><li>telephone, LANs,PBX</li></ul></li><li>pros:<ul><li>cheap</li><li>easy</li></ul></li><li>cons<ul><li>Low data rate</li><li>short range</li></ul></li><li>Unshield and shiled twisted pair<ul><li>STP: reduce interference</li></ul></li></ul><h4 id="coaxial-cable"><a href="#coaxial-cable" class="headerlink" title="coaxial cable"></a>coaxial cable</h4><ul><li>application:TV distribution, LANs. Long distance telephone transmission</li><li>pros: good noise immunity</li><li>cons:harder to install and repair, moderate cost</li></ul><h4 id="optical-fibers"><a href="#optical-fibers" class="headerlink" title="optical fibers"></a>optical fibers</h4><ul><li>application:Long-haul trunks, metropolitan trunks,LANs</li><li>pros:greater capacity, small size and weight, lower attenuation, reter repeater spacing </li><li>cons</li></ul><h3 id="wireless-communication"><a href="#wireless-communication" class="headerlink" title="wireless communication"></a>wireless communication</h3><ul><li>unguided, via antenna</li><li>Directional: focused beam and careful alignment required</li><li>Omnidirctional: spread in all directions, can be received by many antenna</li></ul><h2 id="Encoding-and-decoding"><a href="#Encoding-and-decoding" class="headerlink" title="Encoding and decoding"></a>Encoding and decoding</h2><h3 id="NRZ-amp-NRZI"><a href="#NRZ-amp-NRZI" class="headerlink" title="NRZ&amp;NRZI"></a>NRZ&amp;NRZI</h3><p>RZ: 一个周期内，用二进制传输数据位，在数据位脉冲结束后，需要维持一段时间的低电平。</p><ul><li>Non Return to Zero <ul><li>0 &#x3D;high level, 1&#x3D; low level   </li><li>一个周期可以全部用来传输数据</li></ul></li><li>Non Return to Zero, Invert on one<ul><li>如果有变化就是1，不变就保持</li></ul></li><li>Evaluation:<ul><li>+Efficiency use of bandwidth</li><li>+easy to implement</li><li>-DC component</li><li>-synchronization<ul><li>hard to determine begin and end of bits</li></ul></li></ul></li></ul><h3 id="Multilevel-binary"><a href="#Multilevel-binary" class="headerlink" title="Multilevel binary"></a>Multilevel binary</h3><p>三种电平：0,正,负</p><ul><li>Bipolar AMI(Alternate Inversion)   mark &#x3D;1<br>0 - no signal, 1 &#x3D; positive or neg but must alternate<br>anti DC </li><li>pseudoternary: 1 &#x3D; no signal, 0 &#x3D; positive neg (must alternate). 1编码成0电平，0编码成正负交替电平</li></ul><p><img src="/img/Bipolar-AMI.png" srcset="/img/loading.gif" lazyload alt="Bipolar-AMI"></p><ul><li>evaluation<ul><li>+no DC component  </li><li>+good synchronization</li><li>+error detection</li><li>-not efficient as NRZ</li></ul></li></ul><h3 id="Biphase"><a href="#Biphase" class="headerlink" title="Biphase"></a>Biphase</h3><h4 id="Manchester"><a href="#Manchester" class="headerlink" title="Manchester"></a>Manchester</h4><ul><li>transition in middle of every interval</li><li>0 &#x3D; transition from high to low in middle of interval</li><li>1&#x3D;transition from low to high in middle of interval 在</li></ul><h4 id="diff-Manchester"><a href="#diff-Manchester" class="headerlink" title="diff Manchester"></a>diff Manchester</h4><ul><li><p>0:在开头变</p></li><li><p>1:先保持在中间变</p></li><li><p>evaluation</p><ul><li>+Synchronization on mid bit transition</li><li>+no dc</li><li>+error detection</li><li>-need more bandwidth</li></ul></li></ul><p><img src="/img/manchester.png" srcset="/img/loading.gif" lazyload alt="Manchester"></p><h3 id="Digital-Data-Analog-Signals"><a href="#Digital-Data-Analog-Signals" class="headerlink" title="Digital Data Analog Signals"></a>Digital Data Analog Signals</h3><h4 id="Modulate"><a href="#Modulate" class="headerlink" title="Modulate"></a>Modulate</h4><ul><li>Amplitude Shift Keying (ASK)  </li><li>Frequency Shift Keying (FSK) </li><li>Phase shift Keying (PSK)</li></ul><h4 id="Digitization"><a href="#Digitization" class="headerlink" title="Digitization"></a>Digitization</h4><p>Def: analog data to digital data  </p><ul><li><p>Digital data can then be transmitted using code.</p></li><li><p>Digital data can then be converted to analog signal</p></li><li><p>Digital data can then be converted to <strong>analog signal</strong></p></li><li><p>Analog to digital conversion done using a code</p></li><li><p>Pulse code modulation</p></li><li><p>Delta modulation</p></li><li><p>why</p><ul><li>Higer f –&gt; more efficient</li><li>Permits frequency division multiplexing</li></ul></li><li><p>Type of modulation</p><ul><li>amplitude</li><li>phase</li><li>frequency</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1st lecture of 7CCEMMLE Machine Learning</title>
    <link href="/2022/09/17/MLLec1/"/>
    <url>/2022/09/17/MLLec1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p><h1 id="First-Lec-of-Machine-Learning"><a href="#First-Lec-of-Machine-Learning" class="headerlink" title="First Lec of Machine Learning"></a>First Lec of Machine Learning</h1><h2 id="intro-of-Module"><a href="#intro-of-Module" class="headerlink" title="intro of Module"></a>intro of Module</h2><ul></p><p><li>basic of Linearg algebra, calculus, and probability</li></p><p><li>MATLAB</li><br>&lt;/ul&gt;</p><p><h2 id="what-is-ML"><a href="#what-is-ML" class="headerlink" title="what is ML"></a>what is ML</h2><ol></p><p><li>Induction bias selection: selection of a model<br>train process: optimise </li></p><p><li>Learning: based on data, collection typical data to opitimize algorism</li></p><p><li>Inference, control: use the trained machine(a black-box) then generalize<br><img src="/img/mllec1.png" srcset="/img/loading.gif" lazyload alt="ML approach"><br>Integrating domain knowledge into a machine learning approach<h2 id="ML-method"><a href="#ML-method" class="headerlink" title="ML method"></a>ML method</h2></li><br>&lt;/ol&gt;</p><p><ul></p><p><li>supervised learning </li></p><p><li>unsupervised learning </li></p><p><li>reinforcement(强化学习) learning</li><br>&lt;/ul&gt;</p><p><h3 id="supervised-vs-unsupervised-learing"><a href="#supervised-vs-unsupervised-learing" class="headerlink" title="supervised vs unsupervised learing"></a>supervised vs unsupervised learing</h3><p><img src="/img/mllec2.png" srcset="/img/loading.gif" lazyload alt="vs"><br>supervised: classification. Give data to train a model that generalized can give result about data not in dataset<br>unsuervised : cluster </p></p><p><h2 id="When-to-use"><a href="#When-to-use" class="headerlink" title="When to use"></a>When to use</h2><h3 id="Potential-advantages"><a href="#Potential-advantages" class="headerlink" title="Potential advantages"></a>Potential advantages</h3><ul></p><p><li>lower cost and faster development </li></p><p><li>reduced implementation complexity</li><br>&lt;/ul&gt;</p><p><h3 id="potential-disadvantages"><a href="#potential-disadvantages" class="headerlink" title="potential disadvantages"></a>potential disadvantages</h3><ul></p><p><li>suboptimal performance and limited perfomance guarantees</li></p><p><li>limited interpretability</li><br>&lt;/ul&gt;</p><p><h1 id="Basic-Background"><a href="#Basic-Background" class="headerlink" title="Basic Background"></a>Basic Background</h1><ul></p><p><li>refresher on probablity and linear algebra<h2 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h2></li>ML</p><p><li>def: a random numberical quantitiesthat takes values in a set </li></p><p><li>Bernoulli variable（二分步）: $x～Bern(q)$，set: $X &#x3D; {0,1}$</li><br>&lt;/ul&gt;</p><p>$p(1) &#x3D; Bern(1|q) &#x3D; Pr[x&#x3D;1] &#x3D; q$   </p><ul><li>Categorical variable:<ul><li>$x~Cat(q)$ take values in $X &#x3D; {0,1,2,3,\ddots,}$</li><li>$p(k) &#x3D; Cat(k|q) &#x3D; Pr[x&#x3D;k] &#x3D; q_k$</li></ul></li></ul><h3 id="decrete-RV"><a href="#decrete-RV" class="headerlink" title="decrete RV"></a>decrete RV</h3><p>categorical rvs are represented using one-hot verctor<br>$x^OH$ os dimension Cx1 with all zeros except for a one in the (k + 1)th position when x &#x3D; k<br>For C&#x3D;4, x &#x3D; 0:<br>$$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;1\ &amp;0\&amp;0\&amp;0\end{bmatrix}$$<br>  if x &#x3D;2<br>  $$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;0\ &amp;0\&amp;1\&amp;0\end{bmatrix}$$</p><h3 id="continuous-rv"><a href="#continuous-rv" class="headerlink" title="continuous rv"></a>continuous rv</h3><p>described by pdf. p(x): x~p(x)<br>$p(x)\geq0$and $\int ^{\infin}_{-\infty} p(x)dx &#x3D;1$  </p><p><strong>Gaussian is the most important</strong></p><h4 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h4><p>$$x \sim N(\mu,\sigma^2)&#x3D;\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(x-\mu)^2}{2\sigma^2}$$<br>$\mu$ is the Expection and $\sigma^2$ is Variance</p><h2 id="Expectation-and-variance"><a href="#Expectation-and-variance" class="headerlink" title="Expectation and variance"></a>Expectation and variance</h2><h3 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h3><ul><li>$$E_{x\sim p(x)} [x] &#x3D; \sum_{x \in X} {p(x) \cdot x}$$</li><li>the expectation of function of a dicrete rv is<br>$$E_{x\sim p(x)} [f(x)] &#x3D; \sum_{x \in X} {p(x) \cdot f(x)}$$</li><li>For Categorical<br>$$E_{x\sim Cat(q)} [f(x)] &#x3D; \sum_{x \in X} {q(x) \cdot f(x)}$$</li><li>For continuous rv:</li></ul><p>$$E_{x\sim p(x)} [f(x)] &#x3D; \int_{-\infin}^{\infty} {p(x) \cdot f(x)dx}$$</p><ul><li>For Gaussian</li></ul><p>$$E_{x \sim N(\mu,\sigma^2)} [x] &#x3D; \mu$$<br>$$E_{x \sim N(\mu,\sigma^2)} [x^2] &#x3D; \mu^2+\sigma^2$$</p><ul><li>It is linear</li></ul><h3 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h3><p>For Categorical rv $x\sim Cat(q)$:$$<br>$$Var(x) &#x3D; \sum^{C-1}<em>{x&#x3D;0} q_x(x-(\sum^{C-1}</em>{x&#x3D;0}q_x x))^2$$  </p><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><ul><li><p>vector is an ordered collection of scalars.</p></li><li><p>tanspose: $x^T$<br>,from row to column or from column2row.</p></li><li><p>inner pordx&#96;uct: a measure of <strong>similarity</strong></p></li><li><p>Inner product $x^Ty &#x3D; \sum^L_{i&#x3D;1}x_iy_i$</p></li><li><p><strong>Normalize</strong><br>$$||x||&#x3D;\sqrt{x^Tx}&#x3D;\sqrt{\sum_{i&#x3D;1}^L x_i^2}$$</p></li><li><p>unitary norm of vector $\tilde s&#x3D;\cfrac{x}{||x||}$, $||\tilde{x}||^2 &#x3D; 1$</p></li><li><p>orthogonal: $x^Ty &#x3D; 0$</p></li><li><p>Diagonal matrix: L x L, only diag is 1  </p></li><li><p>$Diag(a)&#x3D;\begin{bmatrix}<br>&amp;a_1 &amp;0 &amp;\cdots &amp;0\<br>&amp;0 &amp;a_2 &amp;\cdots &amp;0 \<br>&amp;\vdots &amp; &amp;\ddots&amp;\vdots\<br>&amp;0 &amp;0 &amp;\cdots &amp;a_L\end{bmatrix}$</p></li><li><p>Outer producet: 2 L x 1 vectors make LxL matrix</p></li><li><p>Symmetric matrix:对称矩阵。$A^T &#x3D; A$</p></li><li><p>Outer product. </p></li><li><p>vector-matrix multiplication: $x^TA &#x3D; (A^Tx)^T$</p><ul><li>positive simi-define:</li></ul></li><li><p>Eigenvector &amp; Eigenvalue</p><ul><li>in fact it the eigenvector is a base vector and the eigenvalue is a scaling factor so that we can simplify the calculation of a linear transformation on one vector.</li><li>def: if A is an $n \times n$ matrix,if there is an non-zero vector $x$ can let $Ax &#x3D; \lambda x$, then the $\lambda$ is the eigenvalue and the vector $x$ is the eigenvector belonging to $\lambda$.</li></ul></li><li><p>calculation of eigenvector</p></li></ul><p>$$(A-\lambda I)x&#x3D;0$$<br>which means<br>$$det(A-\lambda I)&#x3D;0$$  </p>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2022/05/18/markdown/"/>
    <url>/2022/05/18/markdown/</url>
    
    <content type="html"><![CDATA[<!--more--><p><h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs clean"># 一级 <br>## 二级<br>### 三级<br>#### 四级<br>...<br></code></pre></td></tr></table></figure></p><p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span>效果如下面的线<br></code></pre></td></tr></table></figure></p><p><hr></p><p><h2 id="常用标识"><a href="#常用标识" class="headerlink" title="常用标识"></a>常用标识</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>斜体</em>  <code>*斜体*</code>  <br></p></p><p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p><strong>粗体</strong> <code> **粗体**</code> <br></p></p><p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><code>行内代码块</code> `行内代码块` <br></p></p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">代码块<br><br></code></pre></td></tr></table></figure></p><p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[]里写文字，()里写地址 <br></p></p><p><p>自动链接<br>&lt;&gt;里面写邮箱或者地址</p></p><p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无需列表"><a href="#无需列表" class="headerlink" title="无需列表"></a>无需列表</h3><p>直接使用 -,*</p></p><p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>列表1<br><span class="hljs-bullet">- </span>列表2<br></code></pre></td></tr></table></figure></p><p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol></p><p><li><ol start="2"></p><p><li><ol start="3"></p><p><li><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2>![图片Alt](图片地址 “图片Title”)<br>对fluid主体来说，要把图片放在&#x2F;source&#x2F;img中  <h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ol&gt;</p><p><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><p>因为开学了 发现markdown记笔记还是挺好用的，但好多数学符号还是有点难打，于是找了相关资料。 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e74eb43960a1">这个还是很好的</a>  </p></p><p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>行内公式用<code>$公式内容$</code>  $xyz$<br>单独行公式<code>$$公示内容$$</code> $$xyz$$  </p></p><p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><ul></p><p><li>上标: ^ :$x^y$</li></p><p><li>下标：_: $x_y$ </li></p><p><li>组合符号：{},eg <code>$&#123;16&#125;_&#123;8&#125;O&#123;2+&#125;_&#123;2&#125;$</code> ${16}<em>{8}0{2+}</em>{2}$</li></p><p><li>中括号，符号：[]，如：<code>$[x+y]$</code> &#x3D; $[x+y]$</li></p><p><li>大括号，符号：{ }，如：<code>$&#123;x+y&#125;$</code>–  ${x+y}$</li></p><p><li>自适应括号，符号：\left \right，如：$\left(x\right)$，$\left(x{yz}\right)$</li></p><p><li>组合公式，符号：{上位公式 \choose 下位公式}，如：${n+1 \choose k}&#x3D;{n \choose k}+{n \choose k-1}$</li></p><p><li>组合公式，符号：{上位公式 \atop 下位公式}，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots&#x3D;n}A_{k_0}A_{k_1}\cdots$</li><br>&lt;/ul&gt;</p><p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul></p><p><li>加\减还是+-</li></p><p><li>加减运算:<code>\pm</code> :$x\pm y$</li></p><p><li>乘法：<code>\times</code>: $x\times y&#x3D;z$</li></p><p><li>点乘：<code>\cdot\</code>:$x \cdot y &#x3D; z$</li></p><p><li>星乘：<code>\ast</code>: $x \ast y$</li></p><p><li>除法：<code>\div</code>: $x \div y$</li></p><p><li>斜法：<code>/</code>: $x&#x2F;y$</li></p><p><li>分式表示：<code>&#123;分子&#125; \over &#123;分母&#125; </code>: ${x} \over {y}$</li></p><p><li>绝对值：||<h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul></p><p><li>平均数:<code>\overline&#123;&#125;</code> $\overline{xyz}$</li></p><p><li>开方:<code>\sqrt</code> $\sqrt{x}$<br> <code>\sqrt&#123;&#125;&#123;&#125;</code> $\sqrt[3]{xyz}$</li></p><p><li>对数运算:<code>\log_x(y)</code> $\log_2(x)$</li></p><p><li>极限运算:<code>\lim</code>,  </li></p><p><li><code>$\lim^&#123;x\to\infin&#125;_&#123;y\to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code> $\lim^{x\to\infin}_{y\to 0}{\frac{x}{y}}$</li></p><p><li>求和运算:<code>\sum</code><br><code>$\sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code><br>$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li></p><p><li>积分运算:<code>\int</code> $\int^{\infty}_{0}{xdx}$</li></p><p><li>微分运算:<code>\partial</code> $\frac{\partial x}{\partial y}$</li></p><p><li>矩阵运算:<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code><br><code>$\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]$</code></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p>$\left[\begin{matrix}<br>    1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots\ &amp;vdots \13 &amp;14 &amp;\cdots &amp;16<br>\end{matrix}\right]$</p></p><p><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><ul></p><p><li>属于运算，符号：<code>\in</code>，如：$x \in y$<br>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li></p><p><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li></p><p><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li></p><p><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$并集运算，符号：\cup，如：$x \cup y$</li></p><p><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li></p><p><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li></p><p><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li></p><p><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><br>&lt;/ul&gt;</p><p>$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
