<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Personal blog based on Github+Hexo</title>
    <link href="/2023/02/18/blog/"/>
    <url>/2023/02/18/blog/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Blog is really helpful for every engineer, even though sometimes I prefer record by pen and paper.  In this blog I will introduce you how to build your own blog by Hexo and Github. The theme I chose is Fluid.</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Blog,hexo, github, fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec4</title>
    <link href="/2023/02/18/TeleLec4/"/>
    <url>/2023/02/18/TeleLec4/</url>
    
    <content type="html"><![CDATA[<p><h1 id="LAN-Local-Area-Networks-局域网"><a href="#LAN-Local-Area-Networks-局域网" class="headerlink" title="LAN(Local Area Networks 局域网)"></a>LAN(Local Area Networks 局域网)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>LAN 里的每个成员都会收到任意一个成员发出的广播包，so如果想要通讯，必须获取对方的MAC地址（通过 ARP协议）。</p></p><p><ul></p><p><li><p>Characteristic </p></p><p><ul></p><p><li>scope small </li></p><p><li>high data rate</li></p><p><li>shared broadcast medium</li></p><p><li>under single management</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Facts </p></p><p><ul></p><p><li>protocol : MAC, LLC</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="IEEE-802-layers"><a href="#IEEE-802-layers" class="headerlink" title="IEEE 802 layers"></a>IEEE 802 layers</h2><p><img src="/./img/802.png" srcset="/img/loading.gif" lazyload alt="对比"><br>LLC 和MAC 对应了 OSI的data link, 也就是说只有下面三个parts和medium属于802可以约束的范围</p></p><p><h3 id="Physical-layer"><a href="#Physical-layer" class="headerlink" title="Physical layer"></a>Physical layer</h3><ul></p><p><li>Encoding&#x2F;Decoding of signals.</li></p><p><li>Preamble generation&#x2F;removal (synchronization).</li></p><p><li>Bit transmission&#x2F;reception.</li></p><p><li>Spec. of medium, topology<ul></p><p><li>topology: bus, ring, star<br><img src="/./img/LANTop.png" srcset="/img/loading.gif" lazyload alt="topologies"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="MAC-Medium-Access-Control-sublayer"><a href="#MAC-Medium-Access-Control-sublayer" class="headerlink" title="MAC(Medium Access Control sublayer)"></a>MAC(Medium Access Control sublayer)</h3><ul></p><p><li>framing, addressing, error detection</li></p><p><li>access to shared medium</li><br>&lt;/ul&gt;</p><p><h3 id="Logical-Link-Control-sublayer"><a href="#Logical-Link-Control-sublayer" class="headerlink" title="Logical Link Control sublayer"></a>Logical Link Control sublayer</h3><ul></p><p><li>interface to higher layers</li></p><p><li>flow and error control</li></p><p><li><h4 id="for-802-2"><a href="#for-802-2" class="headerlink" title="for 802.2"></a>for 802.2</h4></li></p><p><li>Provides a compatibility interface, irrespective of the MAC layer used.</li></p><p><li>Provides flow and error control services</li><br>&lt;/ul&gt;</p><p><h2 id="Multiple-access-protocols"><a href="#Multiple-access-protocols" class="headerlink" title="Multiple-access protocols"></a>Multiple-access protocols</h2><p><img src="/./img/MACprotocols.png" srcset="/img/loading.gif" lazyload alt="MACprotocols">  </p></p><p><h2 id="Random-access"><a href="#Random-access" class="headerlink" title="Random access"></a>Random access</h2><p>在随机接入协议中，一个传输节点总是以信道的全部速率（即Rbps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止  </p></p><p><p><em>这一部分要会计算</em>  </p></p><p><h3 id="aloha"><a href="#aloha" class="headerlink" title="aloha"></a>aloha</h3><p>Aloha 有两种，一个是纯aloha一个是slotted aloha，也就是时隙aloha  </p></p><p><ul></p><p><li><p>Pure aloha</p></p><p><ul></p><p><li>任何一个站在framing之后可以立即发送，但是看你会出现collision, 在监听时，等待ACK的时间等于round-trip传播时间。<br>最大利用率只有 $\frac{1}{2e}&#x3D;18%$,此时G&#x3D;1&#x2F;2</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>slotted aloha</p></p><p><ul></p><p><li>slot &#x3D; L&#x2F;R,一个时隙(时间片)等于传输一帧的时间</li></p><p><li>如果有frame要发<strong>it must wait for slot boundary</strong>, trans at the starting</li></p><p><li>如果有碰撞，<strong>该节点在时间片结束之前检测到这次碰撞</strong>。该节点<strong>以概率</strong>在后续的每个时间片中重传它的帧，直到该帧被无碰撞地传输出去。</li></p><p><li>一个给定节点成功传输的概率为$p(1-p)^{n-1}$。N个节点成功的概率为$Np(1-p)^{n-1}$</li></p><p><li>Maximum utilization&#x3D;1&#x2F;e&#x3D;37%</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p><img src="/./img/slottedAloha.png" srcset="/img/loading.gif" lazyload alt="slottedAloha"></p></p><p><h4 id="LAN-performance-计算"><a href="#LAN-performance-计算" class="headerlink" title="LAN performance 计算"></a>LAN performance 计算</h4><h3 id="CSMA-listen-before-talking"><a href="#CSMA-listen-before-talking" class="headerlink" title="CSMA (listen before talking)"></a>CSMA (listen before talking)</h3><p>cs的意思就是发送一个载波监听是否idle</p></p><p><ul></p><p><li><p>Non-persistent:<br><img src="/./img/CSMA.png" srcset="/img/loading.gif" lazyload alt="non"><br> but the capacity is wasted</p></li></p><p><li><p>1-persistent</p></p><p><ul></p><p><li>when medium is busy, **continue to listen **until channel is sensed idle</li></p><p><li></li></ul></li></p><p><li><p>p-persistent</p></p><p><ul></p><p><li>if idle-&gt;transmit with probability p and delay <strong>one time unit</strong> with (1-p)</li></p><p><li>when medium is busy, <strong>continue to listen</strong> until channel is idle</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><table></p><p><thead></p><p><tr></p><p><th></th></p><p><th>non-persistent</th></p><p><th>1-persistent</th></p><p><th>p-persistent</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p><p><tbody><tr></p><p><td>idle</td></p><p><td>asap</td></p><p><td>asap</td></p><p><td>p asap,(1-p) wait for next slot</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>busy</td></p><p><td>stop listening, re-listen after a random time</td></p><p><td>keep listening</td></p><p><td>stop listening, re-listen after a random time</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;&lt;/table&gt;</p><p><h3 id="CSMA-x2F-CD-collision-detection"><a href="#CSMA-x2F-CD-collision-detection" class="headerlink" title="CSMA&#x2F;CD (collision detection)"></a>CSMA&#x2F;CD (collision detection)</h3><p>变发送边监听，半双工  </p></p><p><ul></p><p><li><p>process: </p></p><p><ul></p><p><li>1,2 和1-persistent一样</li></p><p><li>3.if collision detected<ul></p><p><li>Transmit a jam signal for one slot.</li></p><p><li>Wait for a random time and reattempt (up to 16 times).</li></p><p><li>Random time generated according to (exponential backoff algorithm):<ul></p><p><li>If a packet is collided n times, where n &lt; 16, then the node waits for $T &#x3D; x \times 512$ bit period. Where $K &#x3D; uniform[0, 2^m − 1]$ , and $m &#x3D; Min[10 , n]$ .</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><ol start="4"></p><p><li>Collision is detected by monitoring the voltage, high voltage</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Problems</p></p><p><ol></p><p><li>Collisions of frames leads to** unpredictable delays**.</li></p><p><li>Minimum packet size required (wasteful of BW in case of many short messages). </li></p><p><li>Poor performance under very heavy load.</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="IEEE-802-3-Frame-format"><a href="#IEEE-802-3-Frame-format" class="headerlink" title="IEEE 802.3 Frame format"></a>IEEE 802.3 Frame format</h3><p><img src="/./img/8023frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h2><p>Star, bus, ring</p></p><p><h3 id="Star-LANs"><a href="#Star-LANs" class="headerlink" title="Star LANs"></a>Star LANs</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><ul></p><p><li>Active central element referred to as hub.</li></p><p><li>Stations connects to the hub by <strong>two twisted pair wires</strong>.</li></p><p><li>Hub acts as a repeater, <strong>repeats signal from a station on outgoing links of all stations</strong>.</li></p><p><li>If two stations transmit at the same time -&gt; collision.</li></p><p><li>Physically a star, logically a bus connection</li></p><p><li>Multiple levels of hops can cascaded in a hierarchical configuration (can build very large networks).</li><br>&lt;/ul&gt;</p><p><p><img src="/./img/busvsstar.png" srcset="/img/loading.gif" lazyload alt="busvsstar"></p></p><p><h3 id="Ring-topology"><a href="#Ring-topology" class="headerlink" title="Ring topology"></a>Ring topology</h3><ul></p><p><li>Network consist of set of repeaters.</li></p><p><li>Repeaters are connected by point to point links.</li></p><p><li>Unidirectional link.</li></p><p><li>Data is transferred from one repeater to next.</li></p><p><li>Repeaters perform <strong>data insertion, reception, and removal.</strong></li></p><p><li>if not data removal <ul></p><p><li>by sender:<ul></p><p><li>used as an ack</li></p><p><li>enable multicasting</li></p><p><li>more fair transmission scenario<br><img src="/./img/star.png" srcset="/img/loading.gif" lazyload alt="star"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Token-ring"><a href="#Token-ring" class="headerlink" title="Token ring"></a>Token ring</h3><p>很有趣的一个拓扑  </p></p><p><ul></p><p><li><p>会有一个token circulate around ring</p></li></p><p><li><p>all station idle-&gt;token is free</p></li></p><p><li><p>station只有检测到free token的时候才能传输，其他station必须等</p></li></p><p><li><p>The station then appends and transmits the remainder of the field to make a data frame.</p></li></p><p><li><p>station will insert a <strong>new free token</strong> after transmitting</p></li></p><p><li><p>什么时候release token</p></p><p><ul></p><p><li>You have to finish your transmission and the leading edge has to return</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p>总的来说，token像一把钥匙，谁要发送msg就需要占用token，发送的信息会发往所有的station但是只会被 dest station <strong>复制</strong>，然后传回src station之后将其删除，然后重新生成一个新的token</p></p><p><h4 id="frame-format"><a href="#frame-format" class="headerlink" title="frame format"></a>frame format</h4><p><img src="/./img/8024frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="LAN-performance"><a href="#LAN-performance" class="headerlink" title="LAN performance"></a>LAN performance</h2><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><ul></p><p><li>The probability that a station attempts to transmit in a slot is $P$</li></p><p><li>$A$ is the probability that some station can send a transmit in a slot successfully, and is given by:<br> $$<br>A &#x3D; NP(1-P)^{N-1}<br>$$</li><br>&lt;/ul&gt;</p><p><h3 id="Token-rings"><a href="#Token-rings" class="headerlink" title="Token rings"></a>Token rings</h3><ol></p><p><li><p>when$t_{tr} \geq t_{prop}$</p></p><p><p>  $S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{1+\frac{a}{N}}$<br>where $a &#x3D; \frac{t_{prop}}{t_{tr}}$  </p><br>&lt;/li&gt;</p><p><li><p>when $t_{tr} &lt;  t_{prop}$<br>$S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{a+\frac{a}{N}}$</p></li><br>&lt;/ol&gt;</p><p><h3 id="LAN-address-MAC-address"><a href="#LAN-address-MAC-address" class="headerlink" title="LAN address(MAC address)"></a>LAN address(MAC address)</h3><ul></p><p><li>a bytes long, unique address, </li></p><p><li>won’t change when the adapter moves</li></p><p><li>Mapped to IP address using ARP</li><br>&lt;/ul&gt;</p><p><h3 id="repeaters-bridges-routers"><a href="#repeaters-bridges-routers" class="headerlink" title="repeaters,bridges, routers"></a>repeaters,bridges, routers</h3><ul></p><p><li>repeater<ul></p><p><li>physical layer</li></p><p><li>extend physical length</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>bridge<ul></p><p><li>connects similar LANs</li></p><p><li>identical physical and link layer protocols</li></p><p><li>why<ul></p><p><li>reliability: several self-contained units</li></p><p><li>performance </li></p><p><li>security: isolate info on separate LANs</li></p><p><li>geography: connect LANs at diff locations</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>router<ul></p><p><li>interconnect various LANs and WANs</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Address-learning"><a href="#Address-learning" class="headerlink" title="Address learning"></a>Address learning</h3><p>会就行</p></p><p><h3 id="wireless-LANs"><a href="#wireless-LANs" class="headerlink" title="wireless LANs"></a>wireless LANs</h3><br>            &lt;/div&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec1&amp;2</title>
    <link href="/2023/02/18/TeleLec1/"/>
    <url>/2023/02/18/TeleLec1/</url>
    
    <content type="html"><![CDATA[<p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本来以为这个课是小通原，还寻思又要被折磨了，结果发现是小计网，还是经典的不讲应用层的计网。  </p></p><p><h2 id="data-communications-vs-Network"><a href="#data-communications-vs-Network" class="headerlink" title="data communications vs Network"></a>data communications vs Network</h2><ul></p><p><li>communications: between 2 nodes. Only care the turnel</li></p><p><li>network: many nodes and links. No need link all nodes. take routing, addressing,congestion control into consideration.</li><br>&lt;/ul&gt;</p><p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><ul></p><p><li>def: millions of connected computing devices<ul></p><p><li>host: end systems</li></p><p><li>links:fiber,copper,ratio</li></p><p><li>packet switches: forward packets. <strong>routers and switches</strong></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="type-of-networks"><a href="#type-of-networks" class="headerlink" title="type of networks"></a>type of networks</h2><h3 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast:"></a>broadcast:</h3><ul></p><p><li>eg. bus mode–&gt; one can c others information</li><br>&lt;/ul&gt;</p><p><h3 id="swtiched-Networks"><a href="#swtiched-Networks" class="headerlink" title="swtiched Networks"></a>swtiched Networks</h3><h4 id="circuit-switched-Networks"><a href="#circuit-switched-Networks" class="headerlink" title="circuit-switched Networks"></a>circuit-switched Networks</h4><ul></p><p><li>a blocked network.</li></p><p><li>eg. old wired telephone. *end-end resources reserved.</li></p><p><li>link bandwidth, switch capacity.</li></p><p><li>dedicated resources</li><br>&lt;/ul&gt;</p><p><h3 id="packet-switched-network-non-blocking-network"><a href="#packet-switched-network-non-blocking-network" class="headerlink" title="packet switched network (non blocking network)"></a>packet switched network (non blocking network)</h3><ul></p><p><li>Each end-end data stream divided into <em>packets</em></li></p><p><li>no block but will delay till overflow. packet wait at router for output link</li><br>&lt;/ul&gt;</p><p><h4 id="virtual-circuit-vs-datagram-networks"><a href="#virtual-circuit-vs-datagram-networks" class="headerlink" title="virtual circuit vs datagram networks"></a>virtual circuit vs datagram networks</h4><ul></p><p><li><p>same goal: move packets tamgoung routers from src to dest</p></li></p><p><li><p>datagram: </p></p><ul><li>destination address determines next hop.</li><li>坐车时告诉司机目的地但是不一定nevigate路线，asking directions 所以 routes may change during session (取决于router的算法)</li><li></li></ul></li><li><p>virtual circuit</p><ul><li>has the map. tag determines next hop</li><li>fixed path determined at <strong>setup time</strong></li></ul></li></ul><h2 id="Loss-and-delay"><a href="#Loss-and-delay" class="headerlink" title="Loss and delay"></a>Loss and delay</h2><ul><li>loss:packet arrival rate to link (temporarily) exceeds output link capacity</li></ul><h3 id="type-of-delay"><a href="#type-of-delay" class="headerlink" title="type of delay"></a>type of delay</h3><ul><li>processing delay: negletive</li><li>queuing delay：$La&#x2F;R$, R-&gt;link bandwidth, a-.average packet arrival rate</li><li>transmission delay: 收费站排队进站.$t &#x3D; \frac{L}{R}$, R&#x3D;link bandwidth(bps), L &#x3D; packets(bits)</li><li>propagation delay: 开车时间, $delay &#x3D; \frac{d}{s}$</li></ul><h2 id="Portocol"><a href="#Portocol" class="headerlink" title="Portocol"></a>Portocol</h2><ul><li>def:set of rules governing the exchange of data between two entities in a system</li><li>Entities: users app, email facilities</li><li>Systems: computers, terminals, remote sensors</li><li>Protocol architectures: communication task broken up into modules<h3 id="Layerd-Network-Architecture"><a href="#Layerd-Network-Architecture" class="headerlink" title="Layerd Network Architecture"></a>Layerd Network Architecture</h3></li><li>define the commmunications abstractions defined by <strong>standardization bodies</strong></li><li>Layer N uses only service of Layer N-1, and only provides services to N+1</li></ul><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><ul><li>Control information is added to user data at each layer, add control inftomation(header) to data at each layer—&gt;封装</li><li>includ: destination SAP</li><li>Sequence number </li><li>Error detection code</li></ul><h3 id="TCP-x2F-IP-model-stack"><a href="#TCP-x2F-IP-model-stack" class="headerlink" title="TCP&#x2F;IP  model stack"></a>TCP&#x2F;IP  model stack</h3><p><img src="/img/teleTCPIPmodel.png" srcset="/img/loading.gif" lazyload alt="TCPIPmodel"></p><h2 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h2><p><img src="/img/teleEncap.png" srcset="/img/loading.gif" lazyload alt="encapsulation"></p><h1 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h1><h2 id="terminology"><a href="#terminology" class="headerlink" title="terminology"></a>terminology</h2><ul><li>Data transmission occurs between <strong>transmitter</strong> and <strong>receiver</strong> over some <strong>transmission medium</strong></li><li>Simplex: <strong>one direction</strong>,eg: TV</li><li>Half duplex: both transmit but not at a time. use full bandwidth</li><li>Full duplex: both dir, simultaneously</li></ul><h2 id="Analog-and-Digital-Data-Transmission"><a href="#Analog-and-Digital-Data-Transmission" class="headerlink" title="Analog and Digital Data Transmission"></a>Analog and Digital Data Transmission</h2><ul><li><p>advantages: cheaper and less susceptible to noise interference</p></li><li><p>Dis: suffer more from <strong>attenuation</strong>( the loss of signal strength in networking cables or connections)</p></li><li><p>signal has small band width. data is compressd to signal for trans<br><strong>analog signal</strong> is sampled to <strong>digital signal</strong></p></li></ul><h2 id="Transmission-Media"><a href="#Transmission-Media" class="headerlink" title="Transmission Media"></a>Transmission Media</h2><ul><li>guided - wire<ul><li>medium is more important</li></ul></li><li>unguided- wireless<ul><li>bandwidth produced by the antenna(天线) is more important</li></ul></li></ul><h3 id="Guided-transmission-media"><a href="#Guided-transmission-media" class="headerlink" title="Guided transmission media"></a>Guided transmission media</h3><h4 id="twisted-pair"><a href="#twisted-pair" class="headerlink" title="twisted pair"></a>twisted pair</h4><ul><li>application: Most common <ul><li>telephone, LANs,PBX</li></ul></li><li>pros:<ul><li>cheap</li><li>easy</li></ul></li><li>cons<ul><li>Low data rate</li><li>short range</li></ul></li><li>Unshield and shiled twisted pair<ul><li>STP: reduce interference</li></ul></li></ul><h4 id="coaxial-cable"><a href="#coaxial-cable" class="headerlink" title="coaxial cable"></a>coaxial cable</h4><ul><li>application:TV distribution, LANs. Long distance telephone transmission</li><li>pros: good noise immunity</li><li>cons:harder to install and repair, moderate cost</li></ul><h4 id="optical-fibers"><a href="#optical-fibers" class="headerlink" title="optical fibers"></a>optical fibers</h4><ul><li>application:Long-haul trunks, metropolitan trunks,LANs</li><li>pros:greater capacity, small size and weight, lower attenuation, reter repeater spacing </li><li>cons</li></ul><h3 id="wireless-communication"><a href="#wireless-communication" class="headerlink" title="wireless communication"></a>wireless communication</h3><ul><li>unguided, via antenna</li><li>Directional: focused beam and careful alignment required</li><li>Omnidirctional: spread in all directions, can be received by many antenna</li></ul><h2 id="Encoding-and-decoding"><a href="#Encoding-and-decoding" class="headerlink" title="Encoding and decoding"></a>Encoding and decoding</h2><h3 id="NRZ-amp-NRZI"><a href="#NRZ-amp-NRZI" class="headerlink" title="NRZ&amp;NRZI"></a>NRZ&amp;NRZI</h3><p>RZ: 一个周期内，用二进制传输数据位，在数据位脉冲结束后，需要维持一段时间的低电平。</p><ul><li>Non Return to Zero <ul><li>0 &#x3D;high level, 1&#x3D; low level   </li><li>一个周期可以全部用来传输数据</li></ul></li><li>Non Return to Zero, Invert on one<ul><li>如果有变化就是1，不变就保持</li></ul></li><li>Evaluation:<ul><li>+Efficiency use of bandwidth</li><li>+easy to implement</li><li>-DC component</li><li>-synchronization<ul><li>hard to determine begin and end of bits</li></ul></li></ul></li></ul><h3 id="Multilevel-binary"><a href="#Multilevel-binary" class="headerlink" title="Multilevel binary"></a>Multilevel binary</h3><p>三种电平：0,正,负</p><ul><li>Bipolar AMI(Alternate Inversion)   mark &#x3D;1<br>0 - no signal, 1 &#x3D; positive or neg but must alternate<br>anti DC </li><li>pseudoternary: 1 &#x3D; no signal, 0 &#x3D; positive neg (must alternate). 1编码成0电平，0编码成正负交替电平</li></ul><p><img src="/img/Bipolar-AMI.png" srcset="/img/loading.gif" lazyload alt="Bipolar-AMI"></p><ul><li>evaluation<ul><li>+no DC component  </li><li>+good synchronization</li><li>+error detection</li><li>-not efficient as NRZ</li></ul></li></ul><h3 id="Biphase"><a href="#Biphase" class="headerlink" title="Biphase"></a>Biphase</h3><h4 id="Manchester"><a href="#Manchester" class="headerlink" title="Manchester"></a>Manchester</h4><ul><li>transition in middle of every interval</li><li>0 &#x3D; transition from high to low in middle of interval</li><li>1&#x3D;transition from low to high in middle of interval 在</li></ul><h4 id="diff-Manchester"><a href="#diff-Manchester" class="headerlink" title="diff Manchester"></a>diff Manchester</h4><ul><li><p>0:在开头变</p></li><li><p>1:先保持在中间变</p></li><li><p>evaluation</p><ul><li>+Synchronization on mid bit transition</li><li>+no dc</li><li>+error detection</li><li>-need more bandwidth</li></ul></li></ul><p><img src="/img/manchester.png" srcset="/img/loading.gif" lazyload alt="Manchester"></p><h3 id="Digital-Data-Analog-Signals"><a href="#Digital-Data-Analog-Signals" class="headerlink" title="Digital Data Analog Signals"></a>Digital Data Analog Signals</h3><h4 id="Modulate"><a href="#Modulate" class="headerlink" title="Modulate"></a>Modulate</h4><ul><li>Amplitude Shift Keying (ASK)  </li><li>Frequency Shift Keying (FSK) </li><li>Phase shift Keying (PSK)</li></ul><h4 id="Digitization"><a href="#Digitization" class="headerlink" title="Digitization"></a>Digitization</h4><p>Def: analog data to digital data  </p><ul><li><p>Digital data can then be transmitted using code.</p></li><li><p>Digital data can then be converted to analog signal</p></li><li><p>Digital data can then be converted to <strong>analog signal</strong></p></li><li><p>Analog to digital conversion done using a code</p></li><li><p>Pulse code modulation</p></li><li><p>Delta modulation</p></li><li><p>why</p><ul><li>Higer f –&gt; more efficient</li><li>Permits frequency division multiplexing</li></ul></li><li><p>Type of modulation</p><ul><li>amplitude</li><li>phase</li><li>frequency</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MLLec3</title>
    <link href="/2023/02/18/MLLec2/"/>
    <url>/2023/02/18/MLLec2/</url>
    
    <content type="html"><![CDATA[<p><p>Chapter 3 of Machine Learning. This lecture discuss the loss function, population loss, optimal hard&#x2F; soft predictors, log-loss, cross-entropy loss and cross entropy, entropy and conditional entropy, KL divergence, and mutual information.</p><br><span id="more"></span></p><p><h1 id="Defining-Inference-推理"><a href="#Defining-Inference-推理" class="headerlink" title="Defining Inference(推理)"></a>Defining Inference(推理)</h1><ul></p><li>In inference problems we got two types variables: <ul><li>input</li><li>output, or target</li><li>A model is given by $p(x,t)$</li><p><h2 id="Two-kinds-of-inference"><a href="#Two-kinds-of-inference" class="headerlink" title="Two kinds of inference"></a>Two kinds of inference</h2><ul></p><li>detection problems:  takes value in a discrete and finite set</li><li>estimation problems: target is continuous</li><p><h3 id="predictor"><a href="#predictor" class="headerlink" title="predictor"></a>predictor</h3><p>two types:</p></p><ul><li>Hard predictor: specifies a single predicted value $\hat t$ of t for every value of x$&#x3D; x$<ul><li>$\hat t(x)$</li><li>x &#x3D; 0, $\hat{t}&#x3D;0$</li></ul></li><li>soft predictor：specifies a “score” for each possible value of $t$ given  $x&#x3D;x$<ul><li>$q(t|x)$</li><li>when x &#x3D; 0, output distribution (0.8,0.2) 分别为t&#x3D;0或者t&#x3D;1 –&gt; $q(1|0) &#x3D; 0.2$<br>Example:<br><img src="/./img/predictortype.png" srcset="/img/loading.gif" lazyload alt="eg"></li></ul></li></ul><h1 id="Optimal-soft-prediction-or-Bayesian-inference"><a href="#Optimal-soft-prediction-or-Bayesian-inference" class="headerlink" title="Optimal soft prediction, or Bayesian inference"></a>Optimal soft prediction, or Bayesian inference</h1><ul><li><p>A natural choice for the soft predictor $q(t|x)$ of t given $x &#x3D; x$ is the posterior distribution $p(t|x)$.</p></li><li><p>With this choice, the “score” q(t|x) assigned to each value of t is its posterior probability given x &#x3D; x.  </p><h2 id="calculation"><a href="#calculation" class="headerlink" title="calculation"></a>calculation</h2><p>  pmf:</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.45</td><td>0.05</td></tr><tr><td>1</td><td>0.1</td><td>0.4</td></tr></tbody></table></li><li><p>Given pmf $p(x,t)$</p></li><li><p>calculate the posterior $p(t|x)$</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.9</td><td>$\frac{0.05}{(0.45+0.05)&#x3D;0.1}$</td></tr><tr><td>1</td><td>0.2</td><td>0.8</td></tr></tbody></table></li><li><p>got the Bayesian soft predictor as<br>$$<br>(t|x&#x3D;0) ~ q(t|0) &#x3D; p(t|0) &#x3D; Bern(t|x)<br>$$<br>and<br>$$(t |x&#x3D;1)~q(t|1) &#x3D; p(t|1) &#x3D; Bern(t|0.8)<br>$$</p></li><li><p>conclusion<br>Ifx&#x3D;0,we can offer the hard prediction $\hat{t}(0) &#x3D; 0$ with associated probability of error of 0.1</p><h1 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h1></li><li><p>to measure the quality of hard prediction $\hat t$, we introduce the loss function $L(t,\hat{t})$</p></li><li><p>$L(t,\hat{t}) &#x3D; 0$ if $t &#x3D; \hat{t}$ </p></li><li><p>For estimation, </p><ul><li>we use $L_k$ loss for integer $k&gt;0$, def as<br>$$<br>L(t,\hat{t}) &#x3D; L_k(t,\hat{t}) &#x3D; |t-\hat{t}|^k<br>$$<ul><li>k &#x3D; 2 normally</li></ul></li></ul></li><li><p>for detection </p><ul><li>0-1 loss, indicator</li></ul></li></ul><p>$$<br>I(a) &#x3D; \begin{cases}<br>1&amp; \text{if a &#x3D; true }\<br>0&amp; \text{if a &#x3D; false}\<br>\end{cases}<br>$$</p><h1 id="Population-loss"><a href="#Population-loss" class="headerlink" title="Population loss"></a>Population loss</h1><ul><li>for given predictor $\hat{t}(·)$, we define population loss as<br>$$<br>L_p(\hat{t}(·)) :&#x3D; E_{(x,t)～p(x,t)}[L(t,\hat{t})]<br>$$</li><li>it is the average lose over the joint distribution of input and target  </li><li>对loss函数取个平均值</li><li>For detection-error loss</li></ul><p>(:&#x3D;的意思是，左边的东西被定义为右边)  </p><p>for a loss functiom, <strong>optimal hard predictor</strong> minimizes the <strong>population loss</strong>.<br>$$<br>\hat t^* (·) :&#x3D; arg min_{\hat t(·)}{L_p(\hat t(·))} &#x3D; E[l(t,\hat t(x))]<br>$$</p><h2 id="Population-detection-error-loss"><a href="#Population-detection-error-loss" class="headerlink" title="Population detection-error loss"></a>Population detection-error loss</h2><ul><li>def: the prob of detection error.<br>$$<br>Pr_{(x,t)<del>p(x,t)}[t\neq\hat t(x)]&#x3D;1-Pr_{(x,t)</del>p(x,t)}[t&#x3D;\hat t(x)]&#x3D;1-\sum_p(x,\hat t(x))<br>$$</li></ul><h1 id="Optimal-Hard-Predictor"><a href="#Optimal-Hard-Predictor" class="headerlink" title="Optimal Hard Predictor"></a>Optimal Hard Predictor</h1><ul><li><p>def: an optimal hard predictor minimizes the populationloss</p><p>$$<br>\hat{t^\star(·)} :&#x3D; arg\space min_{\hat{t}^(·)}{L_p(\hat t^*(·) )}&#x3D;E_{(x,t)\sim p(x,t)}[l(t,\hat t(x))]<br>$$</p></li></ul><p>means: the “argument” that <strong>minimizes</strong> the function in<br>the brackets, that is, the minimizer of this function.</p><ul><li>for any given loss function l, the optimal predictor can be directly computed from the <strong>posterior distribution</strong><br>$$<br>p(t|x)&#x3D;\frac{p(x,t)}{p(x)}<br>$$<br>也就是说能用optimal soft predictor来获得</li></ul><p>$$\hat{t^\star(·)}&#x3D;arg\space min_{\hat t \in{0,1}}E_{t\sim p(t|x)}[l(t,\hat t)]$$</p><h2 id="Optimal-Hard-Prediction-Under-Detection-Error-Loss"><a href="#Optimal-Hard-Prediction-Under-Detection-Error-Loss" class="headerlink" title="Optimal Hard Prediction Under Detection-Error Loss"></a>Optimal Hard Prediction Under Detection-Error Loss</h2><ul><li>the optimal predictor is the maximum of the posterior distribution, i.e.the posterior mode<br>$$<br>\hat{t^\star(x)} &#x3D; arg\space max_{t}p(t|x)<br>$$<br>it is maximum a posterior(MAP)<h2 id="Under-l-2-Loss"><a href="#Under-l-2-Loss" class="headerlink" title="Under $l_2$ Loss"></a>Under $l_2$ Loss</h2></li><li>the optimal hard predictor is the posterior mean, that is, the mean of the posterior distribution</li></ul><h1 id="Cross-Entropy-Loss"><a href="#Cross-Entropy-Loss" class="headerlink" title="Cross-Entropy Loss"></a>Cross-Entropy Loss</h1><p><strong>熵：用来衡量事物的不确定性</strong>，熵越大，信息量越大，是五月不确定，事物越复杂</p><ul><li>assign a loss to soft predictor –&gt; measure how good it is </li><li>To measure the loss of the soft predictor q(t|x) on a pair$(x,t)$<br>using<br> $$l&#x3D;-log q(t|x)$$</li></ul><p><img src="/./img/loglossplot.png" srcset="/img/loading.gif" lazyload alt="plot"></p><ul><li>large when predictor gives low probability to the correct output t given x, which measere the <strong>“superise”</strong></li><li>if t is discrete, the score is constrained in the itnerval[0,1]</li><li>can be negative when t is continuous</li><li>log-loss is used to compare different predictors<h2 id="Population-log-loss"><a href="#Population-log-loss" class="headerlink" title="Population log-loss"></a>Population log-loss</h2>an optimal soft predictor can then be obtained by minimizing the population log-loss<br>$$<br>min_{q(·|·)}{L_p(q(·|·))}&#x3D;E_{(x,t)\sim p(x,t)}[-log q(t|x)]<br>$$</li><li>it the cross entropy between $p(t)$ and $q(t)$</li><li>only for soft predictor and depends on the entire soft predictor q(t|x) obtained by considering all values of x and t<br>$$<br>L_p(q(·))&#x3D;H(p,q)<br>$$</li><li>这反映了 divergence between distribution p and q</li><li>if p &#x3D; q, minimizes the population log-loss</li></ul><h1 id="KL-divergence-kl散度，相对熵"><a href="#KL-divergence-kl散度，相对熵" class="headerlink" title="KL divergence (kl散度，相对熵)"></a>KL divergence (kl散度，相对熵)</h1><p><strong>一个用来衡量两个概率分布的相似性的一个度量指标</strong>，随机分布相同时，为0。<br>$$<br>KL(p||q) &#x3D; E_{t \sim p(t)}[log{\frac{p(t)}{q(t)}}]<br>$$<br><img src="/./img/LLR.png" srcset="/img/loading.gif" lazyload alt="LLR"></p><ul><li>The KL divergence is generally asymmetric<ul><li>$KL(p||q) \neq KL(q||p)$</li></ul></li><li>LLR 越大则分布越不同<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2></li><li>binomial distribution<br><img src="/./img/KLeg.png" srcset="/img/loading.gif" lazyload alt="KLeg"></li><li>normal distribution<br><img src="/./img/normeg.png" srcset="/img/loading.gif" lazyload alt="normeg"><h2 id="relationship-between-Cross-entropy-and-KL"><a href="#relationship-between-Cross-entropy-and-KL" class="headerlink" title="relationship between Cross entropy and KL"></a>relationship between Cross entropy and KL</h2>KL div can be expressed as<br>$$<br>H(p,q):&#x3D;E_{t\sim p(t)}[-log(t)]<br>$$<br>which can have the equality<br>$$<br>KL(p||q)&#x3D;H(p,q)-H(p,p)<br>$$<h1 id="Differential-Entropy"><a href="#Differential-Entropy" class="headerlink" title="Differential Entropy"></a>Differential Entropy</h1></li><li>For Gaussian rv $t\sim N(\mu,\sigma ^2)&#x3D;\frac{1}{2}log(2\pi e\sigma^2)$</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>First lecture of 7CCEMMLE Machine Learning</title>
    <link href="/2023/02/17/MLLec1/"/>
    <url>/2023/02/17/MLLec1/</url>
    
    <content type="html"><![CDATA[<p><h1 id="First-Lec-of-Machine-Learning"><a href="#First-Lec-of-Machine-Learning" class="headerlink" title="First Lec of Machine Learning"></a>First Lec of Machine Learning</h1><h2 id="intro-of-Module"><a href="#intro-of-Module" class="headerlink" title="intro of Module"></a>intro of Module</h2><ul></p><p><li>basic of Linearg algebra, calculus, and probability</li></p><p><li>MATLAB</li><br>&lt;/ul&gt;</p><p><h2 id="what-is-ML"><a href="#what-is-ML" class="headerlink" title="what is ML"></a>what is ML</h2><ol></p><p><li>Induction bias selection: selection of a model<br>train process: optimise </li></p><p><li>Learning: based on data, collection typical data to opitimize algorism</li></p><p><li>Inference, control: use the trained machine(a black-box) then generalize<br><img src="/img/mllec1.png" srcset="/img/loading.gif" lazyload alt="ML approach"><br>Integrating domain knowledge into a machine learning approach<h2 id="ML-method"><a href="#ML-method" class="headerlink" title="ML method"></a>ML method</h2></li><br>&lt;/ol&gt;</p><p><ul></p><p><li>supervised learning </li></p><p><li>unsupervised learning </li></p><p><li>reinforcement(强化学习) learning</li><br>&lt;/ul&gt;</p><p><h3 id="supervised-vs-unsupervised-learing"><a href="#supervised-vs-unsupervised-learing" class="headerlink" title="supervised vs unsupervised learing"></a>supervised vs unsupervised learing</h3><p><img src="/img/mllec2.png" srcset="/img/loading.gif" lazyload alt="vs"><br>supervised: classification. Give data to train a model that generalized can give result about data not in dataset<br>unsuervised : cluster </p></p><p><h2 id="When-to-use"><a href="#When-to-use" class="headerlink" title="When to use"></a>When to use</h2><h3 id="Potential-advantages"><a href="#Potential-advantages" class="headerlink" title="Potential advantages"></a>Potential advantages</h3><ul></p><p><li>lower cost and faster development </li></p><p><li>reduced implementation complexity</li><br>&lt;/ul&gt;</p><p><h3 id="potential-disadvantages"><a href="#potential-disadvantages" class="headerlink" title="potential disadvantages"></a>potential disadvantages</h3><ul></p><p><li>suboptimal performance and limited perfomance guarantees</li></p><p><li>limited interpretability</li><br>&lt;/ul&gt;</p><p><h1 id="Basic-Background"><a href="#Basic-Background" class="headerlink" title="Basic Background"></a>Basic Background</h1><ul></p><p><li>refresher on probablity and linear algebra<h2 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h2></li>ML</p><p><li>def: a random numberical quantitiesthat takes values in a set </li></p><p><li>Bernoulli variable（二分步）: $x～Bern(q)$，set: $X &#x3D; {0,1}$</li><br>&lt;/ul&gt;</p><p>$p(1) &#x3D; Bern(1|q) &#x3D; Pr[x&#x3D;1] &#x3D; q$   </p><ul><li>Categorical variable:<ul><li>$x~Cat(q)$ take values in $X &#x3D; {0,1,2,3,\ddots,}$</li><li>$p(k) &#x3D; Cat(k|q) &#x3D; Pr[x&#x3D;k] &#x3D; q_k$</li></ul></li></ul><h3 id="decrete-RV"><a href="#decrete-RV" class="headerlink" title="decrete RV"></a>decrete RV</h3><p>categorical rvs are represented using one-hot verctor<br>$x^OH$ os dimension Cx1 with all zeros except for a one in the (k + 1)th position when x &#x3D; k<br>For C&#x3D;4, x &#x3D; 0:<br>$$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;1\ &amp;0\&amp;0\&amp;0\end{bmatrix}$$<br>  if x &#x3D;2<br>  $$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;0\ &amp;0\&amp;1\&amp;0\end{bmatrix}$$</p><h3 id="continuous-rv"><a href="#continuous-rv" class="headerlink" title="continuous rv"></a>continuous rv</h3><p>described by pdf. p(x): x~p(x)<br>$p(x)\geq0$and $\int ^{\infin}_{-\infty} p(x)dx &#x3D;1$  </p><p><strong>Gaussian is the most important</strong></p><h4 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h4><p>$$x \sim N(\mu,\sigma^2)&#x3D;\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(x-\mu)^2}{2\sigma^2}$$<br>$\mu$ is the Expection and $\sigma^2$ is Variance</p><h2 id="Expectation-and-variance"><a href="#Expectation-and-variance" class="headerlink" title="Expectation and variance"></a>Expectation and variance</h2><h3 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h3><ul><li>$$E_{x\sim p(x)} [x] &#x3D; \sum_{x \in X} {p(x) \cdot x}$$</li><li>the expectation of function of a dicrete rv is<br>$$E_{x\sim p(x)} [f(x)] &#x3D; \sum_{x \in X} {p(x) \cdot f(x)}$$</li><li>For Categorical<br>$$E_{x\sim Cat(q)} [f(x)] &#x3D; \sum_{x \in X} {q(x) \cdot f(x)}$$</li><li>For continuous rv:</li></ul><p>$$E_{x\sim p(x)} [f(x)] &#x3D; \int_{-\infin}^{\infty} {p(x) \cdot f(x)dx}$$</p><ul><li>For Gaussian</li></ul><p>$$E_{x \sim N(\mu,\sigma^2)} [x] &#x3D; \mu$$<br>$$E_{x \sim N(\mu,\sigma^2)} [x^2] &#x3D; \mu^2+\sigma^2$$</p><ul><li>It is linear</li></ul><h3 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h3><p>For Categorical rv $x\sim Cat(q)$:$$<br>$$Var(x) &#x3D; \sum^{C-1}<em>{x&#x3D;0} q_x(x-(\sum^{C-1}</em>{x&#x3D;0}q_x x))^2$$  </p><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><ul><li><p>vector is an ordered collection of scalars.</p></li><li><p>tanspose: $x^T$<br>,from row to column or from column2row.</p></li><li><p>inner pordx&#96;uct: a measure of <strong>similarity</strong></p></li><li><p>Inner product $x^Ty &#x3D; \sum^L_{i&#x3D;1}x_iy_i$</p></li><li><p><strong>Normalize</strong><br>$$||x||&#x3D;\sqrt{x^Tx}&#x3D;\sqrt{\sum_{i&#x3D;1}^L x_i^2}$$</p></li><li><p>unitary norm of vector $\tilde s&#x3D;\cfrac{x}{||x||}$, $||\tilde{x}||^2 &#x3D; 1$</p></li><li><p>orthogonal: $x^Ty &#x3D; 0$</p></li><li><p>Diagonal matrix: L x L, only diag is 1  </p></li><li><p>$Diag(a)&#x3D;\begin{bmatrix}<br>&amp;a_1 &amp;0 &amp;\cdots &amp;0\<br>&amp;0 &amp;a_2 &amp;\cdots &amp;0 \<br>&amp;\vdots &amp; &amp;\ddots&amp;\vdots\<br>&amp;0 &amp;0 &amp;\cdots &amp;a_L\end{bmatrix}$</p></li><li><p>Outer producet: 2 L x 1 vectors make LxL matrix</p></li><li><p>Symmetric matrix:对称矩阵。$A^T &#x3D; A$</p></li><li><p>Outer product. </p></li><li><p>vector-matrix multiplication: $x^TA &#x3D; (A^Tx)^T$</p><ul><li>positive simi-define:</li></ul></li><li><p>Eigenvector &amp; Eigenvalue</p><ul><li>in fact it the eigenvector is a base vector and the eigenvalue is a scaling factor so that we can simplify the calculation of a linear transformation on one vector.</li><li>def: if A is an $n \times n$ matrix,if there is an non-zero vector $x$ can let $Ax &#x3D; \lambda x$, then the $\lambda$ is the eigenvalue and the vector $x$ is the eigenvector belonging to $\lambda$.</li></ul></li><li><p>calculation of eigenvector</p></li></ul><p>$$(A-\lambda I)x&#x3D;0$$<br>which means<br>$$det(A-\lambda I)&#x3D;0$$  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linkedarray</title>
    <link href="/2023/02/17/linkedarray/"/>
    <url>/2023/02/17/linkedarray/</url>
    
    <content type="html"><![CDATA[<p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">题目</a><br>一个很简单的链表题，第一次做老忘记将指针向下一个移动，即<code>p = p.next</code><br>会用到虚拟头节点，可以避免处理空指针的情况，降低代码的复杂性</p></p><p><h2 id="合并k个生序链表"><a href="#合并k个生序链表" class="headerlink" title="合并k个生序链表"></a>合并k个生序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">题目</a><br>解题思路依然是寻找最小的结点然后连接到dummy上，but因为是k个链表，如果用最朴素的比较方法，会比较的次数较多，时间复杂度高，<strong>所以采用优先级队列</strong>，把链表接电放进去即可获得k个节点里的最小节点. <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/2/22/64/">二叉堆</a> 在这里讲的挺好的，可以参考。  </p></p><p><h2 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目</a><br>可以使用双指针fast指针先走k步，然后fast和slow同事走n-k步，slow就指向倒数第k个节点了  </p></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回链表的倒数第 k 个节点</span><br>ListNode <span class="hljs-title function_">findFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 先走 k 步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 和 p2 同时走 n - k 步</span><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br>```  <br>用这个方法+dummy node即可正确删除节点  <br>## 单链表的中点<br>[题目](https:<span class="hljs-comment">//leetcode.cn/problems/middle-of-the-linked-list/)  </span><br>依然快慢指针。这个题与**链表是否包含环** 解法差不多，快指针一次走两步，慢指针一次走一步，当快指针走到头的时候，慢指针正好是中点  <br>```Java<br>ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步  注意循环结束的点</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>是否有环&amp;&amp;环的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码类似 hasCycle 函数</span><br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// fast 遇到空指针说明没有环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 重新指向头结点</span><br>    slow = head;<br>    <span class="hljs-comment">// 快慢指针同步前进，相交点就是环起点</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：  </p><p><img src="/img/Midcycle1.png" srcset="/img/loading.gif" lazyload alt="img1"></p><p>fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走k步可以转回到相遇点，那走 k - m 步肯定就走到环起点了<br><img src="/img/Midcycle2.png" srcset="/img/loading.gif" lazyload alt="img2"></p><h2 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a><br>用俩指针，分别从AB遍历，当便利完时接上另一个，当两个指针相遇时结束，并且是节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span><br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>            p1 = p1.next;<br>        <span class="hljs-comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><p><h2 id="递归反转链表"><a href="#递归反转链表" class="headerlink" title="递归反转链表"></a>递归反转链表</h2><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目</a><br>反转链表可以使用递归和迭代两种办法，首先说迭代。<br><img src="/img/reverse1.png" srcset="/img/loading.gif" lazyload alt="reverse1"><br>迭代的方法是要存储当前节点  </p></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(List Node head)</span>&#123;<br>    ListNode pre,nxt,cur;<br>    pre = <span class="hljs-literal">null</span>;<br>    nxt = cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>)&#123;<br>        nxt = cur.next;<br>        cur.next = pre;<br><br>        pre = cur;<br>        cur = nxt<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>再有就是递归解法，递归很有趣，采用的是假设，假设出了第一个以外的节点已经反转了，这个该怎么处理呢</p><p>&#96;&#96;&#96; java<br>public ListNode reverse(ListNode head){<br>    if(head &#x3D;&#x3D; null|| head.next &#x3D;&#x3D; null){ &#x2F;&#x2F; 递归函数的base case，意思是链表为空或者只有自己的时候，直接返回<br>        return head;<br>    }<br>    ListNode last &#x3D; reverse(head.next);<br>    head.next.next &#x3D; head;<br>    head.next &#x3D; null;</p><div class="code-wrapper"><pre><code class="hljs">return last;</code></pre></div><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dns</title>
    <link href="/2023/02/17/dns/"/>
    <url>/2023/02/17/dns/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DNS任务<br>人们使用时更喜欢使用hostname但是router更喜欢使用IP。DNS其实主要是为了将域名转换为IP地址，也可以把IP转换为域名<br> DNS是：  </p><ul><li>一个由分层的dns服务器实现的分布式数据库。</li><li>一个让主机能够查询分布式数据库的应用层协议<h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2></li><li>域名解析</li><li>主机别名</li><li>邮件服务器别名</li><li>负载分配：可用于冗余的服务器之间进行负载分配。<h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2>当一个用户主机的浏览器（HTTP用户）请求URL时</li></ul><ol><li>同一台用户主机上运行着DNS应用的客户端</li><li>浏览器从URL中抽出主机名，并把主机名传给DNS应用的客户端</li><li>客户端想DNS发送一个包含主机名的请求。<strong>所有的DNS请求和回答报文都是UDP数据报通过端口53发送</strong></li><li>DNS client会收到一个回答报文，包含对应的IP</li><li>一旦浏览器收到了IP，就能够向改IP地址80端口的http服务器发起一个TCP链接</li></ol><h2 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h2><p><strong>DNS是分布式数据库的范例</strong>  </p><h3 id="分布式、分层次的数据库"><a href="#分布式、分层次的数据库" class="headerlink" title="分布式、分层次的数据库"></a>分布式、分层次的数据库</h3><p>目的：解决扩展性问题<br><img src="/img/dns.png" srcset="/img/loading.gif" lazyload alt="层次结构"><br>类型：<br>根DNS服务器：提供TLD服务器的IP地址<br>顶级域（TLD）DNS服务器:例如:com,org,net,edu,gov和国家顶级域如uk,fr,ca。<br>权威DNS服务器</p><h3 id="local-DNS"><a href="#local-DNS" class="headerlink" title="local DNS"></a>local DNS</h3><p>每个ISP都有一台 local dns 。主机和某个ISP链接时，ISP提供一台主机的IP。该主机具有一台或多台local dns server的IP（通过DHCP）。<br>来个简单的例子<br><img src="/img/dns2.png" srcset="/img/loading.gif" lazyload alt="DNS交互"><br>主机为了获得gaia.cs.umass.edu的IP地址需要进行图里的8次调用！八次！！，如果umass为每个系在增设一个dns服务器的话，将会成为10次。<br>其中用到了的递归查询和迭代查询。<br>递归查询：cse.nyu.edu刀dns.nyu.edu的查询，因为查询是已自己的名义请求dns获得映射。<br>迭代查询： 剩下的三个查询都是迭代查询，因为是把结果返回给dns.nyu.edu<br><strong>因为这样处理的话，实在太麻烦了，会造成所以就提出了DNS缓存的概念</strong></p><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>原理：在一个请求链中，当某个NDS服务器接收到一个DNS回答，能将映射缓存在本地服务器中</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown</title>
    <link href="/2023/02/17/markdown/"/>
    <url>/2023/02/17/markdown/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs clean"># 一级 <br>## 二级<br>### 三级<br>#### 四级<br>...<br></code></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span>效果如下面的线<br></code></pre></td></tr></table></figure><hr><h2 id="常用标识"><a href="#常用标识" class="headerlink" title="常用标识"></a>常用标识</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p><em>斜体</em>  <code>*斜体*</code>  <br></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p><strong>粗体</strong> <code> **粗体**</code> <br></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><code>行内代码块</code> `行内代码块` <br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">代码块<br><br></code></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>[]里写文字，()里写地址 <br></p><p>自动链接<br>&lt;&gt;里面写邮箱或者地址</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无需列表"><a href="#无需列表" class="headerlink" title="无需列表"></a>无需列表</h3><p>直接使用 -,*</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>列表1<br><span class="hljs-bullet">- </span>列表2<br></code></pre></td></tr></table></figure><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li><ol start="2"><li><ol start="3"><li><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2>![图片Alt](图片地址 “图片Title”)<br>对fluid主体来说，要把图片放在&#x2F;source&#x2F;img中  <h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</li></ol></li></ol></li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><p>因为开学了 发现markdown记笔记还是挺好用的，但好多数学符号还是有点难打，于是找了相关资料。 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e74eb43960a1">这个还是很好的</a>  </p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>行内公式用<code>$公式内容$</code>  $xyz$<br>单独行公式<code>$$公示内容$$</code> $$xyz$$  </p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><ul><li>上标: ^ :$x^y$</li><li>下标：_: $x_y$ </li><li>组合符号：{},eg <code>$&#123;16&#125;_&#123;8&#125;O&#123;2+&#125;_&#123;2&#125;$</code> ${16}<em>{8}0{2+}</em>{2}$</li><li>中括号，符号：[]，如：<code>$[x+y]$</code> &#x3D; $[x+y]$</li><li>大括号，符号：{ }，如：<code>$&#123;x+y&#125;$</code>–  ${x+y}$</li><li>自适应括号，符号：\left \right，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：{上位公式 \choose 下位公式}，如：${n+1 \choose k}&#x3D;{n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：{上位公式 \atop 下位公式}，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots&#x3D;n}A_{k_0}A_{k_1}\cdots$</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>加\减还是+-</li><li>加减运算:<code>\pm</code> :$x\pm y$</li><li>乘法：<code>\times</code>: $x\times y&#x3D;z$</li><li>点乘：<code>\cdot\</code>:$x \cdot y &#x3D; z$</li><li>星乘：<code>\ast</code>: $x \ast y$</li><li>除法：<code>\div</code>: $x \div y$</li><li>斜法：<code>/</code>: $x&#x2F;y$</li><li>分式表示：<code>&#123;分子&#125; \over &#123;分母&#125; </code>: ${x} \over {y}$</li><li>绝对值：||<h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul><li>平均数:<code>\overline&#123;&#125;</code> $\overline{xyz}$</li><li>开方:<code>\sqrt</code> $\sqrt{x}$<br> <code>\sqrt&#123;&#125;&#123;&#125;</code> $\sqrt[3]{xyz}$</li><li>对数运算:<code>\log_x(y)</code> $\log_2(x)$</li><li>极限运算:<code>\lim</code>,  </li><li><code>$\lim^&#123;x\to\infin&#125;_&#123;y\to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</code> $\lim^{x\to\infin}_{y\to 0}{\frac{x}{y}}$</li><li>求和运算:<code>\sum</code><br><code>$\sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code><br>$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算:<code>\int</code> $\int^{\infty}_{0}{xdx}$</li><li>微分运算:<code>\partial</code> $\frac{\partial x}{\partial y}$</li><li>矩阵运算:<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code><br><code>$\left[ \begin&#123;matrix&#125; 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end&#123;matrix&#125; \right]$</code></li></ul></li></ul><p>$\left[\begin{matrix}<br>    1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8 \ \vdots &amp;\vdots &amp;\ddots\ &amp;vdots \13 &amp;14 &amp;\cdots &amp;16<br>\end{matrix}\right]$</p><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><ul><li>属于运算，符号：<code>\in</code>，如：$x \in y$<br>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$并集运算，符号：\cup，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li></ul><pre><code class="hljs">        &lt;/div&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>array</title>
    <link href="/2023/02/17/array/"/>
    <url>/2023/02/17/array/</url>
    
    <content type="html"><![CDATA[<p>数组属于是最基本的数据结构了，二分查找、滑动窗口、双指针等都在这里有体现。<br><span id="more"></span></p><p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>双指针经常用在数组、链表中，主要分为：<strong>左右指针和快慢指针</strong>  ，当出现了数组有序的情况，就要考虑是不是要用双指针</p></p><p><ul></p><p><li>左右指针：两个指针由两边往内走或者从内往两边走  </li></p><p><li>快慢指针：往一个方向走</li><br>&lt;/ul&gt;</p><p><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">题目1</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">题目2</a><br>这是一个很有意思的题，关键点是 <strong>原地</strong>修改数组，也就是不能引入新的数组，不然就很简单了。<br>这个题用快慢指针很有趣的一点是，用fast去探路，如果是不重复的，就让slow走一步，如果是重复的，就把fast的值给slow，这样可以保[0,slow]都是不重复的， 非常有意思。</p></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>            slow++;<br>            <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-comment">// 数组长度为索引 + 1</span><br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找其实就是双指针，之后做题多了会写一篇各种二分法的博，写的更详细一点，在这里就只需要知道是个双指针就行了</p></p><p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">题目</a><br>也是一个不难考虑的题，首先考虑长度是0的情况，但是体感说了大于2，就不考虑了</p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = numbers.length-<span class="hljs-number">1</span>,sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            sum = numbers[left]+numbers[right];<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target) &#123;<br>                right--;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure><p><h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><br>            &lt;/div&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
