<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>吴恩达机器学习笔记</title>
    <link href="/2024/06/19/AndrewML/"/>
    <url>/2024/06/19/AndrewML/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h1><h2 id="Ch1-Supervised-vs-Unsupervised-Learning"><a href="#Ch1-Supervised-vs-Unsupervised-Learning" class="headerlink" title="Ch1 Supervised vs Unsupervised Learning"></a>Ch1 Supervised vs Unsupervised Learning</h2><h3 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h3><p>Algorithm mapping from imput to output. The key is: <strong>give the example for algorithm to learn from</strong>, which contains right answer. So that algorithm can make correct predict.<br>Learn from being given right answer.</p><ul><li>Regression: predict a number infinitedly many possible outputs</li><li>Classification:<br>regression is continue but classification is discontinue<h3 id="Unsupervised-learning"><a href="#Unsupervised-learning" class="headerlink" title="Unsupervised learning"></a>Unsupervised learning</h3>Find something interesting in <strong>unlabled</strong> data.<br>Clustring: The algo will decided to assign the data to different groups or clusters<br><img src="/img/ML2.4-1.png" alt="clustering">  </li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StatusChain</title>
    <link href="/2024/06/04/StatusChain/"/>
    <url>/2024/06/04/StatusChain/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于Hyperledger-Fabric的学籍管理系统实现方案"><a href="#基于Hyperledger-Fabric的学籍管理系统实现方案" class="headerlink" title="基于Hyperledger Fabric的学籍管理系统实现方案"></a>基于Hyperledger Fabric的学籍管理系统实现方案</h1><h2 id="用户问题与解答"><a href="#用户问题与解答" class="headerlink" title="用户问题与解答"></a>用户问题与解答</h2><h3 id="用户问题-1"><a href="#用户问题-1" class="headerlink" title="用户问题 1"></a>用户问题 1</h3><p><strong>问题：技术选型为什么这样选？</strong></p><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>选择适合的技术栈对于项目的成功至关重要。以下是我们针对基于Hyperledger Fabric的学籍管理系统的技术选型及其原因：</p><h4 id="1-区块链平台：Hyperledger-Fabric"><a href="#1-区块链平台：Hyperledger-Fabric" class="headerlink" title="1. 区块链平台：Hyperledger Fabric"></a>1. 区块链平台：Hyperledger Fabric</h4><p><strong>原因：</strong></p><ul><li><strong>权限管理：</strong> Hyperledger Fabric是一种许可区块链平台，适合需要严格权限管理的场景。各参与方可以通过预定义的身份认证机制访问数据。</li><li><strong>模块化架构：</strong> Fabric具有高度模块化的架构，可以根据具体需求选择和配置不同的模块，如共识机制、成员管理等。</li><li><strong>隐私和机密性：</strong> Fabric支持多通道架构，可以在一个网络中创建多个通道，每个通道上的交易数据对其他通道不可见，确保数据隐私。</li><li><strong>成熟的企业级解决方案：</strong> Hyperledger Fabric由Linux基金会托管，得到广泛的企业支持，拥有良好的社区和文档支持。</li></ul><h4 id="2-智能合约语言：Go-或-JavaScript-Chaincode"><a href="#2-智能合约语言：Go-或-JavaScript-Chaincode" class="headerlink" title="2. 智能合约语言：Go 或 JavaScript (Chaincode)"></a>2. 智能合约语言：Go 或 JavaScript (Chaincode)</h4><p><strong>原因：</strong></p><ul><li><strong>性能与稳定性：</strong> Go语言具有高性能和稳定性，适合编写高效的链码。</li><li><strong>开发者生态：</strong> JavaScript是最广泛使用的编程语言之一，拥有大量的开发资源和社区支持。</li><li><strong>Fabric支持：</strong> Hyperledger Fabric原生支持使用Go和JavaScript编写链码，能够充分利用平台特性。</li></ul><h4 id="3-前端框架：React-js"><a href="#3-前端框架：React-js" class="headerlink" title="3. 前端框架：React.js"></a>3. 前端框架：React.js</h4><p><strong>原因：</strong></p><ul><li><strong>组件化：</strong> React.js使用组件化的开发模式，可以重用组件，提升开发效率和代码可维护性。</li><li><strong>性能：</strong> React.js通过虚拟DOM实现高效的UI更新，提升用户体验。</li><li><strong>生态系统：</strong> React.js有丰富的生态系统和第三方库支持，能快速实现复杂的前端功能。</li></ul><h4 id="4-后端框架：Node-js-Express"><a href="#4-后端框架：Node-js-Express" class="headerlink" title="4. 后端框架：Node.js + Express"></a>4. 后端框架：Node.js + Express</h4><p><strong>原因：</strong></p><ul><li><strong>非阻塞I/O：</strong> Node.js采用事件驱动和非阻塞I/O模型，适合高并发、高吞吐量的应用场景。</li><li><strong>一致性：</strong> 使用JavaScript作为前后端语言，减少了学习成本和上下文切换，提升开发效率。</li><li><strong>简洁和高效：</strong> Express是一个简洁且灵活的Node.js Web应用框架，提供了丰富的中间件，可以快速搭建RESTful API服务。</li></ul><h4 id="5-数据库：MongoDB"><a href="#5-数据库：MongoDB" class="headerlink" title="5. 数据库：MongoDB"></a>5. 数据库：MongoDB</h4><p><strong>原因：</strong></p><ul><li><strong>灵活的数据模型：</strong> MongoDB是一个NoSQL数据库，使用文档存储数据，数据模型灵活，适合快速变化的应用需求。</li><li><strong>水平扩展：</strong> MongoDB支持水平扩展，能够处理大量数据和高并发请求。</li><li><strong>JSON文档存储：</strong> MongoDB使用JSON格式存储数据，与前端的JSON数据格式一致，简化了数据处理流程。</li></ul><h4 id="6-其他工具：Fabric-SDK"><a href="#6-其他工具：Fabric-SDK" class="headerlink" title="6. 其他工具：Fabric SDK"></a>6. 其他工具：Fabric SDK</h4><p><strong>原因：</strong></p><ul><li><strong>与Fabric集成：</strong> Fabric SDK提供了与Hyperledger Fabric网络交互的API，可以方便地调用链码，提交交易，查询数据。</li><li><strong>多语言支持：</strong> Fabric SDK支持多种编程语言，包括JavaScript、Go、Java等，提供灵活的开发选择。</li></ul><h3 id="用户问题-2"><a href="#用户问题-2" class="headerlink" title="用户问题 2"></a>用户问题 2</h3><p><strong>问题：Hyperledger Fabric 的优势是什么，为什么不选择其他的？</strong></p><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><p>Hyperledger Fabric 的优势在于其独特的架构设计和强大的企业级功能，使其在需要高安全性、隐私性和灵活性的企业应用中表现优异。</p><h4 id="Hyperledger-Fabric-的主要优势"><a href="#Hyperledger-Fabric-的主要优势" class="headerlink" title="Hyperledger Fabric 的主要优势"></a>Hyperledger Fabric 的主要优势</h4><ol><li><strong>权限管理与隐私性</strong></li></ol><ul><li><strong>许可区块链：</strong> Hyperledger Fabric 是一种许可区块链，允许网络成员通过受控的身份验证机制加入网络，确保只有授权的实体可以访问和操作数据。</li><li><strong>多通道架构：</strong> 支持创建多个独立的通道，每个通道有自己的账本和智能合约，确保交易数据仅在相关方之间共享，提高隐私性和数据隔离。</li><li><strong>私有数据集合：</strong> Fabric 支持私有数据集合功能，允许在链上存储私密数据，只对相关方可见，进一步提升数据隐私。</li></ul><ol><li><strong>模块化架构</strong></li></ol><ul><li><strong>灵活配置：</strong> Fabric 的模块化设计允许开发者根据需求选择和配置不同的模块，如共识机制、成员管理、智能合约等，提供高度的定制化能力。</li><li><strong>可插拔共识机制：</strong> 支持多种共识机制，如 Kafka、Raft，可以根据具体应用场景选择最适合的共识算法，提高系统的性能和可靠性。</li></ul><ol><li><strong>高性能和可扩展性</strong></li></ol><ul><li><strong>链码执行：</strong> Fabric 将链码执行和交易排序分离，采用并行执行链码的方式，提高交易处理速度和系统吞吐量。</li><li><strong>水平扩展：</strong> 支持通过增加节点来扩展网络规模和处理能力，适应业务增长需求。</li></ul><ol><li><strong>企业级支持</strong></li></ol><ul><li><strong>Linux 基金会支持：</strong> Hyperledger Fabric 由 Linux 基金会托管，得到广泛的企业支持和良好的社区资源。</li><li><strong>成熟的工具和生态系统：</strong> 提供丰富的开发工具、SDK 和文档支持，帮助开发者快速上手和部署应用。</li></ul><h4 id="为什么不选择其他区块链平台"><a href="#为什么不选择其他区块链平台" class="headerlink" title="为什么不选择其他区块链平台"></a>为什么不选择其他区块链平台</h4><ol><li><strong>以太坊 (Ethereum)</strong></li></ol><ul><li><strong>公有链 vs 许可链：</strong> 以太坊主要用于公有链应用，虽然也有企业级解决方案（如 Quorum），但其权限管理和隐私保护机制不如 Fabric 灵活和强大。</li><li><strong>智能合约性能：</strong> 以太坊的智能合约执行在所有节点上进行，性能较低且难以扩展，高交易费用也是一个问题。</li></ul><ol><li><strong>EOSIO</strong></li></ol><ul><li><strong>共识机制：</strong> EOSIO 使用 DPoS（委任权益证明）共识机制，依赖于超级节点，虽然性能较高，但去中心化程度和安全性可能不如 Fabric。</li><li><strong>企业支持：</strong> EOSIO 的企业级支持和工具生态系统相对较少，特别是在企业级权限管理和隐私保护方面。</li></ul><ol><li><strong>Corda</strong></li></ol><ul><li><strong>金融领域专注：</strong> Corda 主要面向金融行业，尽管其点对点的隐私交易和高效的共识机制适用于金融应用，但在其他领域的通用性和扩展性不如 Fabric。</li><li><strong>社区支持：</strong> 相较于 Fabric，Corda 的社区支持和开发资源相对较少。</li></ul><h3 id="用户问题-3"><a href="#用户问题-3" class="headerlink" title="用户问题 3"></a>用户问题 3</h3><p><strong>问题：它支持什么共识机制？如何数据上链？</strong></p><h4 id="解答：-2"><a href="#解答：-2" class="headerlink" title="解答："></a>解答：</h4><p>Hyperledger Fabric支持多种共识机制，并且其独特的模块化架构允许根据需求灵活选择和配置不同的共识机制。</p><h4 id="Hyperledger-Fabric-支持的共识机制"><a href="#Hyperledger-Fabric-支持的共识机制" class="headerlink" title="Hyperledger Fabric 支持的共识机制"></a>Hyperledger Fabric 支持的共识机制</h4><ol><li><strong>Crash Fault Tolerance (CFT)</strong></li></ol><ul><li><strong>Raft:</strong> Fabric 从 1.4 版本开始原生支持 Raft 共识机制。Raft 是一种基于领导者的分布式一致性算法，具有较高的性能和容错能力，适合大多数企业应用。</li><li><strong>Kafka:</strong> Fabric 也支持 Kafka 作为共识机制，Kafka 是一个分布式流处理平台，通过分区和复制提供高可用性和容错能力。然而，Kafka 在 Hyperledger Fabric 2.0 版本之后不再推荐，Raft 成为默认选择。</li></ul><ol><li><strong>Byzantine Fault Tolerance (BFT)</strong></li></ol><ul><li><strong>SBFT (Simplified Byzantine Fault Tolerance):</strong> Fabric 未来计划支持更高级的 BFT 共识机制，如 SBFT，以应对恶意节点的存在，提高系统的安全性和可靠性。</li></ul><h4 id="数据上链过程"><a href="#数据上链过程" class="headerlink" title="数据上链过程"></a>数据上链过程</h4><p>Hyperledger Fabric 采用了一种独特的“交易排序 - 并行执行 - 交易验证”的架构，将数据上链过程分为以下几个步骤：</p><ol><li><strong>提交交易提案 (Transaction Proposal)</strong></li></ol><ul><li><strong>客户端应用提交提案：</strong> 客户端应用程序（例如学生提交成绩更新请求）通过 Fabric SDK 向一个或多个背书节点（Peer Nodes）提交交易提案。</li><li><strong>签名交易提案：</strong> 每个背书节点接收交易提案，执行链码（智能合约）逻辑，生成交易响应，并对响应进行签名。</li></ul><ol><li><strong>背书交易 (Endorsement)</strong></li></ol><ul><li><strong>收集背书：</strong> 客户端应用程序收集足够数量的背书节点的签名（根据通道配置中的背书策略），将交易提案和背书签名打包成一个交易。</li></ul><ol><li><strong>交易排序 (Ordering)</strong></li></ol><ul><li><strong>提交交易到排序服务：</strong> 客户端将打包好的交易发送到排序服务（Orderer Nodes）。排序服务负责将所有提交的交易进行排序，并生成区块。</li><li><strong>生成区块：</strong> 排序服务将</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BFS 算法</title>
    <link href="/2024/05/05/BFS/"/>
    <url>/2024/05/05/BFS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h1><p>BFS(Breadth First Search): 广度优先算法。<br>在笔试中很常考的一个算法，适用于寻找最短路径的。  </p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>把一些问题抽象成图，从一个点开始向四周扩散。与DFS不同的是：<strong>找到的最短路径一定是最短的</strong>。<br>我们在处理这类问题时最常用的是<strong>队列</strong>这个数据结构</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StringAlgorithm</title>
    <link href="/2024/05/05/StringAlgorithm/"/>
    <url>/2024/05/05/StringAlgorithm/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>myRPC</title>
    <link href="/2024/04/11/myRPC/"/>
    <url>/2024/04/11/myRPC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="myRPC"><a href="#myRPC" class="headerlink" title="myRPC"></a>myRPC</h1><h2 id="框架及实现思路"><a href="#框架及实现思路" class="headerlink" title="框架及实现思路"></a>框架及实现思路</h2><p><a href="https://article-images.zsxq.com/FtUDqWGvAhCfNH4toi5kbgx9fWgC">text</a>  </p><ul><li>如果消费者想要调用提供者，需要<strong>提供者</strong>启动一个<strong>web服务</strong> 然后通过请求客户端发送HTTP请求来调用  </li><li>因为provider提供多个服务和方法，消费者为了更方便调用而不是为每个方法都写一个HTTP调用逻辑，所以要实现一个<strong>请求处理器</strong> 来进行统一调用。</li><li>在provider维护一个<strong>本地服务注册器</strong>来记录服务和对应实现类的映射。  </li><li>注册中心：为了保存服务提供者的地址来方便消费者调用，常用第三方中心，如redis </li><li>负载均衡：</li><li>容错机制</li><li>SPI</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块化，包括：</p><ul><li>common：公共模块：包括公共依赖，接口，model</li><li>consumer：消费者</li><li>provider：提供者模块</li><li>框架模块<h3 id="common："><a href="#common：" class="headerlink" title="common："></a>common：</h3>用于编写和服务相关的接口和数据模型</li></ul><h3 id="请求处理器"><a href="#请求处理器" class="headerlink" title="请求处理器"></a>请求处理器</h3><p>用于provider处理调用，并根据请求参数找到对应的服务和方法，通过反射实现调用，最后封装返回结果并响应需求  </p><ul><li>RpcRequest类： 封装所需要的信息，如服务名称、方法名称、参数的类型列表、参数列表。用于Java反射机制。</li><li>RpcResponse 类：封装调用方法得到的返回值<h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4></li></ul><ol><li>反序列化请求为对象，并从请求对象中获取参数。</li><li>根据服务名称从本地注册器中获取到对应的服务实现类。</li><li>通过反射机制调用方法，得到返回结果。</li><li>对返回结果进行封装和序列化，并写入到响应中。</li></ol><h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><p>服务注册中心是 RPC 框架中不可或缺的重要模块：<br>1）服务提供者在启动时，会把自己能提供的服务信息（比如服务名称、地址、端口<br>等信息）提交到注册中心。<br>2） 服务消费者在调用服务时，会通过服务注册中心查询所需服务的地址和其他信息，从而完成调用。<br>3） 服务注册中心还会定期检查服务提供者的健康状态，如果发现某个服务提供者不可用，它会自动将其从服务列表中剔除。这保证了服务消费者总是调用到正常的服务<br>实例。</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h3><p>一个全异步Java服务器，底层使用Netty运行<br>是JVM上构建 <strong>响应式</strong> 应用的工具。 响应式应用既可以随着工作负载的增长而<strong>扩展</strong> ，又可以在出现故障时 <strong>弹性回复</strong> 。 响应式应用是 <strong>即时响应</strong> 的，因为它能有效利用系统资源并保护自身免受错误影响，从而使延迟可控。  </p><ol><li>Vertx基于事件循环机制。使用异步编程可以使用更少的线程处理更多的并发连接。  </li><li><h4 id="vertx-vs-tomcat"><a href="#vertx-vs-tomcat" class="headerlink" title="vertx vs tomcat"></a>vertx vs tomcat</h4></li></ol><ul><li>vertx时全异步服务器，tomcat可异步可同步</li><li>支持多个语言，不仅是java</li><li>vertx是全异步，所以io性能比较强。对异步传输数据的比例高的软件时很实用</li></ul><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ul><li>网络编程</li><li>内部类</li><li>lambda的好处</li><li>为什么用ConcurrentMap<h2 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h2><h3 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h3>因为对象存活在JVM的堆上，如果想要在其他位置或者网络中传输，需要序列化成可传输的字节数组。  <h3 id="想到的问题"><a href="#想到的问题" class="headerlink" title="想到的问题"></a>想到的问题</h3><h4 id="什么是堆什么是栈。生命周期"><a href="#什么是堆什么是栈。生命周期" class="headerlink" title="什么是堆什么是栈。生命周期"></a>什么是堆什么是栈。生命周期</h4><h4 id="范性"><a href="#范性" class="headerlink" title="范性"></a>范性</h4><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3></li></ul><h2 id="请求处理器-1"><a href="#请求处理器-1" class="headerlink" title="请求处理器"></a>请求处理器</h2><p>作用：处理接收到的请求，根据请求参数找到对应的服务和方法，通过反射实现调用，最后封装返回结果并响应请求  </p><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>允许程序在运行时，检查或修改器自身结构。 可以进行的操作及方法：  </p><ol><li>动态创建对象：反射机制可以在运行时创建任何类的对象，即使在编译时不知道具体类名。这是通过使用Class对象的newInstance()方法（或者通过构造器对象）实现的</li></ol><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><ol><li>反序列化请求为对象，并从请求对象中获取参数</li><li>根据名称从本地注册器中获取到对应的服务实现类</li><li>通过反射机制调用方法，得到返回结果</li><li>对返回结果进行封装和序列化，写入到响应</li></ol><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>静态代理灵活性差，需要为每个方法都写一个代理。所以使用动态代理。  </p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>教程(<a href="https://yuyuanweb.feishu.cn/wiki/VC1qwmX9diCBK3kidyec74vFnde">https://yuyuanweb.feishu.cn/wiki/VC1qwmX9diCBK3kidyec74vFnde</a>)</p><h2 id="高可用分布式注册中心"><a href="#高可用分布式注册中心" class="headerlink" title="高可用分布式注册中心"></a>高可用分布式注册中心</h2><h3 id="注册中心的能力"><a href="#注册中心的能力" class="headerlink" title="注册中心的能力"></a>注册中心的能力</h3><ul><li>数据分布式存储：及中的注册信息数据存储、读取和共享</li><li>服务注册：服务者上报服务信息</li><li>服务发现：消费者从注册中心拉去服务信息</li><li>心跳检测：检查服务提供者存货状态</li><li>服务注销：手动剔除结点</li></ul><h3 id="为什么选ETCD"><a href="#为什么选ETCD" class="headerlink" title="为什么选ETCD"></a>为什么选ETCD</h3><ol><li>是一个分布式的Key-Value存储系统，性能高，方便存储元信息。</li><li>通过采用Raft一致性算法来保证数据的一致性和可靠性，具有高可用性，强一致性、分布式特性</li><li>简单易用，提供了简单的API、数据的过期机制、监听和同志机制</li><li>入门成本低<h3 id="ETCD的特性"><a href="#ETCD的特性" class="headerlink" title="ETCD的特性"></a>ETCD的特性</h3></li><li>Lease：超时之后自动删除</li><li>Watch：监视特定key的变化，如果key的value发生变换就会触发通知<h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4>表层看：ETCD支持实务操作<br>底层看：采用了Raft一致性算法：具体来说，Raft 算法通过选举机制选举出一个领导者 (Leader)节点，领导者负责接收客户端的写请求，并将写操作复制到其他节点上。当客户端发送写请求时，领导者首先将写操作写入自己的日志中，并将写操作的日志条目分发给其他节点，其他节点收到日志后也将其马入自己的日志中。一旦 大多数节点（即半数以上的节点） 都将该日志条目成功写入到自己的日志中，该日志条目就被视为已提交，领导者会向客户端发送成功响应。在领导者发送成功响应后，该写操作就被视为已提交，从而保证了数据的一致性。  <h3 id="存储结构设计"><a href="#存储结构设计" class="headerlink" title="存储结构设计"></a>存储结构设计</h3><strong>层级结构</strong>：将服务理解为文件夹、将服务对应的多个节点理解为文件夹下的文件，那么可以通过服务名称，用前缀查询的方式查询到某个服务的所有节点。  </li><li>Key：/业务前缀/服务名/服务节点地址</li><li>Value</li><li>Key什么时候过期</li></ol><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><a href="https://bcdh.yuque.com/staff-wpxfif/resource/sak10cd1xd6wr925">https://bcdh.yuque.com/staff-wpxfif/resource/sak10cd1xd6wr925</a></p><h2 id="SPI-是什么"><a href="#SPI-是什么" class="headerlink" title="SPI 是什么"></a>SPI 是什么</h2><p>Service Provider Interface是Java 的重要机制，主要用于实现模块化开发和插件化扩展。<br>SPI机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过<strong>反射机制动态加载</strong>这些实现，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。  它有一点类似IoC思想，将装配的控制权移交给程序之外。<br>SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的方式。还有 Dubbo 框架提供同样的 SPI 扩展机制.</p><h3 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h3><p>当模块之间需要进行通信，我们在服务的调用方和提供者之间引入一个接口。  两个都是软件开发的接口，但是用途和目标群体不同。</p><ul><li>API: 当<strong>实现方提供了接口和实现</strong>，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力</li><li>SPI: 接口存在于调用方这边,接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。<h2 id="用到了哪些工厂模式"><a href="#用到了哪些工厂模式" class="headerlink" title="用到了哪些工厂模式"></a>用到了哪些工厂模式</h2>序列化器工厂、注册中心工厂、服务代理工厂、负载均衡器工厂</li></ul><h2 id="注解驱动的实现"><a href="#注解驱动的实现" class="headerlink" title="注解驱动的实现"></a>注解驱动的实现</h2><p>两种常用方法：</p><ol><li>主动扫描</li><li>监听Bean家在<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3>SpringBoot Starter   </li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 学习笔记</title>
    <link href="/2024/04/06/MySQLNotes/"/>
    <url>/2024/04/06/MySQLNotes/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>结构化查询语言，用于查询管理数据库；定义操和操作数据，维护数据的完整性和安全性</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>DDL(Data Definition Language),用于操作数据库、表、列，如：CREATE, ALTER, DROP</li><li>DML(Data Manipulation Language): 操作数据。如：INSERT,UPDATE,DELETE</li><li>DCL(Data Control Language): 操作访问权限和安全级别，如：GRANT, DENY</li><li>DQL(Data Query Language): SELECT</li></ol><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><ol><li>第一范式：每一列都是不可分割的基本苏局仙，每列的值都有原子性，不可再分割</li><li>第二范式</li><li>第三范式<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2>简单的三大类：  </li></ol><ul><li><p>数值：整形、浮点型、定点型</p></li><li><p>字符串：char, varchar</p></li><li>时间类型：YEAR, TIME, DATE, DATETIME</li><li></li></ul><h2 id="NULL-和’’-空字符串-的区别"><a href="#NULL-和’’-空字符串-的区别" class="headerlink" title="NULL 和’’(空字符串)的区别"></a>NULL 和’’(空字符串)的区别</h2><p>是完全不同的值。区别：</p><ol><li>NULL代表的是一个不确定的值，即使是两个NULL也不一定相等。</li><li>‘’的长度是0，不占用空间，而NULL是占空间的</li><li>NULL会影响聚合函数的结果：NULL 会影响聚合函数的结果。例如，SUM、AVG、MIN、MAX 等聚合函数会忽略 NULL 值。 COUNT 的处理方式取决于参数的类型。如果参数是 <em>(COUNT(</em>))，则会统计所有的记录数，包括 NULL 值；如果参数是某个字段名(COUNT(列名))，则会忽略 NULL 值，只统计非空值的个数。<h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="alt text"></li></ol><ul><li>连接器：身份认证和权限相关</li><li>查询缓存：</li><li>分析器：没有面中环</li><li>优化器：按照最优的方案进行</li><li>执行器</li><li>插件式引擎：负责数据的存储和读取，支持InnoDB、MyISAM、Memory等多种</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="数据库的基本操作"><a href="#数据库的基本操作" class="headerlink" title="数据库的基本操作"></a>数据库的基本操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create</span> database db1;  <span class="hljs-comment">--创建数据库db1</span><br><span class="hljs-keyword">show</span> database； <br><span class="hljs-keyword">drop</span> database db1; <span class="hljs-comment">--删除db</span><br><span class="hljs-keyword">select</span> database(); <span class="hljs-comment">--查询当前使用的databse</span><br></code></pre></td></tr></table></figure><p>有时候创建库时需要设置一些默认值，和大小写敏感<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `database`  <br>    <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;utf8&#x27;</span>  <br>    <span class="hljs-keyword">COLLATE</span> <span class="hljs-string">&#x27;utf8_general_ci &#x27;</span>;  <br></code></pre></td></tr></table></figure></p><h3 id="表的基本操作"><a href="#表的基本操作" class="headerlink" title="表的基本操作"></a>表的基本操作</h3><figure class="highlight plaintext"><figcaption><span>TABLE tb(</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CEATE">    id int,<br>    name varchar(20),<br>    gender varchar(10)<br>);<br></code></pre></td></tr></table></figure><h2 id="MySQL-存储索引"><a href="#MySQL-存储索引" class="headerlink" title="MySQL 存储索引"></a>MySQL 存储索引</h2><p>支持多种索引，包括InnoDB, MyISAM, Memory。 默认引擎是InnoDB并且只有InnoDB是事务性存储。  </p><h3 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h3><p>区别在：</p><ol><li>是否支持row-level locking：InnoDB支持。MyISAM只有table-level导致起在并发方面不够搞笑</li><li>是否支持事物：InnoDB实现了四个隔离级别：具有commit和rollback事物功能。InnoDB 默认使用的 <strong>REPEATABLE-READ（可重读）</strong>隔离级别是可以解决幻读问题发生的(基于 MVCC 和 Next-Key Lock)</li><li>是否支持外键：MySQL支持。但是性能有损耗，不建议使用。</li><li>是否支持异常崩溃后的安全恢复:InnoDB支持。数据库重新启动时会恢复到崩溃前状态。这个过程依赖于<code>redo log</code></li><li>是否支持MVCC:InnoDB可以</li><li>索引实现不同： 都是B+Tree索引结构，但是实现方式不同。<ol><li>InnDB本身就是索引文件。</li><li>MyISAM：索引文件和数据文件是分离的，数据文件本身就是按B+Tree组织的一个索引结构，曙节点data保存了完整的数据记录</li></ol></li><li>性能差别：InnoDB随着CPU核增加可以线性增长。</li></ol><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。<br><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong><br><img src="https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="alt text">  </p><h4 id="关系型数据库ACID特性"><a href="#关系型数据库ACID特性" class="headerlink" title="关系型数据库ACID特性"></a>关系型数据库ACID特性</h4><ul><li>A(atomicity) 原子性:事务是最小的执行单位，不允许分割，要么动作全部完成要么完全不起作用</li><li>C(Consistency):执行事务前后，数据保持一致。例如转账业务，无论是否成功，收款人和付款人的总额不变</li><li>I(Isolation):并发访问数据库时，一个用户的事物不被其他事物干扰</li><li>D(Durability):一个事务commit之后，对数据库中的数据改变是持久的，即使数据库发生了故障也不应该有影响<br>总的来说AID是手段，C是目的。<strong> 原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。</strong><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="脏读-Dirty-read"><a href="#脏读-Dirty-read" class="headerlink" title="脏读(Dirty read)"></a>脏读(Dirty read)</h4><img src="https://javaguide.cn/assets/concurrency-consistency-issues-dirty-reading-C1rL9lNt.png" alt="dirty read"><br>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。  </li></ul><h4 id="丢失修改-Lost-to-modify"><a href="#丢失修改-Lost-to-modify" class="headerlink" title="丢失修改(Lost to modify)"></a>丢失修改(Lost to modify)</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。<br>例子：假设有一个简单的银行账户数据库，其中包含一个账户余额字段。现在有两个事务同时运行，它们都试图更新同一个账户的余额。</p><p>事务 A 读取账户余额，读取到的值为 1000 元。<br>同时，事务 B 也读取了同一个账户的余额，读取的值同样为 1000 元。<br>事务 A 将余额更新为 1200 元，因为它向账户中添加了 200 元。<br>事务 B 不知道事务 A 的更新，它也试图更新余额，假设它想从账户中取出 500 元，所以它将余额更新为 500 元。<br>事务 B 的更新最终被提交到数据库，覆盖了事务 A 的更新  </p><p>最终，本应该余额是700但是由于B的覆盖变成了500.</p><h4 id="不可重复读-Unrepeatable-read"><a href="#不可重复读-Unrepeatable-read" class="headerlink" title="不可重复读(Unrepeatable read)"></a>不可重复读(Unrepeatable read)</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><h4 id="幻读-Phantom-read"><a href="#幻读-Phantom-read" class="headerlink" title="幻读(Phantom read)"></a>幻读(Phantom read)</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。<br><img src="https://javaguide.cn/assets/concurrency-consistency-issues-phantom-read-D-ETycCp.png" alt="alt text"></p><h3 id="并发事务的控制"><a href="#并发事务的控制" class="headerlink" title="并发事务的控制"></a>并发事务的控制</h3><p>两种方法：<strong>锁和MVCC</strong></p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>锁</strong>控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 读写锁 来实现并发控制</p><ul><li>共享锁（S锁）：读锁，允许多个事物同时获取，在事务读取记录的时候获取</li><li>排他锁（X锁）：写锁，不事务在修改记录的时候获取。不允许多个事务同时获取。如果一个记录被夹了排他锁，就不能再加入任何类型的锁<br>读写锁可以做到<strong>读读并行</strong>。<br>根据锁粒度不同，还可以分为table-level locking 和 row-level locking。  </li></ul><h4 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h4><p>即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的<br>主要依赖于以下手段实现：</p><ul><li>undo log：用于记录某行数据的多个版本数据</li><li>read view和隐藏字段：判断当前版本数据可见性<h3 id="MVCC-详解"><a href="#MVCC-详解" class="headerlink" title="MVCC 详解"></a>MVCC 详解</h3>用于多个并发事务同时读写数据库时保持数据的一致性和隔离性。<br>当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个<strong>数据快照</strong>，而不是直接修改实际的数据行。  </li></ul><ol><li>读(SELECT)<br>使用快找读区。基于事务开启时，数据库中的状态创建的。不会读取其他事务上为提交的修改</li><li>写(INSERT, UPDATE, DELETE)<br>执行写操作时，会生成新的数据版本，修改后写入数据库。<br>原始版本的数据仍然存在，以供其他事物使用快照读取。且新数据会带有当前事物的版本号</li><li>事务提交和回滚</li></ol><ul><li>提交时：所做修改会变成数据库的最新版本</li><li>回滚：修改被撤销，对其他事物不可见</li></ul><ol><li>版本回收<br>避免版本无线增长，会进行定期回收。</li></ol><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p>对于 一致性非锁定读（Consistent Nonlocking Reads）的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>四个隔离级别：</p><ul><li>READ-UNCOMMITTED：最低级别，允许读取上为提交的数据变更</li><li>READ-COMMITTED：允许读取并发事务已经提交的数据</li><li>REPEATABLE-READ：对同一个字段多次读取结果都是一致的，除非数据是被本身事务自己修改</li><li>SERIALIZABLE：最高级别，完全服从ACID，。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰。<br>InnoDB的默认级别时REPEATABLE-READ。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td>Yes</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td>Yes</td></tr><tr><td style="text-align:center">REPEATABLE-READ</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td>Yes</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td>No</td></tr></tbody></table></div><h2 id="InnoDB-的锁"><a href="#InnoDB-的锁" class="headerlink" title="InnoDB 的锁"></a>InnoDB 的锁</h2><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。</li><li>间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。</li><li>临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>h</p><ol><li>MySQL 有这一篇就够(<a href="https://blog.csdn.net/weixin_45851945/article/details/114287877">https://blog.csdn.net/weixin_45851945/article/details/114287877</a>)</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaGuide 学习记录</title>
    <link href="/2024/03/29/interview/"/>
    <url>/2024/03/29/interview/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简历项目"><a href="#简历项目" class="headerlink" title="简历项目"></a>简历项目</h1><h2 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h2><h3 id="如何保证Redis与数据库双写时数据一致"><a href="#如何保证Redis与数据库双写时数据一致" class="headerlink" title="如何保证Redis与数据库双写时数据一致"></a>如何保证Redis与数据库双写时数据一致</h3><ol><li>先更新缓存后更新数据库（不考虑）<br>一般不考虑，因为如果缓存更新成功，但是更新数据库出现异常，则导致缓存数据与数据库数据不一致切很难察觉，因为缓存中的数据一直存在。</li><li>先更新数据库后更新缓存<br>也不考虑，中间环节出现导致数据不一致，同1</li><li>先删除缓存后更新数据库<ul><li>可能会出现问题的原因： 同时来了请求A（更新操作）和请求B（查询操作）， A会先删除Redis的数据再更新db。此时B看到redis中数据是空的会到数据库查询该值，并补录到redis中。此时请求A没有更新成功或者事物还没有提交，请求B就去数据库查询得到旧值从而导致数据不一致。  </li><li>解决办法：<strong>延迟双删</strong><ul><li>先淘汰缓存</li><li>再写数据</li><li>休眠1秒(根据业务场景判断)，再次淘汰缓存，这样可以将1秒内产生的缓存脏数据删除</li></ul></li><li>为什么要两次删除？</li><li>第一次删除：并发环境下可能产生脏数据。<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">redis.delKey<span class="hljs-comment">(x)</span><br>db.update<span class="hljs-comment">(x)</span><br>Thread.sleep<span class="hljs-comment">(N)</span><br>redis.delKey<br></code></pre></td></tr></table></figure><h3 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h3></li></ul></li><li>Redis是一种基于键值对的NoSQL数据库，它支持多种数据结构: 字符串(String)、哈希(hashs)、列表(lists)、集合(sets)、有序集合(sorted sets)等</li><li>Redis将所有的数据都存在内存中，所以它的读写性能十分惊人。 </li><li>同时，Redis还可以将内存中的数据以快照或者日志的形式保存到硬盘上，以保证数据的安全性。 </li><li>缓存、排行榜(热⻔帖子)、计数器、社交网络(点赞数)、消息队列等。<h3 id="点赞的实现"><a href="#点赞的实现" class="headerlink" title="点赞的实现"></a>点赞的实现</h3>如何实现，为何避免某个用户重复点击？<br>因为是前后端分离，所以前端具有补可靠性<br>如果缓存已经失效了，为什么要从数据库中拉出来？<h3 id="讲一讲Kafka"><a href="#讲一讲Kafka" class="headerlink" title="讲一讲Kafka"></a>讲一讲Kafka</h3>消息队列看作是一个<strong>存放消息的容器</strong>，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种<strong>先进先出的数据结构</strong>，所以消费消息时也是按照顺序来消费的。<br>消息队列可以用来：<ol><li>通过一部处理提高系统性能</li><li>削峰、限流：先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</li><li>降低系统的耦合性<h3 id="如何使用Kafka做系统通知的"><a href="#如何使用Kafka做系统通知的" class="headerlink" title="如何使用Kafka做系统通知的"></a>如何使用Kafka做系统通知的</h3>触发事件之后，生产者生产消息，消费者间听到有消息之后，将消息队列中的实践Event去除，将其封装为msg对象并且持久话到数据库中保存。<br>事件包括：评论，点赞，关注</li></ol></li></ol><h4 id="同步异步的区别"><a href="#同步异步的区别" class="headerlink" title="同步异步的区别"></a>同步异步的区别</h4><p>同步与异步是指访问数据的机制</p><ul><li>同步： 主动请求并等待IO操作完成的方式<ul><li>缺点： 必须等待响应。如果出现请求阻塞或者网络延迟，就必须等待，导致体验差； 每次请求都要重新加载整个页面</li></ul></li><li>异步：主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知</li><li>例子：<ul><li>你去商城买东西，你看上了一款手机，能和店家说你一个这款手机，他就去仓库拿货，你得在店里等着，不能离开，这叫做<strong>同步</strong>。</li><li>现在你买手机去京东下单，下单完成后你就可用做其他时间（追剧、打王者、lol）等货到了去签收就ok了.这就叫异步。<h2 id="A2M"><a href="#A2M" class="headerlink" title="A2M"></a>A2M</h2><h3 id="为什么选择transformer，简单介绍下transformer"><a href="#为什么选择transformer，简单介绍下transformer" class="headerlink" title="为什么选择transformer，简单介绍下transformer"></a>为什么选择transformer，简单介绍下transformer</h3><h3 id="简单介绍一下BERT和GPT"><a href="#简单介绍一下BERT和GPT" class="headerlink" title="简单介绍一下BERT和GPT"></a>简单介绍一下BERT和GPT</h3><h3 id="什么叫mask"><a href="#什么叫mask" class="headerlink" title="什么叫mask"></a>什么叫mask</h3><h3 id="注意力机制是什么"><a href="#注意力机制是什么" class="headerlink" title="注意力机制是什么"></a>注意力机制是什么</h3><h3 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h3><h3 id="对句子的处理流程是什么"><a href="#对句子的处理流程是什么" class="headerlink" title="对句子的处理流程是什么"></a>对句子的处理流程是什么</h3><h3 id="encoder和decoder是什么"><a href="#encoder和decoder是什么" class="headerlink" title="encoder和decoder是什么"></a>encoder和decoder是什么</h3><h3 id="训练流程是什么"><a href="#训练流程是什么" class="headerlink" title="训练流程是什么"></a>训练流程是什么</h3><h3 id="如何处理的数据"><a href="#如何处理的数据" class="headerlink" title="如何处理的数据"></a>如何处理的数据</h3><h3 id="如何处理输入数据的"><a href="#如何处理输入数据的" class="headerlink" title="如何处理输入数据的"></a>如何处理输入数据的</h3><h3 id="如何验证这个项目，标准是什么"><a href="#如何验证这个项目，标准是什么" class="headerlink" title="如何验证这个项目，标准是什么"></a>如何验证这个项目，标准是什么</h3><h3 id="什么事BLEU"><a href="#什么事BLEU" class="headerlink" title="什么事BLEU"></a>什么事BLEU</h3><h3 id="输入输出是怎么处理的？"><a href="#输入输出是怎么处理的？" class="headerlink" title="输入输出是怎么处理的？"></a>输入输出是怎么处理的？</h3><h3 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h3><h3 id="为什么使用Flask"><a href="#为什么使用Flask" class="headerlink" title="为什么使用Flask"></a>为什么使用Flask</h3></li></ul></li></ul><h1 id="FTP-服务器"><a href="#FTP-服务器" class="headerlink" title="FTP 服务器"></a>FTP 服务器</h1><h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>设置基本的服务器配置，包括用户名、密码、操作权限（如删除、cd、mkdir、重命名）和限制速度。</p><h3 id="连接处理："><a href="#连接处理：" class="headerlink" title="连接处理："></a>连接处理：</h3><p>侦听并接受特定端口（标准 FTP 端口 21）上的传入连接。 它处理通过此连接发送的客户端命令。</p><h3 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h3><p>解析并响应来自客户端的FTP命令，如USER、PASS、SYST（系统类型）、PORT（主动模式设置）、PASV（被动模式设置）、PWD（当前目录）、MKD（make目录） 、CWD（更改目录）、DELE（删除文件）、LIST（列出目录中的文件）、RNFR/RNTO（重命名文件）、RETR（检索文件）、STOR（存储文件）和 QUIT。$$</p><h3 id="模式切换："><a href="#模式切换：" class="headerlink" title="模式切换："></a>模式切换：</h3><p>支持主动和被动模式之间的数据传输切换。</p><h3 id="实现基本的文件操作，例如列出目录、检索文件以及在服务器上存储文件。-这是通过根据主动或被动模式以不同方式管理数据套接字的函数来处理的。"><a href="#实现基本的文件操作，例如列出目录、检索文件以及在服务器上存储文件。-这是通过根据主动或被动模式以不同方式管理数据套接字的函数来处理的。" class="headerlink" title="实现基本的文件操作，例如列出目录、检索文件以及在服务器上存储文件。 这是通过根据主动或被动模式以不同方式管理数据套接字的函数来处理的。"></a>实现基本的文件操作，例如列出目录、检索文件以及在服务器上存储文件。 这是通过根据主动或被动模式以不同方式管理数据套接字的函数来处理的。</h3><h3 id="实用函数"><a href="#实用函数" class="headerlink" title="实用函数"></a>实用函数</h3><p>提供多种实用函数来支持主要服务器功能，包括速度限制（sleep_opr_for_speed）、权限转换（convert_str）以及被动（prepose_opr_pasv）和主动（prepose_opr_active）模式的初始设置。</p><h3 id="数据传输函数"><a href="#数据传输函数" class="headerlink" title="数据传输函数"></a>数据传输函数</h3><p>包含从客户端传输目录列表（tranfer_list）、检索文件（tranfer_retr）和存储文件（tranfer_stor）的实现。 这些函数处理主动和被动模式，管理文件描述符，并确保通过网络正确发送或接收数据。</p><h3 id="整体功能"><a href="#整体功能" class="headerlink" title="整体功能"></a>整体功能</h3><p>FTP 服务器能够处理基本的 FTP 操作，允许客户端连接、验证、导航目录结构以及执行文件操作（列表、检索、存储、删除等）。 它支持数据传输速率限制，并且可以在数据连接的主动和被动模式下运行。 服务器使用适当的 FTP 响应代码和消息来响应客户端命令。<br>代码结构是模块化的，server_main.c专注于命令接收和响应，server_sub.c提供数据传输和实用函数的支持。 这种分离有助于组织功能并使代码库更易于维护。</p><h2 id="围绕项目的问题"><a href="#围绕项目的问题" class="headerlink" title="围绕项目的问题"></a>围绕项目的问题</h2><h3 id="什么是FTP"><a href="#什么是FTP" class="headerlink" title="什么是FTP"></a>什么是FTP</h3><h3 id="主动模式和被动模式"><a href="#主动模式和被动模式" class="headerlink" title="主动模式和被动模式"></a>主动模式和被动模式</h3><h3 id="FTP的端口"><a href="#FTP的端口" class="headerlink" title="FTP的端口"></a>FTP的端口</h3><p>21</p><h3 id="ipv4和ipv6"><a href="#ipv4和ipv6" class="headerlink" title="ipv4和ipv6"></a>ipv4和ipv6</h3><p>除了更大的地址空间之外，IPv6 的优势还包括：无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。NAT（Network Address Translation，网络地址转换） 成为可选项：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。对标头结构进行了改进：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。可选的扩展头：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。ICMPv6（Internet Control Message Protocol for IPv6）：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。……</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol><li>进程和线程管理</li><li>存储管理</li><li>文件管理</li><li>设备管理</li><li>网络管理</li><li>安全管理<h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：<br><strong>用户态(User Mode) </strong>: 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。<br><strong>内核态(Kernel Mode)</strong>：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。<h3 id="如何从用户态切换到内核态"><a href="#如何从用户态切换到内核态" class="headerlink" title="如何从用户态切换到内核态"></a>如何从用户态切换到内核态</h3></li><li>系统调用：</li><li>中断</li><li>异常</li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h3><p>GET 和POST是HTTP的两种常用请求方法，在不同的场景和目的下有不同的特点和用法。  </p><ul><li>语义不同： GET常用语获取或查询资源，POST馋用于创建活着修改资源</li><li>格式不同</li><li>缓存上的区别</li><li>安全性的区别</li></ul><h3 id="Cookie-Session-Token"><a href="#Cookie-Session-Token" class="headerlink" title="Cookie, Session, Token"></a>Cookie, Session, Token</h3><p>Coocie和session都是用来跟踪浏览器用户身份的会话方式。  </p><ul><li><strong>Cookie用于保存用户信息。</strong> 例如：  </li></ul><ol><li>我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；</li><li>一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</li><li>登录一次网站后访问网站其他页面不需要重新登录。</li></ol><ul><li><strong>Session主要是通过服务端记录用户的状态</strong> 比如：典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 <strong>HTTP 协议是无状态</strong>的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</li><li>Cookie数据存在客户端，Session存在服务端</li><li>Session安全性更高。</li></ul><h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>TCP报文头长度：32</p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ol><li>客户端发送SYN（SEQ）标志数据包到服务端，此时客户端进入SYN_SEND状态</li><li>服务端发送SYN和ACK（SEQ=y，ACK=x+1）标志的数据包，客户端进入SYN_RECV状态</li><li>cline发送ACK（ACK+y+1），同时进入Established状态<h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4>建立可靠通信信道，确认双方的发送接收正常。</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>为了断开连接要进行四次挥手：  </p><ol><li>client 发送FIN(SEQ=x)，用来关闭客户端到服务器的传输(我发完了就不发了)。client进入FIN-WAIT-1状态</li><li>server收到FIN后，发送一个ACK，服务器进入CLOSE-WAIT状态，服务端进入FIN-WAIT-2状态（可能</li><li>server发送一个FIN(SEQ=y)请求关闭连接</li><li>客户端发送ACK(ACK=y+1)，client进入TIME-WAIT状态，server收到后进入CLOSE状态。client等待2MSL没有收到回复，就关闭连接<br>只要四次挥手没结束，就可以继续穿熟睡<h4 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h4>TCP是<strong>全双工通信</strong>，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</li></ol><h3 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h3><ol><li><p>基于报文块的传输。数据会被分成最适合发送的数据块进行传输。并且给每个包一个序列号，方便排序</p></li><li><p>校验和：在TCP的报文头中有一个校验和，目的是监测数据再传输过程中的变化，如果有差错将drop掉该报文段</p></li><li>重传机制：数据包丢失或者延迟的情况下会重新发送数据包直到收到对方的ACK。主要有：超时重传，快速重传，SACK，D-SACKdeng。</li><li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</li><li>拥塞控制： 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：<strong>一是接收方的接收能力，二是网络的拥塞程度</strong>。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是<strong>发送方根据网络状况自己维护的一个值</strong>，表示发送方认为可以在网络中传输的数据量。<strong>发送方发送数据的大小是滑动窗口和拥塞窗口的最小值</strong>，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li></ol><h3 id="如何进行流量控制"><a href="#如何进行流量控制" class="headerlink" title="如何进行流量控制"></a>如何进行流量控制</h3><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是Spring-什么是springboot"><a href="#什么是Spring-什么是springboot" class="headerlink" title="什么是Spring? 什么是springboot"></a>什么是Spring? 什么是springboot</h2><p> <strong>Spring 框架</strong>指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发<br> <strong>Spring boot</strong>： </p><h2 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h2><p>  <img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200831175708.png" alt="alt text"></p><ul><li><p>core container :最重要的</p><ul><li>spring-core：Spring 框架基本的核心工具类。</li><li>spring-beans：提供对 bean 的创建、配置和管理等功能的支持。</li><li>spring-context：提供对国际化、事件传播、资源加载等功能的支持。</li><li>spring-expression：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul></li><li><p>AOP</p></li><li>Data access/integration</li><li>web</li><li>massaging </li><li>test</li></ul><h2 id="IoC-Inversion-of-Control-控制反转"><a href="#IoC-Inversion-of-Control-控制反转" class="headerlink" title="IoC(Inversion of Control)控制反转"></a>IoC(Inversion of Control)控制反转</h2><p>面向对象的设计思想，实现方式<strong>依赖注入</strong>，实现依赖注入的关键是IoC container，本质上是工厂.</p><ul><li>依赖注入的方式有：构造方法注入、setter注入 、接口注入</li></ul><h2 id="AOP-Aspect-Oriented-Programming-面向切面编程"><a href="#AOP-Aspect-Oriented-Programming-面向切面编程" class="headerlink" title="AOP(Aspect-Oriented Programming) 面向切面编程"></a>AOP(Aspect-Oriented Programming) 面向切面编程</h2><p>AOP 为OOP的一种延续，二者互补  </p><ul><li>目的：将横切关注点业务逻辑中分离出来，通过动态代理、字节码等操作，实现代码的复用和解耦<h3 id="为什么叫面向切面变成"><a href="#为什么叫面向切面变成" class="headerlink" title="为什么叫面向切面变成"></a>为什么叫面向切面变成</h3>将关注点分离出来形成一个<strong>切面(Aspect)</strong>  </li><li>横切关注点：多个类或者对象中的公众行为：日志记录、事务管理、权限控制、接口限流、接口幂等</li><li>切面：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体功能。</li><li>连接点：方法调用或者方法执行时的某个特定时刻</li><li>通知：切面在某个连接点要进行的操作<ul><li>前置、后置、返回、异常通知和环绕通知</li></ul></li></ul><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring中的一个重要模块，用于快速架构web能力。其核心思想是通过将业务逻辑、数据、显示分离来组织代码。  </p><ul><li>Model:</li><li>view</li><li>controller<br>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。<h2 id="spring-MVC的核心组件"><a href="#spring-MVC的核心组件" class="headerlink" title="spring MVC的核心组件"></a>spring MVC的核心组件</h2></li><li>DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。</li><li>HandlerMapping：处理器映射器，根据 URL 去匹配查找能处理的 </li><li>Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>HandlerAdapter：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li>Handler：请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="Bean-是什么"><a href="#Bean-是什么" class="headerlink" title="Bean 是什么"></a>Bean 是什么</h3>代指那些被IoC容器管理的对象。可以通过配置元数据来定义（XML文件、注解或者Java配置类）<h3 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h3></li><li>@Autowired:属于内置注解，注入方式为：<strong>byType</strong>，会优先根据接口类型匹配并注入Bean。当一个接口存在多个实现类，则都需要适应名称来匹配。 支持构造函数、方法、字段和参数上使用</li><li><p>@Resource：属于JDK提供的注解，诸如方式是<strong>byName</strong></p></li><li><p>@Inject</p><h3 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h3><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3></li></ul><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>是一个模板引擎，生成动态HTML。</p><h3 id="什么是RESTful-java开发"><a href="#什么是RESTful-java开发" class="headerlink" title="什么是RESTful java开发"></a>什么是RESTful java开发</h3><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redisopen in new window （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在<strong>内存中的（内存数据库，支持持久化）</strong>，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h2 id="为什么redis快"><a href="#为什么redis快" class="headerlink" title="为什么redis快"></a>为什么redis快</h2><ul><li>基于内存的，访问速度比较快</li><li>基于reactor模式设计开发了一套高效的时间处理模型，主要是<strong>单线程</strong>事件循环和IO多路复用</li><li>内置了优化后的数据类型和结构</li></ul><h2 id="为什么要使用Redis"><a href="#为什么要使用Redis" class="headerlink" title="为什么要使用Redis"></a>为什么要使用Redis</h2><ol><li>高性能</li><li>高并发</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>5种基础数据类型：<ul><li>String</li><li>list</li><li>hash</li><li>set</li><li>zset(有序集和)</li></ul></li></ul><h1 id="Java-随记"><a href="#Java-随记" class="headerlink" title="Java 随记"></a>Java 随记</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。  </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">(parameters) -&gt; expression 或<br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p><strong>用于给方法传输动态参数</strong>  </p><ol><li>Runnable 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 内部类</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Runnable is using&quot;</span>);<br>  &#125;<br>&#125;).start();<br><br><span class="hljs-comment">//用lambda</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; System.out.println(<span class="hljs-string">&quot;Its a lambda&quot;</span>)).start();<br></code></pre></td></tr></table></figure></li><li>Comparator 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;Integer&gt; strings = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>Collections.sort(strings,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span>&#123;<br>    <span class="hljs-keyword">return</span> o1-o2;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">//Use lambda</span><br>Collections.sort(strings,(Integer o1, Integer o2) -&gt; o1 - o2);<br><br></code></pre></td></tr></table></figure></li><li>Listener 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>button.addItemListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">itemStateChanged</span><span class="hljs-params">(ItemEvent e)</span> &#123;<br>   e.getItem();<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda</span><br>button.addItemListener(e -&gt; e.getItem());<br>````<br></code></pre></td></tr></table></figure></li><li>自定义接口<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3></li><li>声称文档</li><li>编译时进行个时间差，如@Override</li><li>跟踪代码的依赖性，实现替代配置文件功能</li><li>反射的class，method，field中，有许多关于nnotation的借口，可以在反射中解析并使用annotation</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>自带的标准注解：<ol><li>@Override:如果药用它标记一个实际上没有override弗雷德方法是会报警</li><li>@Deprecated: 标记废弃过时的</li><li>@SuppressWarnings</li></ol></li><li>元注解:用于定义注解的注解<br>@Retention、@Target、@Inherited、@Documented、@Repeatable </li><li>自定义注解</li></ol><h3 id="注解扫描bean（springboot）"><a href="#注解扫描bean（springboot）" class="headerlink" title="注解扫描bean（springboot）"></a>注解扫描bean（springboot）</h3><p> Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解(annotation)的Bean.  </p><p> Spring提供如下几个Annotation来标注Spring Bean：</p><ul><li>@Component: 标注一个普通的Spring Bean类</li><li>@Controller: 标注一个控制层组件类</li><li>@Service: 标注一个业务逻辑层组件类</li><li>@Repository: 标注一个DAO层组件类</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h1 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h1><h1 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h1><h2 id="处女面：boss直聘-推荐系统工程师一面-40min-挂"><a href="#处女面：boss直聘-推荐系统工程师一面-40min-挂" class="headerlink" title="处女面：boss直聘-推荐系统工程师一面-40min-挂"></a>处女面：boss直聘-推荐系统工程师一面-40min-挂</h2><ol><li>自我介绍：感觉需要再优化一下，而不是只是把简历简单概括，没有提到简历上的亮点。不够好</li><li>写一个快排：设定一个pivot，然后将左右两边分别排好</li><li>Top K怎么实现：最小堆,创建一个大小为K的最小堆。</li><li>给一个100个数的链表，如何优化查询<br>面试官给的方式是创建多层索引，比如每隔10个数就抽一个构建一个新的链表为第二层，再从第二层抽取构建第三层，依次构建。  <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>挣扎了这么久终于有了一个面试，但是表现实在太糟糕了，发现了自己实在是不牢固。面试之前甚至对自己的简历都没法吃透，无论是数据结构、算法、数据库都感觉自己一片茫然。  </li></ol><h2 id="第四范式一面-40min"><a href="#第四范式一面-40min" class="headerlink" title="第四范式一面(40min)"></a>第四范式一面(40min)</h2><p>在牛客网面试，但是没有手写代码</p><ol><li>自我介绍.</li><li>我看你项目用到了MVC,讲一下MVC吧</li><li>讲一下single page吧</li><li>我看你用过Vue.js， 你是如何将Vue.js和Flaskd打包在一起的。Flask路由</li><li>讲讲你的Springboot的项目吧，你是如何实现注册页的</li><li>你用到了Mysql。讲一下MySQL中的锁吧</li><li>听说过MVCC吗，讲一下</li><li>Docker是如何封装的</li><li>Docker的底层逻辑是什么</li><li>docker的client和server的通信事如何痛心的</li><li>多线程之间是如何通信的</li><li>使用Java或者C是如何处理信号的</li><li>docker容器时使用什么技术进行资源管理的</li><li>你要部署pytorch的话，是以什么来导出模型的</li><li>如何将单机部署转化为公开部署，如何考虑安全性</li><li>有没考虑过你在实现你的页面的时候的安全性，如何做安全性。</li><li>如何实现高可用</li><li>讲一下负载均衡</li><li>如何做故障转移</li></ol><h2 id="小雨智造一面-1h"><a href="#小雨智造一面-1h" class="headerlink" title="小雨智造一面(1h)"></a>小雨智造一面(1h)</h2><ol><li>项目里面的技术是怎么学的</li><li>讲一下myRPC项目里有哪些模块，都是用来做什么的</li><li>你这项目是要部署在服务器上的，如果是部署在单机该怎么办？有哪些模块可以被优化</li><li>如果是进程之间的通信该有化掉哪些部分<br>回答了常用的进程通信方式。追问：你会如何实现？<br>如果是在不同的JVM之间该怎么通信<br>回答了会使用socket？用一个类似于识别码的东西来标准化通信。<br>为什么要标准化通信，如果不这样的话，会发生什么情况？<br>没答上来，结束</li><li>看你用了Vertx，为什么用了vertx？<br>异步。<br>那么tomcat是什么？</li></ol><p>在项目初期我是通过 vert.x 的HTTP服务器的功能来实现网络通信，因为官方文档首先演示了这个 Demd，比较方便。但后面我了解到 RPC 框架需要更高的性能，所以我叉基于 Vert.x 实现了 TCP 服务器，并且自主设计了协议消息结构，从而提高了 RPC 框架的网络通信效率。<br>我的项目选用 vert.x 实现 TCP 服务器，而不是 Netty 或直接用 Socket， 主要有几个方面原因：</p><ol><li>Vert.x 提供了高层次的抽象，相比 Netty 框架更简单易用。它不仅仅是一个网络框架，还是一个完整的异步编程框架，提供了包括 HTTP 服务器 / 客户端、WebSocket、事件总线、数据库访问、定时器等在内的多种构建高性能应用程序的工具和各种网络编程的 APl。<br>2.高性能。Vert.x 基于事件循环机制，采用单线程或少量线程处理大量并发连接，可以有效滅少线程上下文切换的开销，提高服务器的吞吐量和响应速度。更适合 RPC 框架这种需要处理大量 TCP 连接的应用场景。<br>3.对于 TCP 半包粘包的情况。Vert.x 提供了 RecordParser 类，能更方便地解决，不用自己去设计算法来处理。</li><li>你的论坛项目改进了什么？</li><li>讲一下锁的概念，如果要是不用常见的api，你该怎么实现</li><li>看你用了SPI，什么是SPI怎么实现的SPI</li><li>讲一下注解吧</li><li>假设java的包之间有互相的依赖，如何统计间接依赖。 写个代码吧</li></ol><h2 id="航旅纵横"><a href="#航旅纵横" class="headerlink" title="航旅纵横"></a>航旅纵横</h2><ol><li>Java 序列化时，不希望某些字段序列化，该使用什么<br>对于不想进行序列化的变量，可以使用 transient 关键字修饰。transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。关于 transient 还有几点注意：transient 只能修饰变量，不能修饰类和方法。transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ol><ol><li>实现多线程的方法有哪些</li><li>Redis怎么</li><li>RPC项目遇到了什么问题，怎么解决的</li><li>RPC项目参考了Dubble，讲一下dubble的运行流程<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1、服务容器负责启动，加载，运行服务提供者。  <br>2、服务提供者在启动时，向注册中心注册自己提供的服务。  <br>3、服务消费者在启动时，向注册中心订阅自己所需的服务。  <br>4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。  <br>5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。  <br>6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。  <br></code></pre></td></tr></table></figure></li><li>dubble是同步还是异步的</li><li>Linux常见的命令有哪些</li><li>mybatis相关</li><li>IoC 是什么</li><li>讲讲Bean的生命周期</li><li>常见的注解<br>@Controller(处理请求)<br>@Service（提供服务/业务）<br>@Repository(处理数据库)<br>@Conponent(通用)</li></ol><h2 id="光大"><a href="#光大" class="headerlink" title="光大"></a>光大</h2><ol><li>Transformer, BERT, GPT的区别</li></ol><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p><strong>Transformer</strong> 是一种用于自然语言处理（NLP）任务的深度学习模型架构，由Vaswani等人在2017年提出。Transformer的核心创新在于引入了<strong>注意力机制</strong>（Attention Mechanism），取代了传统的循环神经网络（RNN）和长短期记忆网络（LSTM），实现了更高效的并行处理。</p><ul><li><strong>架构</strong>：Transformer包括编码器（Encoder）和解码器（Decoder）两部分。编码器和解码器各由多个相同的层（Layer）堆叠而成，每一层包含多头自注意力机制（Multi-Head Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。</li><li><strong>自注意力机制</strong>：每个输入单词都可以关注序列中所有其他单词，计算这些单词之间的相关性。这种机制允许模型更好地捕捉全局上下文信息。</li><li><strong>多头注意力</strong>：通过多个独立的注意力头，模型可以从不同的子空间中学习信息。</li></ul><h3 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h3><p><strong>BERT</strong>（Bidirectional Encoder Representations from Transformers）是一种基于Transformer的预训练语言模型，由Google在2018年提出。BERT的核心在于双向性，即它在训练时同时考虑了左右两侧的上下文。</p><ul><li><strong>预训练与微调</strong>：BERT首先在大规模语料库上进行预训练，然后在具体任务上进行微调。预训练任务包括掩码语言模型（Masked Language Model, MLM）和下一个句子预测（Next Sentence Prediction, NSP）。</li><li><strong>架构</strong>：BERT只使用了Transformer的编码器部分。通过双向编码器，BERT在理解句子整体语义方面表现出色。</li><li><strong>应用</strong>：BERT在多个NLP任务上取得了显著的效果，如问答、文本分类和命名实体识别等。</li></ul><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><p><strong>GPT</strong>（Generative Pre-trained Transformer）是另一种基于Transformer的预训练语言模型，由OpenAI提出。与BERT不同，GPT主要关注生成任务。</p><ul><li><strong>单向性</strong>：GPT是单向模型，即在生成某个单词时只考虑该单词左侧的上下文。尽管如此，GPT在生成自然语言文本方面表现优异。</li><li><strong>架构</strong>：GPT主要使用了Transformer的解码器部分。通过自回归方式生成文本，每次生成一个单词并将其作为输入继续生成下一个单词。</li><li><strong>版本演进</strong>：OpenAI相继推出了GPT-2和GPT-3，模型规模和参数量显著增加，性能也大幅提升。GPT-3以其强大的生成能力广受关注。</li></ul><h3 id="Transformer-BERT-和-GPT-的关系"><a href="#Transformer-BERT-和-GPT-的关系" class="headerlink" title="Transformer, BERT 和 GPT 的关系"></a>Transformer, BERT 和 GPT 的关系</h3><ul><li><strong>共同点</strong>：Transformer、BERT和GPT都基于Transformer架构。Transformer是基础架构，提供了编码器和解码器的框架，BERT和GPT则是基于这一架构的具体实现。</li><li><strong>不同点</strong>：<ul><li><strong>架构部分</strong>：BERT使用了Transformer的编码器部分，GPT使用了Transformer的解码器部分。</li><li><strong>训练方式</strong>：BERT是双向模型，预训练任务包括MLM和NSP。GPT是单向模型，通过自回归方式生成文本。</li><li><strong>应用场景</strong>：BERT主要用于理解任务，如问答和文本分类；GPT主要用于生成任务，如文本生成和对话系统。</li></ul></li></ul><h3 id="图示总结"><a href="#图示总结" class="headerlink" title="图示总结"></a>图示总结</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>论坛项目笔记</title>
    <link href="/2024/03/29/community/"/>
    <url>/2024/03/29/community/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><h2 id="为什么要做这个项目？"><a href="#为什么要做这个项目？" class="headerlink" title="为什么要做这个项目？"></a>为什么要做这个项目？</h2><p>为了<del>学习新知识</del> 春招简历上太空了，又是NLP又是CV的。这个项目是个烂大街项目所以学起来资源多一些，而且能覆盖大部分的后端需要的东西。春招时间也不多，赶紧学赶紧面。<br>由于本人属于喜欢先学一学bg再开始进行项目顺便背八股文，所以会记录笔记，没准会单独成篇，之后再说。  </p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210520202315292.png" alt="alt text"><br>嗯，放眼望去好想没有什么东西是真的会的，看来都得重新学。  本着面向简历学习的思想，我们可以看出来主要功能有：  </p><ul><li>基于邮件激活的注册方式，登陆功能的随机验证码验证;</li><li>实现了登录状态检查、为游客和已登陆用 户展示不同的界面和功能</li><li>支持用户发布帖子、评论、发送站内信与过滤敏感词功能</li><li>实现了点赞，关注与系统通知功能。<br>东西真的不少，感觉全身心投入要学好久。但是，面向简历学习和面向八股学习应该就会简单很多吧。  <h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2></li><li>Spring Boot</li><li>Spring、Spring MVC、MyBatis</li><li>Redis、Kafka、Elasticsearch</li><li>Spring Security、Spring Actuator<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><strong>Maven</strong>：Maven 是 Apache 软件基金会的一个开源项目,是一个优秀的项目构建工具,它用来帮助开发者管理项目中的 jar,以及 jar 之间的依赖关系、完成项目的编译、测试、打包和发布等工作<br><strong>Spring initializer</strong> : 由于一个项目可能需要的包很多，挨个下会很麻烦，所以使用这个来搜索和下载和管理jar包。  直接进入网站(<a href="https://start.spring.io">https://start.spring.io</a>) 进行关键词搜索<br><strong>Spring Boot</strong>: 提供起步依赖、自动配置、端点监控</li></ul><h1 id="Spring-入门"><a href="#Spring-入门" class="headerlink" title="Spring 入门"></a>Spring 入门</h1><h2 id="spring全家桶"><a href="#spring全家桶" class="headerlink" title="spring全家桶"></a>spring全家桶</h2><ul><li>Spring Framework</li><li>Spring Boot</li><li>Spring cloud(为服务)</li><li>Spring cloud data flow<h3 id="课程记录"><a href="#课程记录" class="headerlink" title="课程记录"></a>课程记录</h3></li><li>Bean实例化是是单例实例化，可以通过加入<code>@Scope(&quot;prototype“)</code>可以让每次实例化是都重新创建<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2></li><li>@Repository<ul><li>如果同一个接口有不同的实现，可以使用 @Primary</li></ul></li><li>@Autowired 自动注解</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li>SqlSessionFactory: 用于创建工厂类</li><li>SqlSession：核心组件，用于向数据库执行SQL</li><li>主配置文件：XML</li><li>Mapper接口：DAO接口</li><li>Mapper映射器：用于编写SQL</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>system-design notes</title>
    <link href="/2023/12/17/system-design/"/>
    <url>/2023/12/17/system-design/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Notes for system design<br><span id="more"></span></p><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Notes for the rep <a href="https://github.com/ByteByteGoHq/system-design-101#communication-protocols">system-design-101</a>, which aiming at using visual and simple terms to explain complex systems</p><h1 id="Communication-protocols"><a href="#Communication-protocols" class="headerlink" title="Communication protocols"></a>Communication protocols</h1><h2 id="Most-used-Architecture-styles"><a href="#Most-used-Architecture-styles" class="headerlink" title="Most used Architecture styles"></a>Most used Architecture styles</h2><ul><li>SOAP<ul><li>for enterpriise applications</li></ul></li><li>RESTful<ul><li>This should be the most popular one, it is easy to implemented using HTTP methods.</li><li>for web services</li><li><strong>In many JD, it is one of important part</strong></li></ul></li><li>GraphQL<ul><li>Using query language, request specific data</li></ul></li><li>gRPC<ul><li>for microservices architectures</li></ul></li><li>WebSocket<ul><li>real time bidirectional, persistent connnections</li><li>perfect for low latency data exchange</li></ul></li><li>Webhook      <ul><li>notifies system when event occur</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Introduct to HTML and CSS</title>
    <link href="/2023/12/08/WebsiteBasis/"/>
    <url>/2023/12/08/WebsiteBasis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!--Introduce the basic concept of HTML and CSS--><h1 id="HTML-Overview"><a href="#HTML-Overview" class="headerlink" title="HTML Overview"></a>HTML Overview</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>HTML (Hypertext Markup Language) is the standard markup language for creating web pages and web applications. With Cascading Style Sheets (CSS) and JavaScript, it forms a triad of cornerstone technologies for the World Wide Web.</p><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><ul><li>HTML elements are the building blocks of HTML pages.</li><li>Elements are represented by tags like <code>&lt;html&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, etc.</li><li>Tags label pieces of content such as “heading”, “paragraph”, “table”, and so on.</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p>A basic HTML document structure includes:</p><ul><li><code>&lt;!DOCTYPE html&gt;</code>: Declaration to define the document type.</li><li><code>&lt;html&gt;</code>: Root element of an HTML page.</li><li><code>&lt;head&gt;</code>: Contains meta-information about the document.</li><li><code>&lt;title&gt;</code>: Specifies a title for the document.</li><li><code>&lt;body&gt;</code>: Contains the visible page content.</li><li><code>&lt;table&gt;</code>: Create a table for information. Inside it, we will use <code>&lt;th&gt;</code> stands for table head,<code>&lt;tr&gt;</code> for table row,<code>&lt;td&gt;</code> for table data, <code>&lt;caption&gt;</code> for table caption<h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Page Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is a Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100%&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>for exmaple<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Person 1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Person 2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Person 3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Emil<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Tobias<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Linus<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>$$<br></code></pre></td></tr></table></figure></li></ul><h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><h3 id="Headings"><a href="#Headings" class="headerlink" title="Headings"></a>Headings</h3><ul><li><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code> tags are used for defining headings.</li><li><code>&lt;h1&gt;</code> defines the most important heading.</li></ul><h3 id="Paragraphs"><a href="#Paragraphs" class="headerlink" title="Paragraphs"></a>Paragraphs</h3><ul><li><code>&lt;p&gt;</code> tag defines a paragraph.</li></ul><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><ul><li><code>&lt;a&gt;</code> tag defines a hyperlink.</li><li><code>href</code> attribute specifies the link’s destination.</li></ul><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com&quot;</span>&gt;</span>This is a link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><ul><li><code>&lt;img&gt;</code> tag is used to embed an image.</li><li><code>src</code> attribute specifies the path to the image.</li><li><code>alt</code> attribute provides alternative text.</li></ul><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My Image&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h2><p>Forms are defined with the <code>&lt;form&gt;</code> tag. They can contain input elements like text fields, checkboxes, radio-buttons, submit buttons, etc.</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/action_page.php&quot;</span>&gt;</span><br>  First name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mickey&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Last name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mouse&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><h2 id="CSS-Integration"><a href="#CSS-Integration" class="headerlink" title="CSS Integration"></a>CSS Integration</h2><p>CSS is used to control the style and layout of web pages.</p><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>: powderblue;&#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">h1</span>   &#123;<span class="hljs-attribute">color</span>: blue;&#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">p</span>    &#123;<span class="hljs-attribute">color</span>: red;&#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript-Integration"><a href="#JavaScript-Integration" class="headerlink" title="JavaScript Integration"></a>JavaScript Integration</h2><p>JavaScript can be integrated to add interactivity to web pages.</p><h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My First Web Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My First Paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>JavaScript in Body<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;My First JavaScript&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span> <br><br></code></pre></td></tr></table></figure><p>JS code is inserted between  <code>&lt;script&gt;</code> and <code>&lt;/script&gt;</code>. And this tag can be in <code>&lt;head&gt;</code> or <code>&lt;body&gt;</code>   </p><h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="Core-features"><a href="#Core-features" class="headerlink" title="Core features"></a>Core features</h3><ul><li>声名式渲染：可以声明式地描述最终输出的HTML和JS状态关系</li><li>响应性：vue会自动跟踪</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MIT-Missing-Semester</title>
    <link href="/2023/07/13/TheMissingClass/"/>
    <url>/2023/07/13/TheMissingClass/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The tools necessary<br><span id="more"></span></p><h1 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p> texual iterface to interact with machine. </p><ul><li>built-in function implemented by envy PATH</li><li>you can define the function in shell.  </li><li><code>echo $PATH</code> can show all path in machine. When type a name of program will walk through the path, search and match </li><li><code>which echo</code>: show its path  </li><li><code>pwd</code>: print working directory (absolute path) <ul><li>vs relative path</li></ul></li><li><code>cd</code>: change dir<ul><li><code>.</code>: current dir</li><li><code>..</code>: parent dir</li><li><code>~</code>: back to home dir</li><li><code>-</code>:<code>cd -</code> go back to previous dir</li></ul></li><li><p><code>ls</code>: list he files  </p><ul><li>can add some arguments or flags to show more details<ul><li><code>ls -l</code>: more info of files.</li><li>r, w, x: different for file and idr<br>for dir<ul><li>read: list the dir</li><li>write: rename, create, move or remove.</li><li>execute:a search, are you allowed to enter this dir.</li></ul></li></ul></li></ul></li><li><p><code>--help</code>: show more help on cmd, like <code>ls --help</code></p></li><li><code>mv</code>: rename the file. <ul><li>need two path: old path and new path</li></ul></li><li><code>cp</code>: copy a file<ul><li>two para: need to <strong>full path</strong> of old and direct</li></ul></li><li><code>rm</code>: remove file. <ul><li>cant use it to recursive delete a dir<ul><li>use <code>rm -r</code> to delete</li><li>or <code>rmdir</code>: remove <strong>empty</strong> dir</li></ul></li></ul></li><li><code>mkdir</code></li><li><code>man</code>: manual page</li></ul><h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><ul><li>Input stream: keyboard (default)</li><li>Output stream: print to terminal (default)</li><li><code>&gt; file</code>: direct the content to file<ul><li>`echo hello &gt; hello.txt</li></ul></li><li><code>&lt;</code></li><li><code>cat</code>: print the content in file<ul><li><code>cat &lt; hello.txt</code></li><li><code>cat &lt;hello.txt &gt; hello2.txt</code></li></ul></li><li><code>|</code>: pip, take the output of left as input of right side<ul><li><code>ls -l | tail -n1</code>:</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61aNotes</title>
    <link href="/2023/06/27/cs61aNotes/"/>
    <url>/2023/06/27/cs61aNotes/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h1><h2 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h2><p>when we try to implement a function, we need to find the common structure.  </p><h3 id="lambda-equation"><a href="#lambda-equation" class="headerlink" title="lambda equation"></a>lambda equation</h3><ul><li><code>square = lambda x: x * x</code> means for var x, return <code>x*x</code></li><li>the expression must be single</li><li>if wanna use <code>while</code> loop, then use def</li></ul><h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="Box-and-pointer-notation"><a href="#Box-and-pointer-notation" class="headerlink" title="Box-and pointer notation"></a>Box-and pointer notation</h2><ul><li>closure property of data type<ul><li>the result of combination can itself be combined using the same method</li><li>permits us to do hierarchical structure</li></ul></li></ul><h2 id="slicing"><a href="#slicing" class="headerlink" title="slicing"></a>slicing</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">odds = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>odds[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[3,5]</span><br></code></pre></td></tr></table></figure><p>so the slicing is from and include the <strong>start</strong> but end without <strong>end</strong></p><h2 id="sequence-aggregtion"><a href="#sequence-aggregtion" class="headerlink" title="sequence aggregtion"></a>sequence aggregtion</h2><ul><li><code>sum([2,3,4])</code><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] + [<span class="hljs-number">4</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>]],[<span class="hljs-number">1</span>])<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure></li><li><code>max(iterable[, key=func])</code><br><code>max(range(10), key=lambda x: 7-(x-4)*(x-2))</code> means in the function <code>7-(x-4)*(x-2))</code>, which number can make the function take max value</li></ul><h2 id="Tree-1"><a href="#Tree-1" class="headerlink" title="Tree"></a>Tree</h2><p>Implemmenting the Tree Abstraction<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree</span>(<span class="hljs-params">lable, branches=[]</span>):<br>    <span class="hljs-keyword">for</span> branch <span class="hljs-keyword">in</span> branches:<br>        <span class="hljs-keyword">assert</span> is_tree(branch)<br>    <span class="hljs-keyword">return</span> [label] + <span class="hljs-built_in">list</span>(branches)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">label</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">return</span> tree[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">branches</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">return</span> tree[<span class="hljs-number">1</span>:] <span class="hljs-comment"># mind here it is a slicing </span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_tree</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(tree) != <span class="hljs-built_in">list</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(tree) &lt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> branch <span class="hljs-keyword">in</span> branches(tree):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_tree(branch):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_leaf</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> branches(trees)<br></code></pre></td></tr></table></figure></p><ul><li>fib tree<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_tree</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> tree(n)<br>    <span class="hljs-keyword">else</span>:<br>        left, right = fib_tree(n-<span class="hljs-number">2</span>), fib_tree(n-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> tree(label(left)+label(right),[left,right])<br> <br><br></code></pre></td></tr></table></figure></li><li>increment tree<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_leaves</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return a tree like t but with leaf labels incremented &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> is_leaf(t):<br>        <span class="hljs-keyword">return</span> tree(label(t) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>: <br>        bs = [increment_leaves(b) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> braches(t)]<br>        <span class="hljs-keyword">return</span> tree(label(t),bs)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;return a tree like t but with all labels incremented&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> tree(label(t) + <span class="hljs-number">1</span>, [increment(b) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> braches(t)])<br></code></pre></td></tr></table></figure></li><li>print tree<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_tree</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-built_in">print</span>(label(t))<br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> branches(t):<br>        <span class="hljs-built_in">print</span>(b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_tree_struc</span>(<span class="hljs-params">t, indent=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;  &#x27;</span> * indent + <span class="hljs-built_in">str</span>(label(t)))<br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> branches(t):<br>        print_tree_struc(b, indent + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="Mutable-Sequence"><a href="#Mutable-Sequence" class="headerlink" title="Mutable Sequence"></a>Mutable Sequence</h1><h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2>object: value behave it should be represent<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">today = date(<span class="hljs-number">2023</span>,<span class="hljs-number">7</span>,<span class="hljs-number">21</span>) <br>today.year<br><span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure>object <strong>.</strong>  attribute or method   <h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2></li><li>immutable sequences</li><li>the value are protected from mutation</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">turtle = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>ooze()<br>turtle<br></code></pre></td></tr></table></figure><p>out: (1,2,3)</p><h3 id="Muatation"><a href="#Muatation" class="headerlink" title="Muatation"></a>Muatation</h3><p>Assignment changes variables, but mutation changes objects.<br>Objects that can be changed are called <strong>mutable</strong> and the act of changing one of these objects is a <strong>mutation</strong>.<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = x<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(x)<br><span class="hljs-number">4461801280</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(y)<br><span class="hljs-number">4461801280</span><br></code></pre></td></tr></table></figure><br>from this example, we can see <strong>x</strong> and <strong>y</strong> point to same obj<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>x.append(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>y<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><br>If want to judge whether they are same obj, use <code>a is b</code></p><h1 id="08-Recursion"><a href="#08-Recursion" class="headerlink" title="08 Recursion"></a>08 Recursion</h1><h2 id="Recursive-Functions"><a href="#Recursive-Functions" class="headerlink" title="Recursive Functions"></a>Recursive Functions</h2><ul><li>def: recursive function is that the body of function call itself, either directly or indirectly</li><li>recursion is a very elegant way of thinking about the nature of computation<h3 id="Anatomy"><a href="#Anatomy" class="headerlink" title="Anatomy"></a>Anatomy</h3></li></ul><ol><li>the def statement header </li><li>base case: those evluate without recursive calls</li><li>recursive case: need to be recalled recursively</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> n//<span class="hljs-number">10</span>, n%<span class="hljs-number">10</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_digits</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>: <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">return</span> n <br>    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># recursive case</span><br>        all_but_last, last = split(n)<br>        <span class="hljs-keyword">return</span> sum_digits(all_but_last) + last<br></code></pre></td></tr></table></figure><h2 id="order-of-recursive-calls"><a href="#order-of-recursive-calls" class="headerlink" title="order of recursive calls"></a>order of recursive calls</h2><p><strong>never using your mind to jump into recursion!!</strong><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cascade</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>        <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(n)<br>        cascade(n//<span class="hljs-number">10</span>)<br>        <span class="hljs-built_in">print</span>(n)<br><br></code></pre></td></tr></table></figure></p><h2 id="Tree-recursions"><a href="#Tree-recursions" class="headerlink" title="Tree recursions"></a>Tree recursions</h2><p>Fibonacci<br><img src="/img/fibonachi.png" alt="fib"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">2</span>) + fib(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>it need huge computation time if n is large, bcs there are many repetitive computes</p><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="Class-statement"><a href="#Class-statement" class="headerlink" title="Class statement"></a>Class statement</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> &lt;name&gt;:<br>    &lt;suite&gt;<br></code></pre></td></tr></table></figure><p>the suite is executed when the class statement is executed </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 39 | LC62. Unique Paths, 63. Unique Paths II</title>
    <link href="/2023/03/27/CarlDay39/"/>
    <url>/2023/03/27/CarlDay39/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC62. Unique Paths, 63. Unique Paths II<br><span id="more"></span></p><h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>It is one of my OJ in CISCO interview. It is not hard.</p><h1 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h1><ol><li>Determine the meaning of the dp array (dp table) and the subscript</li><li>Determine the recursive formula</li><li>try to initialize dp array</li><li>Determine traversal order</li><li>Example derivation dp array</li></ol><h1 id="LC62-Unique-Paths"><a href="#LC62-Unique-Paths" class="headerlink" title="LC62. Unique Paths"></a>LC62. Unique Paths</h1><p>In this question, it shows me the different way to initiate dp array.  </p><ol><li>the meaning of dp table: number of routes to (n,m)</li><li>formulat: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</li><li>every point at first row and colum is 1</li><li>post order<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br><br>        <span class="hljs-comment">//dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>                dp[i][j] =dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="LC63-Unique-Paths-II"><a href="#LC63-Unique-Paths-II" class="headerlink" title="LC63. Unique Paths II"></a>LC63. Unique Paths II</h1><p>This is the exact question I did in the OA<br><a href="https://leetcode.cn/problems/unique-paths-ii/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <br>        <span class="hljs-keyword">if</span>(obstacleGrid[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> || obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] != <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-comment">//when init array, we should identify when 1 appears in first row or col</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][i] != <span class="hljs-number">1</span>; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-comment">// System.out.println(&quot;i=&quot;+i);</span><br>                <span class="hljs-comment">// System.out.println(&quot;j=&quot;+j);</span><br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>)&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// System.out.println(dp[i][j]);</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br>For the initiate the </p><h2 id="OA"><a href="#OA" class="headerlink" title="OA"></a>OA</h2><p>A forklift worker moves products from one place to the other in an automotive parts warehouse. There a map in the dashboard that shows, in real time, the open and blocked sections inside the warehouse. The map is displayed as an n x m matrix of 1’s and 0’s which represent open and blocked sections respectively. A forklift driver always starts at the upper left corner of the map at warehouse[0][0] and tries to reach the bottom right section of the map or ware house[n-1][m-1]/ Each movement must be in increasing value along a row or column but not both. Given the warehouse map, determine the number of discinct path to get from warehouse[0][0] to warehouse[n-1][m-1]. The number maybe larger, so return the value module (10^9+7)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Warehouse</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfDistinctPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] warehouse)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> warehouse.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> warehouse[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// If the starting or ending point is blocked, return 0</span><br>        <span class="hljs-keyword">if</span> (warehouse[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || warehouse[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Initialize the first row and first column of the dp array</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (warehouse[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// we can add this part into &#x27;for&#x27;s condition&#x27;</span><br>                dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (warehouse[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Fill in the remaining dp array</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (warehouse[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = (dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 38 | LC509. Fibonacci Number, LC746. Min Cost Climbing Stairs, LC746. Min Cost Climbing Stairs</title>
    <link href="/2023/03/27/CarlDay38/"/>
    <url>/2023/03/27/CarlDay38/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Dynamic Programming Basic and LC509. Fibonacci Number, LC746. Min Cost Climbing Stairs, LC746. Min Cost Climbing Stairs<br><span id="more"></span></p><h1 id="Dynamic-Programming-Basic"><a href="#Dynamic-Programming-Basic" class="headerlink" title="Dynamic Programming Basic"></a>Dynamic Programming Basic</h1><ol><li>Determine the meaning of the dp array (dp table) and the subscript</li><li>Determine the recursive formula</li><li>try to initialize dp array</li><li>Determine traversal order</li><li>Example derivation dp array<h2 id="LC509-Fibonacci-Number"><a href="#LC509-Fibonacci-Number" class="headerlink" title="LC509. Fibonacci Number"></a>LC509. Fibonacci Number</h2><a href="https://leetcode.cn/problems/fibonacci-number/">Question</a><br>It is a very calssic problem in dp. Helpful to identify the process of dp   </li><li>identify the meaning of dp[i]: value of No. i fib</li><li>transfer function: dp[i] = dp[i - 1] + dp[i - 2]</li><li>initiate the base case: dp[0] = 0, dp[1] = 1</li><li>set the order of traverse: it is from the front to end  </li><li>examples for dp of array: it is for when the answer is wrong, we can print the DP array</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n )</span> &#123;<br>    <span class="hljs-type">int</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LC70-Climbing-Stairs"><a href="#LC70-Climbing-Stairs" class="headerlink" title="LC70. Climbing Stairs"></a>LC70. Climbing Stairs</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp(n);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n; <span class="hljs-comment">//base case</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<span class="hljs-comment">// transfer function</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LC746-Min-Cost-Climbing-Stairs"><a href="#LC746-Min-Cost-Climbing-Stairs" class="headerlink" title="LC746. Min Cost Climbing Stairs"></a>LC746. Min Cost Climbing Stairs</h2><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">Question</a><br>In this question, we have to<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-keyword">return</span> dp(cost);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> cost.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[l + <span class="hljs-number">1</span>];<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= l; i++) &#123;<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>            System.out.println(dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[l];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linkedarray &amp; Array algorithm</title>
    <link href="/2023/03/25/array/"/>
    <url>/2023/03/25/array/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Array and linkedarray method, mainly two pointer<br><span id="more"></span></p><h1 id="two-pointer"><a href="#two-pointer" class="headerlink" title="two-pointer"></a>two-pointer</h1><p>Two pointer is an efficient way to solve array, linkedarray, and String prolems. it can be divided into 4 ways</p><ol><li>Seperate pointers</li><li>slow-fast pointers</li><li>left-right pointers</li><li>sliding window<h2 id="Seperate-pointers"><a href="#Seperate-pointers" class="headerlink" title="Seperate pointers"></a>Seperate pointers</h2>Seperate-pointers is quite useful in split and merge arraylist.<br>Note: In linkedlist why may use the <strong>Dummy node</strong> as the start of.   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><h4 id="Merge-two-sorted-Lists"><a href="#Merge-two-sorted-Lists" class="headerlink" title="Merge two sorted Lists"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">Merge two sorted Lists</a></h4></li></ol><p>It is an easy question but many details in it. In this question, we use a <em>dummy</em> node as start and a <em>p</em> pointer to control. Use <em>p1</em> and <em>p2</em> to control<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>        ListNode p1, p2;<br>        p1 = list1;<br>        p2 = list2;<br>        <span class="hljs-comment">// the main judge of the value, the smaller one will be attack to the *p.next*</span><br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span> &amp;&amp; p2 != <span class="hljs-literal">null</span>)&#123;<br>             <span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;<br>                p.next = p2;<br>                p2 = p2.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p.next = p1;<br>                p1 = p1.next;<br>            &#125;<br><br>            p = p.next; <span class="hljs-comment">// keep moving the p pointer </span><br><br>        &#125;<br>        <span class="hljs-comment">// when one list comes to end, we should attach the rest of other list to the new list</span><br>        <span class="hljs-keyword">if</span>(p1 != <span class="hljs-literal">null</span>)&#123;<br>            p.next = p1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p2 != <span class="hljs-literal">null</span>)&#123;<br>            p.next = p2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h4 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><a href="https://leetcode.cn/problems/partition-list/">Partition List</a></h4><p><code>&#39;Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.</code></p><p>Same as <strong>Merge to sorted list</strong>, we can use the dummy node to solve this. It is not difficult to come up with: </p><ol><li>initialize two dummy nodes</li><li>initialize a pointer to iterate the list. Compare the size relationship between the node and the given value, and add it to two new linked lists respectively.</li><li>Break the connections in origin list, and move pointer to next node.</li><li>Merge two list.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), d1 = dummy1;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), d2 = dummy2;<br>       <br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br><br>       <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(p.val &lt; x)&#123;<br>               d1.next = p;<br>               d1 = d1.next;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               d2.next = p;<br>               d2 = d2.next;<br>           &#125;<br>           <span class="hljs-comment">//  p = p.next; cant use this to let p move forward, otherwise there will be a circle here</span><br><br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> p.next;<br>           p.next = <span class="hljs-literal">null</span>;<br>           p = tmp;<br>           <span class="hljs-comment">// 如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。</span><br>       &#125;<br>       d1.next = dummy2.next;<br>       <span class="hljs-keyword">return</span> dummy1.next;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="Slow-Fast-pointers"><a href="#Slow-Fast-pointers" class="headerlink" title="Slow - Fast pointers"></a>Slow - Fast pointers</h2><p>the slow - fast pointer is useful in indetifying cycles in linkedlist and the N th node from end of list.   </p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List</a></h4><ol><li>Initialize a dummy node</li><li>Find the last <strong>N+1</strong> node: the fast pointer move forward N steps, then slow pointer start.</li><li>delete the node : <code>x.next = x.next.next</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> findFromEnd(dummy, n + <span class="hljs-number">1</span>);<br>    x.next = x.next.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br>ListNode <span class="hljs-title function_">findFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 moves k steps</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">// p1 and p2 move n-k steps</span><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-comment">// p2 point at n - k + 1, which is last N</span><br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">Middle of the Linked List</a></h4><p>initialize two pointers, the fast pointer move 2 steps in one round, slow one moves 1 step in one round.<br><strong>End case</strong>: <code>fast == null &amp;&amp; fast.next == null</code>,which indentify odd and even number of nodes.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//fast != null is for the situation that the list has even number of nodes, fast.next != null is for the odd situation</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">Linked List Cycle II</a></h4><p>This is the most insteresting one for me in these questions.  </p><ol><li>How to detect a cycle? Fast pointer move 2 steps, and slow pointer move 1 step. if fast meet the end, then no cycle. </li><li>if Slow meet Fast, then there is a cycle</li><li>let slow one back to start of list, then move slow and fast mvoe together in 1 step.</li><li>when they meet again, then it is the start of cycle.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       ListNode fast, slow;<br>       fast = head;<br>       slow = head;<br><br>       <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>           fast = fast.next.next;<br>           slow = slow.next;<br><br>           <span class="hljs-keyword">if</span>(slow == fast)&#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       slow = head;<br>       <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>           fast = fast.next;<br>           slow = slow.next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> slow;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="./img/haveCycle.jpeg" alt="haveCycle"></p><h2 id="left-and-right-two-pointer"><a href="#left-and-right-two-pointer" class="headerlink" title="left and right two-pointer"></a>left and right two-pointer</h2><p>The most common example of left and right pointers is <strong>binary search algorithm</strong><br>For a binary search, we need some conditions:</p><ol><li>the array or linkedarray should be in order</li><li>what we are looking for is single instead of multiple </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = num.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            right = mid -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><h4 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm, Binary search, two-pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network Theory Lecture Notes Lec 7 8 9</title>
    <link href="/2023/03/22/NetworkTheory789/"/>
    <url>/2023/03/22/NetworkTheory789/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lecture-7-Introduction-to-Network-Optimisation"><a href="#Lecture-7-Introduction-to-Network-Optimisation" class="headerlink" title="Lecture 7: Introduction to Network Optimisation"></a>Lecture 7: Introduction to Network Optimisation</h1><h2 id="What-is-Optimisation"><a href="#What-is-Optimisation" class="headerlink" title="What is Optimisation"></a>What is Optimisation</h2><ul><li>def: select the best element from a set of alternatives</li></ul><h3 id="When-the-function-is-complex"><a href="#When-the-function-is-complex" class="headerlink" title="When the function is complex"></a>When the function is complex</h3><ul><li>by constrained optimisation<ul><li>on the input</li><li>output</li><li>input and output</li></ul></li></ul><h2 id="network-optimisation"><a href="#network-optimisation" class="headerlink" title="network optimisation"></a>network optimisation</h2><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><ul><li>to avoid the congestion and thus latency, jitter and packet loss in network</li></ul><h3 id="what-to-we-need-to-know"><a href="#what-to-we-need-to-know" class="headerlink" title="what to we need to know?"></a>what to we need to know?</h3><ul><li>traffic demand</li><li>capabilities of each node</li><li><p>capabilities of each link</p></li><li><p>Goal: to ensure, with the given set of constraints, an optimal network design with<strong> lowest cost structure</strong> and <strong>best performance</strong></p></li></ul><h2 id="KPIs"><a href="#KPIs" class="headerlink" title="KPIs"></a>KPIs</h2><ul><li>the target functions to optimise</li><li>performance<ul><li>Throughtput: effective speed (Mbps)</li><li>latency: delay from when a packet is sent to when it is received</li><li>jitter: variation of delays</li><li>paket loss</li><li>congestion</li></ul></li></ul><h2 id="Steps-of-network-optimisation"><a href="#Steps-of-network-optimisation" class="headerlink" title="Steps of network optimisation"></a>Steps of network optimisation</h2><ol><li>building a mathematical model<ul><li>linear, convex, concave model</li></ul></li><li>existence of optimao solution for the model<ul><li>fesaible solution: a vector x that satisfies all constrains</li><li>optimal solution: A feasible solution that gives the best value for objective function among all feasible solutions.</li></ul></li><li>characterisation of optimal solutions</li><li>algorithms for computing optimal solutions</li></ol><h3 id="Building-a-mathematical-model"><a href="#Building-a-mathematical-model" class="headerlink" title="Building a mathematical model"></a>Building a mathematical model</h3><ul><li>identifications:<ul><li>variables<ul><li>can use “Dummy” variable can make model more readable or to facilitate algorithmic solution</li></ul></li><li>object function</li><li>constrains<ul><li>Equality constraints (latency = 10ms) are too restrictive, better avoiding</li></ul></li></ul></li></ul><h4 id="how-to-build-model"><a href="#how-to-build-model" class="headerlink" title="how to build model"></a>how to build model</h4><ul><li>idendify all decision var<br>* </li><li>identify objective function<ul><li>Cost function or profit function</li></ul></li><li>identify all Constraints on Decision Variables</li></ul><h2 id="Minimum-cost-flow-problem"><a href="#Minimum-cost-flow-problem" class="headerlink" title="Minimum cost flow problem"></a>Minimum cost flow problem</h2><ul><li>aim:  finding the <strong>cheapest possible way</strong> of sending a certain amount of flow through a network.<ul><li>$x_{ij} =$amount transferred on edge (i,j)</li><li>$u_{ij} =$  capacity of edge</li><li>$c_{ij} =$ unit cost of shipping flow from node i to node j on (i,j) </li><li>$b_i =$ flow to be transmitted over the network<script type="math/tex; mode=display">minimise \sum_{(i,j)\in A}{c_{ij}x_{ij}}</script><script type="math/tex; mode=display">subject to \sum_j{x_{i,j}}-\sum_j{x_{j,i}} = b_i</script><img src="/img/MinimumCostFlowProblem.png" alt="Minimum Cost Flow Problem"></li></ul></li></ul><h1 id="Lecture-8-Solving-optimisation-problems"><a href="#Lecture-8-Solving-optimisation-problems" class="headerlink" title="Lecture 8: Solving optimisation problems"></a>Lecture 8: Solving optimisation problems</h1><h2 id="convex-optimisation-problems"><a href="#convex-optimisation-problems" class="headerlink" title="convex optimisation problems"></a>convex optimisation problems</h2><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><ul><li>Unconstrained problems: <ul><li>Newton’s method</li></ul></li><li>constrained problems:     <ul><li>Lagrangian dual problem</li><li>Penalty method<ul><li>Barrier method</li><li>logarithmic barrier</li></ul></li></ul></li></ul><h3 id="convexity"><a href="#convexity" class="headerlink" title="convexity"></a>convexity</h3><p>Use $H(x)$, Hessian(second grad) of $f(x)$, if $H(x)$ is positive semi definite for all x<br><strong>M</strong> is positive semi definite if $x^tMx\geq0$ for all $x\in R^n$</p><h2 id="Newton’s-method"><a href="#Newton’s-method" class="headerlink" title="Newton’s method"></a>Newton’s method</h2><p>it can only get local min instead of global</p><h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h3><ol><li>choose start point $x_0$</li><li>obtain better approximation<script type="math/tex; mode=display">x_1 = x_0-\frac{f(x_0)}{f'(x_0)}</script></li><li>The process is repeated until a more accurate<br>approximation is found</li></ol>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 32 | LC51</title>
    <link href="/2023/03/18/CarlDay32/"/>
    <url>/2023/03/18/CarlDay32/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LC122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#LC122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="LC122. Best Time to Buy and Sell Stock II"></a>LC122. Best Time to Buy and Sell Stock II</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">Question</a><br>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</p><p>Find and return the maximum profit you can achieve.<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Example</span> <span class="hljs-number">1</span>:<br><br><span class="hljs-attribute">Input</span>: prices =<span class="hljs-meta"> [7,1,5,3,6,4]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">7</span><br><span class="hljs-attribute">Explanation</span>: Buy <span class="hljs-literal">on</span> day <span class="hljs-number">2</span> (price = <span class="hljs-number">1</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">3</span> (price = <span class="hljs-number">5</span>), profit = <span class="hljs-number">5</span>-<span class="hljs-number">1</span> = <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Then</span> buy <span class="hljs-literal">on</span> day <span class="hljs-number">4</span> (price = <span class="hljs-number">3</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">5</span> (price = <span class="hljs-number">6</span>), profit = <span class="hljs-number">6</span>-<span class="hljs-number">3</span> = <span class="hljs-number">3</span>.<br><span class="hljs-attribute">Total</span> profit is <span class="hljs-number">4</span> + <span class="hljs-number">3</span> = <span class="hljs-number">7</span>.<br></code></pre></td></tr></table></figure><br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Example</span> <span class="hljs-number">2</span>:<br><br><span class="hljs-attribute">Input</span>: prices =<span class="hljs-meta"> [1,2,3,4,5]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">Explanation</span>: Buy <span class="hljs-literal">on</span> day <span class="hljs-number">1</span> (price = <span class="hljs-number">1</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">5</span> (price = <span class="hljs-number">5</span>), profit = <span class="hljs-number">5</span>-<span class="hljs-number">1</span> = <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Total</span> profit is <span class="hljs-number">4</span>.<br></code></pre></td></tr></table></figure><br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Example <span class="hljs-number">3</span>:<br><br><span class="hljs-symbol">Input:</span> prices = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br><span class="hljs-symbol">Output:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">Explanation:</span> There <span class="hljs-built_in">is</span> no way <span class="hljs-keyword">to</span> make a positive profit, so we never buy the stock <span class="hljs-keyword">to</span> achieve the maximum profit <span class="hljs-keyword">of</span> <span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>To solve this question, we only need to count the profit of everyday. As long as we only count the positive profits, then we can get the max.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;<br>            res += Math.max(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 31 | LC455. Assign Cookies, LC376. Wiggle Subsequence, LC53. Maximum Subarray</title>
    <link href="/2023/03/17/CarlDay31/"/>
    <url>/2023/03/17/CarlDay31/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><p>Greedy algodithm build up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit.<br>Key of greedy algorithm is <strong>select the local optimum at each stage to achieve the global optimum</strong><br>Here is an example :<br>There are some banknotes, and you can take ten of them. If you want to reach the maximum amount, how do you take them?<br>The solution is: every time you take the biggest one, the final result is to take the biggest amount of money.</p><h1 id="LC455-Assign-Cookies"><a href="#LC455-Assign-Cookies" class="headerlink" title="LC455. Assign Cookies"></a>LC455. Assign Cookies</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">Question</a><br>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.  </p><p>Example 1:<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: g =<span class="hljs-meta"> [1,2,3], s = [1,1]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">Explanation</span>: You have <span class="hljs-number">3</span> children and <span class="hljs-number">2</span> cookies. The greed factors of <span class="hljs-number">3</span> children are <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>. <br><span class="hljs-attribute">And</span> even though you have <span class="hljs-number">2</span> cookies, since their size is both <span class="hljs-number">1</span>, you could only make the child whose greed factor is <span class="hljs-number">1</span> content.<br><span class="hljs-attribute">You</span> need to output <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: g =<span class="hljs-meta"> [1,2], s = [1,2,3]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">Explanation</span>: You have <span class="hljs-number">2</span> children and <span class="hljs-number">3</span> cookies. The greed factors of <span class="hljs-number">2</span> children are <span class="hljs-number">1</span>, <span class="hljs-number">2</span>. <br><span class="hljs-attribute">You</span> have <span class="hljs-number">3</span> cookies and their sizes are big enough to gratify <span class="hljs-literal">all</span> of the children, <br><span class="hljs-attribute">You</span> need to output <span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>sort the array then use largest cookie to satisfy the child with largest greed factor.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findContentChildren</span><span class="hljs-params">(<span class="hljs-type">int</span>[] g, <span class="hljs-type">int</span>[] s)</span> &#123;<br>      Arrays.sort(g);<br>      Arrays.sort(s);<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++)&#123;<br>          <span class="hljs-keyword">if</span>(index &lt; g.length &amp;&amp; g[index] &lt;= s[i])&#123;<br>              index++;<br>          &#125;<br>      &#125;<br>    <br>    <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC376-Wiggle-Subsequence"><a href="#LC376-Wiggle-Subsequence" class="headerlink" title="LC376. Wiggle Subsequence"></a>LC376. Wiggle Subsequence</h1><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">Question</a>  </p><p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p><p>For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Example</span> <span class="hljs-number">1</span>:<br><br><span class="hljs-attribute">Input</span>: nums =<span class="hljs-meta"> [1,7,4,9,2,5]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">6</span><br><span class="hljs-attribute">Explanation</span>: The entire sequence is a wiggle sequence with differences (<span class="hljs-number">6</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">3</span>).<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Example <span class="hljs-number">2</span>:<br><br><span class="hljs-symbol">Input:</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>]<br><span class="hljs-symbol">Output:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">Explanation:</span> There are several subsequences that achieve this length.<br>One <span class="hljs-built_in">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">17</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>, <span class="hljs-number">8</span>] <span class="hljs-keyword">with</span> differences (<span class="hljs-number">16</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">8</span>).<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Example</span> <span class="hljs-number">3</span>:<br><br><span class="hljs-attribute">Input</span>: nums =<span class="hljs-meta"> [1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>      <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>          <span class="hljs-keyword">return</span> nums.length;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">curdiff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">prediff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>          curdiff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br><br>          <span class="hljs-keyword">if</span>((curdiff &lt; <span class="hljs-number">0</span> &amp;&amp; prediff &gt;= <span class="hljs-number">0</span>)||(curdiff &gt; <span class="hljs-number">0</span> &amp;&amp; prediff &lt;=<span class="hljs-number">0</span>))&#123;<br>              count++;<br>              prediff = curdiff;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC53-Maximum-Subarray"><a href="#LC53-Maximum-Subarray" class="headerlink" title="LC53. Maximum Subarray"></a>LC53. Maximum Subarray</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">Question</a><br>Given an integer array nums, find the subarray with the largest sum, and return its sum.</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Example 1:<br><br>Input: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>Output: 6<br>Explanation: The subarray [4,<span class="hljs-string">-1</span>,2,1] has the largest sum 6.<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Example 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">Input</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1]</span><br><span class="hljs-attribute">Output</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">Explanation</span><span class="hljs-punctuation">:</span> <span class="hljs-string">The subarray [1] has the largest sum 1.</span><br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Example 3</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">Input</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [5,4,-1,7,8]</span><br><span class="hljs-attribute">Output</span><span class="hljs-punctuation">:</span> <span class="hljs-string">23</span><br><span class="hljs-attribute">Explanation</span><span class="hljs-punctuation">:</span> <span class="hljs-string">The subarray [5,4,-1,7,8] has the largest sum 23.</span><br></code></pre></td></tr></table></figure><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>We can count the continuous sum, until it is negtive, becasue if a negtive plus others is definite smaller. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            count += nums[i];<br>            sum = Integer.max(count,sum);<br>            <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">0</span>)&#123;<br>                count = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 30 | LC51. N Queens</title>
    <link href="/2023/03/16/CarlDay30/"/>
    <url>/2023/03/16/CarlDay30/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>N-Queens<br><span id="more"></span></p><h1 id="LC51-N-Queens"><a href="#LC51-N-Queens" class="headerlink" title="LC51. N Queens"></a>LC51. N Queens</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/n-queens/">Question</a><br>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.  </p><p>Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.  </p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Input</span>: n = <span class="hljs-number">4</span><br><span class="hljs-symbol">Output</span>: [[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br></code></pre></td></tr></table></figure><br><img src="/img/NQueens.png" alt="NQueens"></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Clearly this is a difficult but a typical question of backtracking.  </p><h3 id="3-steps"><a href="#3-steps" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters:<ol><li><code>List&lt;String&gt; board</code>: we should initialze the board by the n</li><li>row</li></ol></li><li>end condition<ol><li><code>row == board.size()</code>: if row reach the last row, the end </li></ol></li><li>single layer<ol><li>function <code>isValid</code> to judge whether it is valid to place a queen here: inlcuding <strong>column</strong>, <strong>top right</strong>, <strong>top left</strong></li><li>set the queen</li></ol></li></ol><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// &#x27;.&#x27; means empty</span><br>        List&lt;String&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            board.add(sb.toString());<br>        &#125;<br>        backtrack(board, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == board.size()) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(board));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.get(row).length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br><br>            <span class="hljs-keyword">if</span> (!isValid(board, row, col)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">char</span>[] arr = board.get(row).toCharArray();<br>            arr[col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.set(row, String.valueOf(arr));<br><br>            backtrack(board, row + <span class="hljs-number">1</span>);<br><br>            arr[col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            board.set(row, String.valueOf(arr));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// check the validation of queens</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board.size();<br><br>        <span class="hljs-comment">// check column</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(col) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// check top right</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// check top left</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (board.get(i).charAt(j) == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BackTracking Algorithm</title>
    <link href="/2023/03/15/backtracking/"/>
    <url>/2023/03/15/backtracking/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Backtracking is an algorithmic technique where the goal is to get all solutions to a problem using the <strong>brute force approach</strong>.<br>It consists of building <strong>a set of all the solutions</strong> incrementally. Since a problem would <strong>have constraints</strong>, the solutions that <strong>fail to satisfy</strong> them will be <strong>removed</strong>.  </p><h2 id="Aimed-questions"><a href="#Aimed-questions" class="headerlink" title="Aimed questions"></a>Aimed questions</h2><p><img src="/img/backtrack.png" alt="backtrack"></p><h1 id="skeleton"><a href="#skeleton" class="headerlink" title="skeleton"></a>skeleton</h1><p>For a bracktrack problem ,we have to consider 3 conditions:  </p><ol><li>path: the dicisions have been made </li><li>choices list: what we can choose</li><li>end condition<br>Here is the skeloton of it in pseudocode</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">reslut = []<br><br>def backtrack(<span class="hljs-type">path</span>, choicesList)&#123;<br>    <span class="hljs-keyword">if</span>(satisfy <span class="hljs-keyword">end</span> condition)&#123;<br>        result.<span class="hljs-keyword">add</span>(<span class="hljs-type">path</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(choice : choicesList)&#123;<br>        choose process<br>        backtrack(<span class="hljs-type">path</span>, choicesList);<br>        recall choose process<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>it is hard to determine the parameters at first, we can set the logic first and fullfill the parameters when we need it.  </p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="Leetcode-Permutations-https-leetcode-cn-problems-permutations"><a href="#Leetcode-Permutations-https-leetcode-cn-problems-permutations" class="headerlink" title="Leetcode: Permutations(https://leetcode.cn/problems/permutations/)"></a>Leetcode: Permutations(<a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a>)</h3><ul><li><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.  </p></li><li><p>Example 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></li><li>Example 2:<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure></li><li>Example 3:<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// result </span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<span class="hljs-comment">// to identify whether it has been used, like in graph traversing, we need a identifier to avoid loop</span><br><br>        backtrack(nums, path, used);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, LinkedList&lt;Integer&gt; path, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, path, used); <span class="hljs-comment">// recursion, we need to make decision before recursion and withdraw decision after recursion. It means we do pre-order thing first then post-order</span><br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 29 | LC46. Permutations, LC47. Permutations II</title>
    <link href="/2023/03/15/CarlDay29/"/>
    <url>/2023/03/15/CarlDay29/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC46. Permutations, LC47. Permutations II<br><span id="more"></span></p><h1 id="LC46-Permutations"><a href="#LC46-Permutations" class="headerlink" title="LC46. Permutations"></a>LC46. Permutations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/permutations/">Question</a><br>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>the main difference between combiation and permutations is it  is should start from 0 instead of <code>start</code> .</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br><br>        backtrack(nums, path, used);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, LinkedList&lt;Integer&gt; path, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.addLast(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, path, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC47-Permutations-II"><a href="#LC47-Permutations-II" class="headerlink" title="LC47. Permutations II"></a>LC47. Permutations II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/permutations-ii/">Question</a><br>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,1,2]</span><br>Output:<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>In this question, it has dupicates, so we can use <code>nums[i] == nums[i-1]</code> to avoid it. However we have to ensure the input is in sorted.</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<span class="hljs-comment">// sort the input</span><br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        backtrack(nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">boolean</span>[] used)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<span class="hljs-comment">//nums[i] has been used</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            backtrack(nums, used);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 28 | LC78. Subsets, LC90. Subsets II, LC491. Non-decreasing Subsequences</title>
    <link href="/2023/03/14/CarlDay28/"/>
    <url>/2023/03/14/CarlDay28/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC78. Subsets, LC90. Subsets II, LC491. Non-decreasing Subsequences<br><span id="more"></span></p><h1 id="LC78-Subsets"><a href="#LC78-Subsets" class="headerlink" title="LC78. Subsets"></a>LC78. Subsets</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums of unique elements, return all possible subsets (the power set).  </p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,3]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>]<br>Output: <span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>This is a brand new kind of question. If the subset problem, combination problem, and segmentation problem are all abstracted into a <strong>tree</strong>, then the combination problem and the segmentation problem are to <strong>collect the leaf nodes</strong> of the tree, and the subset problem is to <strong>find all the nodes</strong> of the tree!</p><h3 id="3-steps"><a href="#3-steps" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters: <ol><li><code>int[] nums</code>: input</li><li>start: avoid duplicate</li></ol></li><li>end statements<ol><li><code>start == nums.length</code>: reach the end of tree</li><li>add every nodes!</li></ol></li><li><p>single layer </p><ol><li>add and withdraw</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <br>        backtrack(nums, <span class="hljs-number">0</span>, path);<br>        <br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, LinkedList path)</span>&#123;<br><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<span class="hljs-comment">// notice here , there is no if control as combination do, becasue we need to collect every nodes instead of leaves only</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>, path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC90-Subsets-II"><a href="#LC90-Subsets-II" class="headerlink" title="LC90. Subsets II"></a>LC90. Subsets II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>Given an integer array nums that may contain duplicates, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[1,2,2]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">0</span>]<br>Output: <span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ol><li>parameters: <ol><li><code>int[] nums</code>: input</li><li>start: avoid duplicate</li></ol></li><li>end statements<ol><li><code>start == nums.length</code>: reach the end of tree</li><li>add every nodes!</li></ol></li><li>single layer <ol><li>add and withdraw</li><li>judge same elements</li></ol></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        backtrack(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; start &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC491-Non-decreasing-Subsequences"><a href="#LC491-Non-decreasing-Subsequences" class="headerlink" title="LC491. Non-decreasing Subsequences"></a>LC491. Non-decreasing Subsequences</h1><p>Given an integer array <code>nums</code>, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.<br>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: nums = <span class="hljs-comment">[4,6,7,7]</span><br>Output: <span class="hljs-comment">[<span class="hljs-comment">[4,6]</span>,<span class="hljs-comment">[4,6,7]</span>,<span class="hljs-comment">[4,6,7,7]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[4,7,7]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[6,7,7]</span>,<span class="hljs-comment">[7,7]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: nums = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-string">[[4,4]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>it is quite like <a href="CarlDay27.md">LC40 CobinationII</a>.  To ensure the no decreasing property, we can use <code>getLast() &gt; nums[i]</code> to </p><h3 id="3-steps-1"><a href="#3-steps-1" class="headerlink" title="3 steps"></a>3 steps</h3><ol><li>parameters:<ol><li>nums</li><li>start</li></ol></li><li>end conditions<ol><li>the end arrary with at least 2 elements: <code>path.size()&gt;1</code></li></ol></li><li>single layer<ol><li>since we have to avoid duplicate, so we can use <code>HashSet</code> to avoid</li><li>judge the path is empty or not and the last element is larger than nums[i]</li></ol></li></ol><h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backtrack(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() &gt; <span class="hljs-number">1</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>        &#125;<br>        HashSet&lt;Integer&gt; used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!path.isEmpty() &amp;&amp; path.getLast() &gt; nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(used.contains(nums[i]))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            used.add(nums[i]);<br>            path.add(nums[i]);<br>            backtrack(nums, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 27 | LC39. Combination Sum, LC40. Combination Sum II, LC93. Restore IP Addresses</title>
    <link href="/2023/03/14/CarlDay27/"/>
    <url>/2023/03/14/CarlDay27/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC39. Combination Sum, LC40. Combination Sum II, LC93. Restore IP Addresses<br><span id="more"></span></p><h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum/">Question</a><br>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in <strong>any order</strong>.<br>The <strong>same</strong> number may be chosen from candidates an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.  </p><p>The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p><p>Example 1:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span><br>Output: <span class="hljs-string">[[2,2,3],[7]]</span><br></code></pre></td></tr></table></figure><p>Explanation:<br>2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.<br>7 is a candidate, and 7 = 7.<br>These are the only two combinations.<br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8  <br>Output: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> candidates = [<span class="hljs-number">2</span>], target = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">Output:</span> []<br></code></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is quite same as <a href="">LC216. Combination Sum III</a></p><h3 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>input</li><li>sum: sum of elements in path s</li><li>start</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>sum = target</li><li>if <code>candidate[i] + sum &gt; target</code>, then stop the for loop, but if we wanna do so, we need to sort the array</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<span class="hljs-comment">//very important</span><br>        backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates &amp;&amp;(sum + candidates[i] &lt;= target); i++)&#123;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br><br>            backtrack(candidates, target, sum, i);<br><br>            sum -= candidates[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="LC40-Combination-Sum-II"><a href="#LC40-Combination-Sum-II" class="headerlink" title="LC40. Combination Sum II"></a>LC40. Combination Sum II</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/">Question</a><br>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.  </p><p>Each number in candidates may only be used once in the combination.</p><p>Note: The solution set must not contain duplicate combinations.</p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8<br>Output: <br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,1,6]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,5]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[1,7]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[2,6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5<br>Output: <br><span class="hljs-comment">[</span><br><span class="hljs-comment"><span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment"><span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>The difference between this question and former question is that: <strong>Each number in candidates may only be used once in the combination.</strong><br>So we have to process the dupilcate </p><h3 id="3-Steps-1"><a href="#3-Steps-1" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>input</li><li>sum: sum of elements in path s</li><li>start</li><li>used:int[]. it is used to avoid duplicate</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>sum = target</li><li>if <code>candidate[i] + sum &gt; target</code>, then stop the for loop, but if we wanna do so, we need to sort the array</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>        Arrays.sort(candidates);<br>        Arrays.fill(used, <span class="hljs-literal">false</span>);<br>        backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>       <br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length ; i++)&#123;<br>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>              <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(candidates[i]);<br>            sum += candidates[i];<br><br>            backtrack(candidates, target, sum, i + <span class="hljs-number">1</span>);<br>            <br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="LC131-Palindrome-Partitioning"><a href="#LC131-Palindrome-Partitioning" class="headerlink" title="LC131. Palindrome Partitioning"></a>LC131. Palindrome Partitioning</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">Question</a><br>Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.<br>Example 1:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Input</span>: s = <span class="hljs-string">&quot;aab&quot;</span><br><span class="hljs-symbol">Output</span>: [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: s = <span class="hljs-string">&quot;a&quot;</span><br>Output: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure></p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><h3 id="3-Steps-2"><a href="#3-Steps-2" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>parameters:<ol><li>res</li><li>path</li><li>start : to avoid duplicate seletection</li></ol></li><li>end statements<ol><li><code>start == s.length()</code>: reach the end, means we have found the solution</li></ol></li><li>Single laler process<ol><li>judge whether it is a palindrome: use two-pointers to judge. If it is not, then jump it. </li><li>add result substring to <code>path</code></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>        backtrack(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == s.length())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!isPalindrome(s, start, i))&#123;<br>                <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// not a palindrome, can be splited</span><br>            &#125;<br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtrack(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span>&#123;<br>        <span class="hljs-keyword">while</span>(lo &lt; hi)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(lo) != s.charAt(hi))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            lo++;<br>            hi--;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC93-Restore-IP-Addresses"><a href="#LC93-Restore-IP-Addresses" class="headerlink" title="LC93. Restore IP Addresses"></a>LC93. Restore IP Addresses</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">Question</a><br>A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.  </p><p>Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in <strong>any</strong> order.<br>Example 1:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;25525511135&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br><br></code></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;0000&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;101023&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]<br></code></pre></td></tr></table></figure></p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>Like Palindrome Partitioning. The difference is the function <code>isValid</code> is used to judge whether the ip address is valid. And the tree has 4 layers.</p><h3 id="3-Steps-3"><a href="#3-Steps-3" class="headerlink" title="3 Steps"></a>3 Steps</h3><ol><li>parameters of <code>backtrack</code> function: <ol><li>String s</li><li>int start: void duplicate</li></ol></li><li>end statements:<ol><li>path.length &gt;= 4</li><li>the string is not valid</li></ol></li><li>single layer process:<ol><li>take a substring between <strong>start</strong> and <strong>i</strong></li><li>Judge valid:<ol><li>0 start</li><li>length not 1~3</li><li>lager than 255</li></ol></li></ol></li></ol><h3 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>      <br>        backtrack(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == s.length() &amp;&amp; path.size() == <span class="hljs-number">4</span>)&#123;<br>            res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(!isValid(s, start, i))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(path.size() &gt;= <span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtrack(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> end - start + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span> || length &gt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<span class="hljs-comment">//mind here, it should be a char 0 instead of int 0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(length &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Integer.parseInt(s.substring(start, start + length)) &gt; <span class="hljs-number">255</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 25 | LC216. Combination Sum III, LC17. Letter Combinations of a Phone Number</title>
    <link href="/2023/03/11/CarlDay25/"/>
    <url>/2023/03/11/CarlDay25/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC216. Combination Sum III, LC17. Letter Combinations of a Phone Number<br><span id="more"></span></p><h1 id="LC216-Combination-Sum-III"><a href="#LC216-Combination-Sum-III" class="headerlink" title="LC216. Combination Sum III"></a>LC216. Combination Sum III</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combination-sum-iii/">Question</a>  </p><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:  </p><ul><li>Only numbers 1 through 9 are used.</li><li>Each number is used at most once.  </li></ul><p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.  </p><p>Example 1:<br>    <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>Output: <span class="hljs-string">[[1,2,4]]</span><br></code></pre></td></tr></table></figure><br>    Explanation:<br>    1 + 2 + 4 = 7<br>    There are no other valid combinations.<br>Example 2:<br>    <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">9</span><br>Output: <span class="hljs-string">[[1,2,6],[1,3,5],[2,3,4]]</span><br></code></pre></td></tr></table></figure><br>    Explanation:<br>    1 + 2 + 6 = 9<br>    1 + 3 + 5 = 9<br>    2 + 3 + 4 = 9<br>    There are no other valid combinations.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>It is quite same as LC77. The differences are :</p><ol><li>The set size is constant: 9</li><li>end condition has two: <code>sum &gt; targertSum</code> or <code>k == path.size</code></li><li>Need to calculate sum when choosing and withdraw the decision of path</li></ol><h3 id="3-Steps"><a href="#3-Steps" class="headerlink" title="3 Steps:"></a>3 Steps:</h3><ol><li>identify the parameters of <code>backtrack</code><ul><li>targetSum: equals to n</li><li>k</li><li>sum: sum of elements in path s</li><li>start</li></ul></li><li>end statement<ul><li>sum &gt; targetSum</li><li>reach the end of tree</li></ul></li><li>Process in single layer, which is choose and withdraw path<ul><li>add element to path</li><li>use <em>sum</em> to calculate</li></ul></li></ol><p>So the solution is:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br><br>        backtrack(k, n, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span>&#123;<br>  <br>        <span class="hljs-keyword">if</span>(sum &gt; n)&#123;         <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(k == path.size())&#123;<br>            <span class="hljs-keyword">if</span> (sum == n)&#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(path));<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= <span class="hljs-number">9</span> - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            sum += i;<br>            path.add(i);<br>            backtrack(k, n, i + <span class="hljs-number">1</span>, sum);<br>            path.removeLast();<br>            sum -= i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC17-Letter-Combinations-of-a-Phone-Number"><a href="#LC17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="LC17. Letter Combinations of a Phone Number"></a>LC17. Letter Combinations of a Phone Number</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">Question</a><br>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.  </p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br>Example 1:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;23&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>Example 2:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">Output:</span> []<br></code></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> digits = <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure></p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><h3 id="3-step"><a href="#3-step" class="headerlink" title="3 step"></a>3 step</h3><ol><li>paramenters: <ol><li>digits</li><li>start: record which number has been recursive</li></ol></li><li>end statement<ol><li>if <code>start == digit.size</code>: means how many numbers needed</li></ol></li><li>single layer:<ol><li>target index to number and mapping it. </li><li>record the path</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[] mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>            <span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>            &#125;;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span>(digits.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        backtrack(digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> start, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() == digits.length()) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; digits.length(); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> digits.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : mapping[digit].toCharArray()) &#123;<br>                sb.append(c);<br>                backtrack(digits, i + <span class="hljs-number">1</span>, sb);<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 24 | LC77. Combinations</title>
    <link href="/2023/03/10/CarlDay24/"/>
    <url>/2023/03/10/CarlDay24/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Backtracking algorithm basic and LC77. Combinations<br><span id="more"></span></p><h1 id="Backtracking-algorithm-basic"><a href="#Backtracking-algorithm-basic" class="headerlink" title="Backtracking algorithm basic"></a>Backtracking algorithm basic</h1><p>see in <a href="backtracking.md">Backtrack algorithm</a></p><h1 id="LC77-Combinations"><a href="#LC77-Combinations" class="headerlink" title="LC77. Combinations"></a>LC77. Combinations</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://leetcode.cn/problems/combinations/">Question</a>  </p><p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].  </p><p>Example 1:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: n = 4, k = 2<br>Output: <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[3,4]</span>]</span><br></code></pre></td></tr></table></figure><br>Explanation: There are 4 choose 2 = 6 total combinations.<br>Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.<br>Example 2:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>Output: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><br>Explanation: There is 1 choose 1 = 1 total combination. </p><ul><li>Constraints:<br>1 &lt;= n &lt;= 20<br>1 &lt;= k &lt;= n  </li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>For a backtrack problem, we can consider it as a binary tree, then we can draw a map to illustrate the question<br><img src="/img/combinationeg.jpeg" alt="combination"><br>In this map we can know that <em>k</em> limits the depth of tree and <em>n</em> limits the broad of tree.<br>So for the <code>backtrack</code> function, the end condition is <strong>reach the depth of tree</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        backtrack(n, k, <span class="hljs-number">1</span>, track);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start, List&lt;Integer&gt; track)</span>&#123;<span class="hljs-comment">// the start is used to avoid dupicate</span><br>        <span class="hljs-keyword">if</span>(k == track.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; i++)&#123;<br>            track.add(i);<br>            backtrack(n, k, i + <span class="hljs-number">1</span>, track); <span class="hljs-comment">// notice here, the start is i + 1 instead of start + 1</span><br><br>            track.remove(track.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>For this quesiton, we can optimize it by <strong>pruning</strong>. Let’s see the previous image<br><img src="/img/combinationeg.jpeg" alt="combination"><br>we can notice that the selection for layer2 at 4, it is null, so it is useless, then we can modify it by adjusting <em>for loop</em>. Let’s analyze it </p><ol><li>elements already selected: <code>track.size()</code></li><li>elements needed: <code>k-track.size()</code></li><li>elements left in the list: <code>n - 1</code> &gt;= element needed <code>k-path.size()</code></li><li>In the set n at most from the starting position: <code>i &lt;= n - (k - path.size()) + 1</code>, start to recuisive  </li></ol><p>so we can change the <em>for loop</em> into<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; i++)&#123;<br>            path.add(i);<br>            combineHelper(n, k, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure><br>The final code is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>      List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <br>        backtrack(n, k, <span class="hljs-number">1</span>,track);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start, List&lt;Integer&gt; track)</span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(k == track.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(track));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - track.size()) + <span class="hljs-number">1</span>;i++)&#123;<br>            track.add(i);<br>            <br>            backtrack(n, k, i + <span class="hljs-number">1</span>, track); <span class="hljs-comment">// i + 1instead of </span><br>            <br>            track.remove(track.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 23 | LC538. Convert BST to Greater Tree</title>
    <link href="/2023/03/09/CarlDay23/"/>
    <url>/2023/03/09/CarlDay23/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC538. Convert BST to Greater Tree<br><span id="more"></span></p><h1 id="LC538-Convert-BST-to-Greater-Tree"><a href="#LC538-Convert-BST-to-Greater-Tree" class="headerlink" title="LC538. Convert BST to Greater Tree"></a>LC538. Convert BST to Greater Tree</h1><p>tranverse from right to left<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        traverse(root.right);<span class="hljs-comment">//since we need the sum of all keys greater than the original key in BST, so we traverse right node first then left</span><br>        sum += root.val;<br>        root.val = sum;<br>        traverse(root.left);<br><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 22 | LC701. Insert into a Binary Search Tree, LC450. Delete Node in a BST</title>
    <link href="/2023/03/08/CarlDay22/"/>
    <url>/2023/03/08/CarlDay22/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC701. Insert into a Binary Search Tree, LC450. Delete Node in a BST<br><span id="more"></span></p><h1 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a>701. Insert into a Binary Search Tree</h1><p>Inserting one value into BST is easym just compare it with root value, if larger then insert it in right, else insert it to left.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(val &gt; root.val)&#123;<br>          root.right = insertIntoBST(root.right, val); <span class="hljs-comment">//it must be root.right</span><br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; root.val)&#123;<br>          root.left = insertIntoBST(root.left, val);<br>      &#125;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a>450. Delete Node in a BST</h1><p>When ever we wanna delete or insert an element, we have to <strong>search it first</strong>, so the skeleton is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>    <span class="hljs-title function_">if</span><span class="hljs-params">(root.val == key)</span>&#123;<span class="hljs-comment">//found the node</span><br>        ···<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<span class="hljs-comment">//key smaller, search left subtree</span><br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<span class="hljs-comment">// key larger, search right subtree</span><br>            root.right = deleteNode(root.right, key);<br>    &#125;<br>        <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><br>Then, we have to identify the situations for delete ndoe.  </p><ol><li>it is the leef: just remove it</li><li>it only has left node: then let it be its left node</li><li>it only has right node: be right</li><li>it has left and right node, then we need to find the <strong>minimum</strong> in its left subtree to replace itselft to maintain the validation of BST. </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br><br>        <span class="hljs-keyword">if</span>(root.val == key)&#123;<br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span> &amp;&amp; root.right != <span class="hljs-literal">null</span>) &#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> getMin(root.right);<span class="hljs-comment">//find min of right</span><br>            <br>                root.val = minNode.val;<br>                <br>                root.right = deleteNode(root.right, minNode.val);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root.val &gt; key)&#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; key)&#123;<br>            root.right = deleteNode(root.right, key);<br>    &#125;<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>    TreeNode <span class="hljs-title function_">getMin</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">while</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            root = root.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 21 | LC530. Minimum Absolute Difference in BST, LC501. Find Mode in Binary Search Tree, LC236. Lowest Common Ancestor of a Binary Tree, 236. Lowest Common Ancestor of a Binary Tree</title>
    <link href="/2023/03/07/CarlDay21/"/>
    <url>/2023/03/07/CarlDay21/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC530. Minimum Absolute Difference in BST, LC501. Find Mode in Binary Search Tree, LC236. Lowest Common Ancestor of a Binary Tree, 236. Lowest Common Ancestor of a Binary Tree<br><span id="more"></span></p><h1 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a>530. Minimum Absolute Difference in BST</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">Question</a><br>For every BST question, we have to remember <strong>the inorder traverse of BST is a monotonically increase array</strong>. Using this character, we can solve many problems.<br>In this question, we can have study a new method: the <code>prev</code>node, using this can process the prev node so that we can process it with <code>cur</code> node.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// prev node </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        traverse(root.left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>)&#123;<br>            min = Math.min(min,root.val - pre.val);<br>        &#125;<br>        pre = root;<br>        traverse(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a>501. Find Mode in Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">Question</a><br>Same as before, <strong>inorder traverse + prev ndoe processing</strong>. Just we have to do some <code>if else</code> in the in-order traverse.   And one Key is <strong>when new mode happens, we have to clear the previouse result and add new mode</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// using for record previouse node </span><br>    ArrayList&lt;Integer&gt; mode= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">curCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) &#123;<br>        traverse(root);<br><br>        <span class="hljs-type">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mode.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; res.length; i++)&#123;<br>            res[i] = mode.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        traverse(root.left);<br>        <span class="hljs-keyword">if</span>(prev == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">// process the root ndoe</span><br>            curCount = <span class="hljs-number">1</span>;<br>            maxCount = <span class="hljs-number">1</span>;<br>            mode.add(root.val);<br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>            <span class="hljs-keyword">if</span>(root.val == prev.val)&#123;<span class="hljs-comment">//if value equivalent</span><br>                curCount ++;<br>                <span class="hljs-keyword">if</span>(curCount == maxCount)&#123;<br>                    mode.add(root.val);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curCount &gt; maxCount)&#123;<span class="hljs-comment">//new mode appears</span><br>                    mode.clear();<span class="hljs-comment">//clear the og array, because this is the new mode</span><br>                    maxCount = curCount;<br>                    mode.add(root.val);<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(root.val != prev.val)&#123;<span class="hljs-comment">//</span><br>                curCount = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(curCount == maxCount)&#123;<br>                    mode.add(root.val);<br>            &#125;<br>            &#125;<br><br>        &#125;        <br>        prev = root;<br>        traverse(root.right);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">Question</a><br>The LCA of two nodes is actually the intersection point of the “extension line” of the two nodes to the root node.<br>There are two common situation<br><img src="/img/LCA.jpeg" alt="LCA"><br>So <strong>if one node can find node p &amp; q in its left and right subtree, then it is LCA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(root, p ,q);<br>    &#125;<br><br>    TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(root == p || root == q)&#123; <span class="hljs-comment">// for the 2nd situation </span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> find(root.left,  p,  q);<br>        TreeNode right= find(root.right,  p,  q);<br><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">// for the 1st situation</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left != <span class="hljs-literal">null</span> ? left : right;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><code>return left != null ? left : right;</code> means if cant find the node in left subtree, then find the right subtree.<br><code>if(root == p || root == q)&#123; return root;&#125;</code>, why we can locate the root as LCA? Because <code>p</code> and <code>q</code> will exist in the tree.</p><h1 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">Question</a><br>Since it is a BST, we can use its propety: <strong>left node &gt; right node</strong>. If <code>root.val &gt; max</code>, then try to find it in left subtree, if <code>root.val &lt; min</code>, then find it in right subtree. It is not very hard to work out this, but we have to know how to implement it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Math.max(p.val, q.val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(p.val, q.val);<br><br>        <span class="hljs-keyword">return</span> find(root, min, max);<br>    &#125;<br><br>    TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span>(root.val &gt; max)&#123;<br>            <span class="hljs-keyword">return</span> find(root.left, min, max);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; min)&#123;<br>            <span class="hljs-keyword">return</span> find(root.right, min, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 20 | LC654. Maximum Binary Tree, LC617 Merge Two Binary Trees, LC700 Search in a Binary Search Tree, LC98 Validate Binary Search Tree</title>
    <link href="/2023/03/06/CarlDay20/"/>
    <url>/2023/03/06/CarlDay20/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC654. Maximum Binary Tree, LC617 Merge Two Binary Trees, LC700 Search in a Binary Search Tree, LC98 Validate Binary Search Tree<br><span id="more"></span></p><h1 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">Question</a><br>Same method as <a href="CarlDay18.md">106. Construct Binary Tree from Inorder and Postorder Traversal</a>. Find the max value, tag its location and split it into subtrees. Then construct them seperately by recursion.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxTag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; max)&#123;<br>                max = nums[i];<br>                maxTag = i;<span class="hljs-comment">//Find the location of max value</span><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(max);<br>        root.left = build(nums, start, maxTag - <span class="hljs-number">1</span>);<br>        root.right = build(nums, maxTag + <span class="hljs-number">1</span>, end);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">Question</a><br>These question has one same point is <strong>we need to focus on the meaning of funtion itself, which can save a lot of trouble</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br><br>        root1.val += root2.val;<br><br>        root1.left = mergeTrees(root1.left, root2.left);<br>        root1.right = mergeTrees(root1.right, root2.right);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a>700. Search in a Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">Question</a><br><img src="/img/bst.HEIC" alt="notes"><br>Welcome to BST. As the notes show the basic logic, we can searc the tree<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">if</span>(root.val &gt; val)&#123;<br>           <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(root.val &lt; val)&#123;<br>           <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>       &#125;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode max;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>        <span class="hljs-keyword">if</span> (!left) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (max != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= max.val) &#123;<span class="hljs-comment">//focus on this part bcs it make sure the validation of tree.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        max = root;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 18 | LC513 Find Bottom Left Tree Value, LC2 Path Sum, LC106 Construct Binary Tree from Inorder and Postorder Traversal</title>
    <link href="/2023/03/04/CarlDay18/"/>
    <url>/2023/03/04/CarlDay18/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC513 Find Bottom Left Tree Value, LC2 Path Sum, LC106 Construct Binary Tree from Inorder and Postorder Traversal<br><span id="more"></span></p><h1 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">Question</a><br>easy to solve by level traverse.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>      que.offer(root);<br><br>      <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>              <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> que.poll();<br>              <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                  res = cur.val;<br>              &#125;<br>              <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                  que.offer(cur.left);<br><br>              &#125;<br>              <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                  que.offer(cur.right);<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h1 id="2-Path-Sum"><a href="#2-Path-Sum" class="headerlink" title="2. Path Sum"></a>2. Path Sum</h1><p><a href="https://leetcode.cn/problems/path-sum/">Question</a><br>Easy question, just figure out the logic: ‘targetSum-root.val’ is next recursion’s input.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> targetSum == root.val;<br>       &#125;<br><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">leftPath</span> <span class="hljs-operator">=</span> hasPathSum(root.left,targetSum - root.val);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">rightPath</span> <span class="hljs-operator">=</span> hasPathSum(root.right, targetSum - root.val);<br>       <span class="hljs-keyword">return</span> (leftPath||rightPath);<br>   &#125;   <br></code></pre></td></tr></table></figure></p><h1 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h1><p><strong>The construction problem of binary tree generally uses the idea of “decomposition problem”: constructing the whole tree = root node + constructing left subtree + constructing right subtree.</strong><br>In post-order traverse, the last value is the root node. Then we can split the left subtree and right subtree by root. Then we can calculate the no nodes in left subtree and then recursive. The key in this question is <strong>how to identify the start and end in both postorder and inorder array to build subtrees</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br>     HashMap&lt;Integer, Integer&gt; inHash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> [] inorder, <span class="hljs-type">int</span>[] postorder)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            inHash.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd )</span>&#123;<br>         <span class="hljs-keyword">if</span>(inStart &gt; inEnd)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>         &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> postorder[postEnd];<span class="hljs-comment">//the root is the last node in postorder</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> inHash.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> index - inStart; <br><br>         <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>         root.left = build(inorder, inStart, index - <span class="hljs-number">1</span>, postorder, postStart, postStart + leftSize - <span class="hljs-number">1</span>);<br>         root.right = build(inorder, index + <span class="hljs-number">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class="hljs-number">1</span>);<span class="hljs-comment">//mind the end of postorder is og end-1 bcs it is used for root</span><br>         <span class="hljs-keyword">return</span> root;<br><br><br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Question</a>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;Integer, Integer&gt; inHash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-comment">//将中序遍历存入hashmap可以降低查找对应index的时间复杂度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;<br>            inHash.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> [] preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span> [] inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span>&#123;<br>        <span class="hljs-keyword">if</span>(inStart &gt; inEnd)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 为什么只考虑中序遍历的时候，不考虑前序</span><br>        <span class="hljs-type">int</span> rootVal= preorder[preStart];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> inHash.get(rootVal);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSieze</span> <span class="hljs-operator">=</span> index - inStart;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        <br>        root.left = build(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftSieze, inorder, inStart, index - <span class="hljs-number">1</span>);<br>        root.right = build(preorder, preStart + leftSieze + <span class="hljs-number">1</span>, preEnd, inorder,index+<span class="hljs-number">1</span>, inEnd);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 17 | LC110 Balanced Binary Tree, LC257 Binary Tree Paths, LC404 Sum of Left Leaves</title>
    <link href="/2023/03/03/CarlDay17/"/>
    <url>/2023/03/03/CarlDay17/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">Question</a><br>It is labeled as an easy question, but there are some important points: create a new function for the question, how to choose the <strong>return value</strong>, lambda formular.<br>Firtly, what is a <strong>Balanced tree</strong>. By <a href="https://www.geeksforgeeks.org/balanced-binary-tree/">geeksforgeeks</a><br><strong>balanced binary tree</strong> is a binary tree that follows the 3 conditions: </p><ul><li>The height of the left and right tree for any node does not differ by more than 1</li><li>The left subtree of that node is also balanced.</li><li>The right subtree of that node is also balanced.<br>And, what is height? <strong>Heigth</strong> is the shortest simple route from the node to leef node. If we want to obtain its height, we have to use the <strong>post-order traverse</strong>.  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> calcuHeight(root) !=-<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calcuHeight</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lh</span> <span class="hljs-operator">=</span> calcuHeight(root.left);<br>        <span class="hljs-keyword">if</span>(lh == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> calcuHeight(root.right);<br>        <span class="hljs-keyword">if</span>(rh == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (Math.abs(lh-rh)&gt;<span class="hljs-number">1</span>)? -<span class="hljs-number">1</span>: Math.max(lh,rh) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="For-tree-recurive-question"><a href="#For-tree-recurive-question" class="headerlink" title="For tree recurive question"></a>For tree recurive question</h1><p>For a recursive problem, we can follow 5 steps:</p><ol><li>Need a new function?</li><li>which traverse should we take: in-order, post-order, pre-order.</li><li>identify input and return</li><li>identify the end condition</li><li>identify the process in single recurion</li></ol><h1 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a>257. Binary Tree Paths</h1><p>In this question we Have to focus on the <strong>input</strong> of <em>traverse function</em> and how to use the <em>StringBuilder()</em><br>It is a DFS question, and it is a pre-order question. we need to consider <strong>whether the node is leaf or not</strong>, if leaf, then add the path to <em>res</em>, if not then add to <em>path</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>     <br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        traverse(root, <span class="hljs-string">&quot;&quot;</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root,String path, List&lt;String&gt; res)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path);<br>            sb.append(Integer.toString(root.val));<br>            <br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp;root.right == <span class="hljs-literal">null</span>)&#123;<br>                res.add(sb.toString());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sb.append(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            traverse(root.left, sb.toString(), res);<br>            traverse(root.right, sb.toString(),res);<br>        &#125;<br>        <span class="hljs-comment">//pre-order</span><br>    &#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a>404. Sum of Left Leaves</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">Question</a><br>Same as the depth of a tree, if we clearly figure out what is the meaning of the function, it is easier to write solution  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> sumOfLeftLeaves(root.right);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> leftValue + rightValue;<br>    <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span> &amp;&amp; root.left.left == <span class="hljs-literal">null</span> &amp;&amp; root.left.right == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//means the node is a leaf</span><br>        sum += root.left.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 16 | LC104 Maximum Depth of Binary Tree, LC111 Minimum Depth of Binary Tree</title>
    <link href="/2023/03/02/CarlDay16/"/>
    <url>/2023/03/02/CarlDay16/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC104 Maximum Depth of Binary Tree, LC111 Minimum Depth of Binary Tree<br><span id="more"></span></p><h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>there are two solution to this problems, one is Iterative by Layer-order traverse. When reach one layer, then <em>result++</em>. Then we can use the template to finish it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    que.offer(root);<br><br>    <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> que.poll();<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) que.offer(cur.left);<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) que.offer(cur.right);<br><br>        &#125;<br>        depth++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><br>But there is an easier way to fixit is recursive method. As we can identify, the meaning of function is the maximum of tree. So we can compute its child-tree’s depth and choose the max of them then plus one.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(leftMax, rightMax)+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h1><p>At first glance we might simply think it uses the same method as <em>Maximum Depth of Binary Tree</em>. However, it is not that easy, there are more details inside it. We can easily think of the traversal method. Then the end condition is <strong>reach the leaf node of any tree</strong>, which is <code>cur.left == null &amp;&amp; cur.right == null</code>. So the answer is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>         q.offer(root);<br><br>         <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>             <br>             <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>             <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ; i++)&#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                 <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base: reach the leaf node of any tree</span><br>                     <span class="hljs-keyword">return</span> depth;<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.left);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.right);<br>                 &#125;<br>             &#125;<br>             depth++;<br>             <br>         &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><br>What if we try the recursive method as the <em>maxDepth</em>?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> minDepth(root.right);<br><br>       <span class="hljs-keyword">return</span> Math.min(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><br>Sadly it occurs error when input a tree with only right or left tree like the figure shows.<br><img src="/img/minDepth.png" alt="minDepth"><br>So we have to deal with it by adding some terms.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> minDepth(root.right);<br><br>       <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;<br>       &#125;<br><br>         <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> Math.min(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">Question</a><br>Firstly, we shold distinct the full <strong>binary tree</strong> and <strong>complete tree</strong><br>according to <a href="https://en.wikipedia.org/wiki/Binary_tree">wikipedia</a> </p><ul><li><strong>full tree</strong> : is a tree in which every node has either 0 or 2 children.</li></ul><p><img src="/img/Full_binary.svg" alt="Full_binary"></p><ul><li><p><strong>Comlete binary tree</strong> : a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.<br><img src="/img/Complete_binary2.svg" alt="Complete_binary2"></p></li><li><p><strong>perfect binary tree</strong>: a binary tree in which all interior nodes have two children and all leaves have the same depth or same level  </p></li></ul><p>So if the subtree has same depth, then it is a full binary tree, we can calculate the node by $n = 2^{depth} - 1$<br><img src="/img/Count Complete Tree Nodes.png" alt="Count Complete Tree Nodes"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> root, r = root;<br>    <span class="hljs-comment">// height of left and right tree</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hl</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l != <span class="hljs-literal">null</span>) &#123;<br>        l = l.left;<br>        hl++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (r != <span class="hljs-literal">null</span>) &#123;<br>        r = r.right;<br>        hr++;<br>    &#125;<br>    <span class="hljs-comment">// height same --&gt; full</span><br>    <span class="hljs-keyword">if</span> (hl == hr) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, hl) - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 15 | LC107, LC199, LC637, LC515, LC116, LC 117, LC103, LC226, LC 101</title>
    <link href="/2023/03/02/CarlDay15/"/>
    <url>/2023/03/02/CarlDay15/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC107 Binary Tree Level Order Traversal II, LC199 Binary Tree Right Side View, LC637 Average of Levels in Binary Tree, LC515 Find Largest Value in Each Tree Row, LC116. Populating Next Right Pointers in Each Node, LC117. Populating Next Right Pointers in Each Node II, LC104 Maximum Depth of Binary Tree, LC226 Invert Binary Tree, LC101 Symmetric Tree<br><span id="more"></span></p><h1 id="Template-for-layer-order-traverse"><a href="#Template-for-layer-order-traverse" class="headerlink" title="Template for layer-order traverse"></a>Template for layer-order traverse</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkFun02</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">///base</span><br><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        que.offer(node);<span class="hljs-comment">//add the root node</span><br><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();/<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> que.size();<span class="hljs-comment">//notice this should not be in the loop</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123; <br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> que.poll();<br>                itemList.add(tmpNode.val);<br><br>                <span class="hljs-keyword">if</span> (tmpNode.left != <span class="hljs-literal">null</span>) que.offer(tmpNode.left);<br>                <span class="hljs-keyword">if</span> (tmpNode.right != <span class="hljs-literal">null</span>) que.offer(tmpNode.right);<br>            &#125;<br><br>            resList.add(itemList);<span class="hljs-comment">//add each layers result</span><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="LC107-Binary-Tree-Level-Order-Traversal-II"><a href="#LC107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="LC107 Binary Tree Level Order Traversal II"></a>LC107 Binary Tree Level Order Traversal II</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//必须是linkedlist 否则不能addFirst</span><br>       <br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span>  res;<br>       &#125;<br>       Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<span class="hljs-comment">//注意sz在这理而不是在for里，不然每次循环sz都会变</span><br>           <br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               <br>               level.add(cur.val);<br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br><br>           &#125;<br>           res.addFirst(level);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;  <br></code></pre></td></tr></table></figure><h1 id="LC199-Binary-Tree-Right-Side-View"><a href="#LC199-Binary-Tree-Right-Side-View" class="headerlink" title="LC199 Binary Tree Right Side View"></a>LC199 Binary Tree Right Side View</h1><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br><br>       Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz ; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(i == sz - <span class="hljs-number">1</span>)&#123;<br>                   <span class="hljs-comment">// System.out.println(i);</span><br>                   res.add(cur.val);<br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC637-Average-of-Levels-in-Binary-Tree"><a href="#LC637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="LC637 Average of Levels in Binary Tree"></a>LC637 Average of Levels in Binary Tree</h1><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">Question</a><br>In this question, we have to identify where is the start of level traverse. The <em>while</em> loop is used to traverse from top to botom. <em>for</em> loop is used to traverse from left to right, so if we wanna process each node’s value, we have to do it before it offers its right and left nodes<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Double&gt; <span class="hljs-title function_">averageOfLevels</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Double&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.offer(root);<br><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                sum += cur.val;<br><br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.right);<br>                &#125;<br><br>                &#125;<br>            res.add(sum/sz);<br>            &#125;<br>        <span class="hljs-keyword">return</span> res;<br>     &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span> &lt;&gt;();<br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ;i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                level.add(cur.val);<br>                <span class="hljs-keyword">for</span> (Node child : cur.children) &#123;<br>                    q.offer(child);<br>            &#125;<br>            <br>        &#125;<br>        <br>        res.add(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC515-Find-Largest-Value-in-Each-Tree-Row"><a href="#LC515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="LC515 Find Largest Value in Each Tree Row"></a>LC515 Find Largest Value in Each Tree Row</h1><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br>       Queue &lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       <br>       q.offer(root);<br>       <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>               max = Math.max(max,cur.val);<br>               <br>               <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                   q.offer(cur.right);<br>               &#125;<br>            <br>           &#125;<br>           res.add(max);<span class="hljs-comment">//add maximum after each level </span><br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LC116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LC116. Populating Next Right Pointers in Each Node"></a>LC116. Populating Next Right Pointers in Each Node</h1><p>This question, the difficulty is how to connect two seperate treenodes. We can consider it  as a Ternary Tree and then traverse the whole tree, which link left node to right inside one tree and link nodes between trees<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        traverse(root.left, root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(Node node1, Node node2)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span>|| node2 == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        node1.next = node2;<br>        traverse(node1.left, node1.right);<br>        traverse(node2.left, node2.right);<br>        traverse(node1.right, node2.left );<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#LC117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="LC117. Populating Next Right Pointers in Each Node II"></a>LC117. Populating Next Right Pointers in Each Node II</h1><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">Question</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>        Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// use a prenode to identify whether this is the first node of each level. Just like the Dummy node in linkedlist</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; sz; i++)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                <br>                <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>)&#123;<br>                    pre.next = cur;<br>                &#125;<br>                pre = cur;<br><br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                    q.offer(cur.right);<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC104-Maximum-Depth-of-Binary-Tree"><a href="#LC104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LC104 Maximum Depth of Binary Tree"></a>LC104 Maximum Depth of Binary Tree</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">Question</a><br>In this question, I prefer the recursion instead of traverse each level.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftValue</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightValue</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>    <span class="hljs-keyword">return</span> Math.max(leftValue,rightValue) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>It is quite simple isnt it? Just figure out what’s the recursion doing. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">depth</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>         q.offer(root);<br><br>         <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>             <br>             <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>             <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz ; i++)&#123;<br>                 <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                 <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base: reach the leaf node of any tree</span><br>                     <span class="hljs-keyword">return</span> depth;<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.left);<br>                 &#125;<br>                 <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                     q.offer(cur.right);<br>                 &#125;<br>             &#125;<br>             depth++;<br>             <br>         &#125;<br>    <span class="hljs-keyword">return</span> depth;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="LC226-Invert-Binary-Tree"><a href="#LC226-Invert-Binary-Tree" class="headerlink" title="LC226 Invert Binary Tree"></a>LC226 Invert Binary Tree</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">Question</a><br>An easy question. What we should do is </p><ol><li>indentify the return value and input parameters</li><li>the end base </li><li>logic in each recursion<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightTree</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftTree</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>       <br>       root.left = rightTree;<br>       root.right = leftTree;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="LC101-Symmetric-Tree"><a href="#LC101-Symmetric-Tree" class="headerlink" title="LC101 Symmetric Tree"></a>LC101 Symmetric Tree</h1><a href="https://leetcode.cn/problems/symmetric-tree/">Question</a>  </li></ol><p>The most important note in this question is how to identify the end. We have to seperately consider the 4 situations. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">return</span> compare(root.left, root.right);<br>   &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>       <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right  != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right !=<span class="hljs-literal">null</span> &amp;&amp; left.val != right.val)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">compareOutside</span> <span class="hljs-operator">=</span> compare(left.left, right.right);<br>       <br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">compareInside</span> <span class="hljs-operator">=</span> compare(left.right, right.left);<br>       <span class="hljs-keyword">return</span> compareOutside &amp;&amp; compareInside;<br><br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 14 | Binary tree basis</title>
    <link href="/2023/03/01/CarlDay14/"/>
    <url>/2023/03/01/CarlDay14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Binary tree basis<br><span id="more"></span></p><h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><p>In Java the TreeNode is defined<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode()&#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val)&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right)&#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h1><p>No matter preorder, inorder or postordder traverse, the main different is whill should we do some process, here is the skeleton<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//base</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// pre order process</span><br>    traverse(root.left);<br>    <span class="hljs-comment">//in order process</span><br>    traverse(root.right);<br><br>    <span class="hljs-comment">// post order</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br>According to <a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-334dd/">Labuladong</a>, when we try to figure out a tree problem when shold consider  </p><pre><code class="hljs">1. Is it possible to get the answer by traversing the binary tree? If possible, implement it with a traverse function with external variables.2. Is it possible to define a recursive function to derive the answer to the original question through the answer to the sub-question (subtree)? If possible, write the definition of this recursive function, and make full use of the return value of this function.3. No matter which thinking mode you use, you must understand what each node of the binary tree needs to do, and when it needs to be done (front, middle, and back order).</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 13 | LC239 Sliding Window Maximum, LC347 Top K Frequent Elements（Unfinished)</title>
    <link href="/2023/02/28/CarlDay13/"/>
    <url>/2023/02/28/CarlDay13/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Using monotonic queue to solve LC239 &amp; 347<br><span id="more"></span></p><h1 id="LC239-Sliding-Window-Maximum"><a href="#LC239-Sliding-Window-Maximum" class="headerlink" title="LC239 Sliding Window Maximum"></a>LC239 Sliding Window Maximum</h1><p>When we tried to move the window, it really like we are <em>poping</em> and <em>pushing</em> element in a queue. But using the direct solution to check the maximum will be a <strong>O(n*k)</strong> time cost. So we can maintain a monotonic queue. Unlike the normal big stack and small stack, it maintains a queue that may become the maximum value in a sliding window.    </p><h4 id="The-difference-between-add-and-offer-in-Queue"><a href="#The-difference-between-add-and-offer-in-Queue" class="headerlink" title="The difference between add() and offer in Queue:"></a>The difference between <code>add()</code> and <code>offer</code> in Queue:</h4><ul><li><code>add()</code>,<code>remove</code>,<code>element</code>: throws an exception</li><li><code>offer()</code>,<code>poll()</code>,<code>peek</code>: returns a special value: null or false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">MonotonicQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicQueue</span>();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; k - <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// fullfill first k -1 queue, if fullfill the window then will miss the first maxvalue</span><br>                mq.offer(nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                mq.offer(nums[i]);<br>                res.add(mq.maxValue());<br>                mq.poll(nums[i - k + <span class="hljs-number">1</span>]);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>            arr[i] = res.get(i);<br>    &#125;<br>     <span class="hljs-keyword">return</span> arr;<br>       <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicQueue</span> &#123;<br>    Deque&lt;Integer&gt; de = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">while</span>(!de.isEmpty() &amp;&amp; de.peekLast() &lt; n)&#123;<span class="hljs-comment">// when we add a new element, we have to compare it with the Last element instead of First bcs we need to maintain is mono</span><br>            de.pollLast();<br>        &#125;<br>        de.offerLast(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> de.peekFirst();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span> (n == de.getFirst()) &#123;<br>            de.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 11 | LC20 Valid parentheses, LC1047 Remove All Adjacent Duplicates In String, LC150. Evaluate Reverse Polish Notation</title>
    <link href="/2023/02/25/CarlDay11/"/>
    <url>/2023/02/25/CarlDay11/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC20,1047,150<br><span id="more"></span><br>When we handle the elemination question, it will be useful to use stack.<br>But one thing is important that <strong>stack</strong> is not recommended in Java becasue of its low efficiency. We prefer <em>deque</em>. But for better understanding, we use stack in this blog.</p><h1 id="LC20-Valid-parentheses"><a href="#LC20-Valid-parentheses" class="headerlink" title="LC20 Valid parentheses"></a>LC20 Valid parentheses</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">Question</a><br>In this question, we have to pair the parenthese. We can use stack to pair them. If we meet left par, them push its right one into stack. When we go through all the string, if meet its one, then pop it.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span>hexo &#123;<br>       Stack&lt;Character&gt; x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-comment">//    Deque&lt;Character&gt; x = new LinkedList&lt;&gt;()</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>           <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>               x.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.isEmpty()||x.peek()!=c)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               x.pop();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x.isEmpty();<span class="hljs-comment">//notice the return value</span><br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h1><p>Like LC20, easy but will use <em>Stringbuffer</em>. Check every char, when it is the peek of stack, then pop stack.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque &lt;Character&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>           ch = s.charAt(i) ;<br>           <br>           <span class="hljs-keyword">if</span>(que.isEmpty()||que.peek() != ch)&#123;<br>               que.push(ch);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               que.pop();<br>           &#125;<br>           <br>        &#125;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            res.append(que.pollLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC150-Evaluate-Reverse-Polish-Notation"><a href="#LC150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="LC150. Evaluate Reverse Polish Notation"></a>LC150. Evaluate Reverse Polish Notation</h1><p>The Reverse polish notation is proposed for the Stack calculation in computer. it is very easy that, we push <em>intereger</em> into stack, if we meet a calculator, we pop 2 elements and calculate. Then push the result into stack.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>      Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span>(String token: tokens)&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;+-/*&quot;</span>.contains(token))&#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> s.pop(), b = s.pop();<br>              <span class="hljs-keyword">switch</span>(token)&#123;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                    s.push(a + b);<br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                    s.push(b - a);<span class="hljs-comment">// notice that it is b-a instead of a-b</span><br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                    s.push(a * b);<br>                    <span class="hljs-keyword">break</span>;<br>                  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                  s.push(b / a); <span class="hljs-comment">// b/a instead of a/b</span><br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              s.push(Integer.parseInt(token));<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> s.pop();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 10 | LC232 Implement Queue using Stacks LC225 Implement Stack using Queues</title>
    <link href="/2023/02/25/CarlDay10/"/>
    <url>/2023/02/25/CarlDay10/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Stack-and-queue"><a href="#Stack-and-queue" class="headerlink" title="Stack and queue"></a>Stack and queue</h1><p>In this part, the most important thing is to know what is the differences between queue and stack. Besides We have to get familiar with methods in stack and queue.<br>In stack, it is FILO, queue is FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Stack</span><br>Stack&lt;Integer&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span> &lt;&gt;();<br>s1.push();<br>s1.pop();<br>s1.peek();<br>s1.empty() <span class="hljs-comment">//check whether it is empty </span><br><br><span class="hljs-comment">//Deque. it can be used in FIFO and FILO</span><br>Deque&lt;Integer&gt; de = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>&lt;Integer&gt;();<br>de.addLast();<br>de.offerLast();<br>de.removeFirst();<br>de.poll <span class="hljs-title function_">first</span><span class="hljs-params">()</span>;<br>de.getFirst();<br>de.peekFirst();<br><br></code></pre></td></tr></table></figure></p><h1 id="LC232-Implement-Queue-using-Stacks"><a href="#LC232-Implement-Queue-using-Stacks" class="headerlink" title="LC232 Implement Queue using Stacks"></a>LC232 Implement Queue using Stacks</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">Question</a><br>As said before, the differences between queue and stack is FIFO or FILO.<br>So to implement a queue, we can implement 2 stacks. One for in-put and one for out-put.<br>When new element is pushed in the queue, it enter <em>inStack</em>. If we wanna pop one element, we have to pop element from <em>inStack</em> to <em>outStack</em>, then pop from <em>outStack</em>, so as to <em>peek()</em>.<br>So the answer is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; in, out;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br>        in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        in.push(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(out.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!in.isEmpty())&#123;<br>                out.push(in.pop());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> out.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(out.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span>(!in.isEmpty())&#123;<br>                out.push(in.pop());<br>            &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> out.peek();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC225-Implement-Stack-using-Queues"><a href="#LC225-Implement-Stack-using-Queues" class="headerlink" title="LC225. Implement Stack using Queues"></a>LC225. Implement Stack using Queues</h1><p>From FIFO to FILO. To implement it, we can offer the first ele in queue and push in to queue again, then we can get a FILO. But we have to maintain a variable <em>top</em> to save the top element of queue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>&#123;<br>    Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        q.offer(x);<br>        top = x;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> top;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> q.size();<br>        <span class="hljs-keyword">while</span>(size &gt; <span class="hljs-number">2</span>)&#123;<br>            q.offer(q.poll());<br>            size--;<br>        &#125;<br>        <br>        top = q.peek();<br>        q.offer(q.poll());<br>        <span class="hljs-keyword">return</span> q.poll();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> q.isEmpty();<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Network Theory Lecture Notes</title>
    <link href="/2023/02/24/NetworkTheoryNote/"/>
    <url>/2023/02/24/NetworkTheoryNote/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lecture-1-Networks-and-Graphs"><a href="#Lecture-1-Networks-and-Graphs" class="headerlink" title="Lecture 1 Networks and Graphs"></a>Lecture 1 Networks and Graphs</h1><h2 id="Some-definition"><a href="#Some-definition" class="headerlink" title="Some definition"></a>Some definition</h2><ul><li>Network: a set of items connected by their relations</li><li>Adjacency matrix </li><li>Directed graph &amp; undirected graph</li><li>degree of node: how many edges connected to the node </li><li>connected graph and disconnected node: depend on <em>isolate node</em></li><li>Connectivity of Directed graph<ul><li>strongly connected: any node can reach any node via directed path</li><li>Direceted Acyclic Graph(DAG): has no cycles</li></ul></li><li>$no. edge \geq no.Vertices - no.components$</li><li><strong>DFS</strong> can be used to explore the graph repeatedly until the entire graph has been traversed </li><li><strong>BFS</strong>: Search the graph outward from a starting node, reaching the closet nodes first<ul><li>It can be used to organise the structure of a graph, arranging the nodes based on their distances from a fixed starting point.</li></ul></li><li>Weighted graph </li><li>complete graph: has maximum number of edges— node that has $n(n-1)/2$ edges</li><li>Bipartite graph<ul><li>ndoes can be divided into two disjoint sets, these two sets are independent</li><li>every link connects a node in U to one node in V</li></ul></li><li>Tree: a connected (undirected) graph with no cycles<ul><li>has only n-1 edges</li><li>unique path between any two nodes</li></ul></li></ul><h2 id="Measures-to-describe-Network"><a href="#Measures-to-describe-Network" class="headerlink" title="Measures to describe Network"></a>Measures to describe Network</h2><ul><li>Degree distributions:$P(k) = \frac{N(k)}{n}$, N(k) is number of nodes with degree k.</li><li>Distance:the number of edges along the <strong>shortest path</strong> connecting those nodes.</li><li>Diameter: the <strong>largest distance</strong> between any two nodes</li><li>average path length</li><li><p>Clustering coefficient</p><ul><li><p>for node i with degree $k_i$, the coefficient is </p><script type="math/tex; mode=display">C_i = \frac{2e_i}{k_i(k_i - 1)}e_i is the number of edges between the neighbors of node i</script></li><li><p>Average clustering: $C = \frac{1}{N}\sum{C_i}$</p></li></ul></li></ul><h2 id="Spanning-Tree"><a href="#Spanning-Tree" class="headerlink" title="Spanning Tree"></a>Spanning Tree</h2><ul><li>for any connected graph there is a spanning tree that maintains connectivity but contains no cycle(close loop)</li><li>Minimum spanning tree(MST): can reach every vertex and ensure the sum of all weights is minumum<h3 id="Construction-a-spanning-tree"><a href="#Construction-a-spanning-tree" class="headerlink" title="Construction a spanning tree"></a>Construction a spanning tree</h3></li></ul><ol><li>select any node in N; N’ = {n}; E’={}</li><li>if N’ = N, stop</li><li>choose (i,j) $\in$ E, i $\in$ N’, j $\notin$ N’<ol><li>$N := N’ \cup {j}$</li><li>$E’ := E \cup {(i,j)}$</li><li>Go main  step 2</li></ol></li></ol><p><strong>The spanning tree is not unique</strong></p><h3 id="If-G-is-a-connected-graph-of-n-nodes"><a href="#If-G-is-a-connected-graph-of-n-nodes" class="headerlink" title="If G is a connected graph of n nodes"></a>If G is a connected graph of n nodes</h3><ul><li>G contains at least n-1 edges</li><li>G contains a spanning tree</li><li>if G contains exactly n-1 edges, G is a spanning tree<h2 id="Distributed-Algorithm"><a href="#Distributed-Algorithm" class="headerlink" title="Distributed Algorithm"></a>Distributed Algorithm</h2><h3 id="Random-Graph-Model"><a href="#Random-Graph-Model" class="headerlink" title="Random Graph Model"></a>Random Graph Model</h3>Suppose: edge(u,v) is formed with probability $p \in (0,1)$, n is no. of nodes. Then <em>n</em> and <em>p</em> can’t define a unique graph<br>Use $G_{np}$ to denote it, n is numboer of nodes and p is the probability</li></ul><h3 id="Degree-distribution"><a href="#Degree-distribution" class="headerlink" title="Degree distribution"></a>Degree distribution</h3><ul><li>THe expected degree of a node </li></ul><script type="math/tex; mode=display">E[X_v] = (n - 1)p</script><p><img src="/img/Degree Distribution.png" alt="Degree Distribution"><br>As network size ++, distribution becomes <em>increasingly narrow</em></p><p><img src="/img/Clustering Coefficient in random graphs.png" alt="Clustering Coefficient in random graphs"></p><h1 id="Tutorial-1"><a href="#Tutorial-1" class="headerlink" title="Tutorial 1"></a>Tutorial 1</h1><h2 id="Determine-a-Minimum-Spanning-Tree-MST"><a href="#Determine-a-Minimum-Spanning-Tree-MST" class="headerlink" title="Determine a Minimum Spanning Tree(MST)"></a>Determine a Minimum Spanning Tree(MST)</h2><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html">文章</a>  </p><ul><li>any undirected graph has a minimum spanning tree forest. </li><li>MST is not necessarily unique <h3 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h3></li><li>Start with an arbitrary single node then add minimum weight outgoing edge</li><li>Find $u ∈ U$ and $v ∈ V − U$ such that the edge (u, v) is a smallest edge between U and V − U.</li><li><img src="/img/prim.png" alt="prim">  </li><li>from (a) to (b) we will select the vertex from <strong>a,d,c</strong> because it connect to a-b. <h3 id="kruskal’s-algorithm"><a href="#kruskal’s-algorithm" class="headerlink" title="kruskal’s algorithm"></a>kruskal’s algorithm</h3></li><li>imput the weighted graph then sort the edges based on its weight</li><li>Add the edges from the smallest edge, but need to avoid loop</li></ul><h1 id="Lecture-2-Small-World-phenomenon"><a href="#Lecture-2-Small-World-phenomenon" class="headerlink" title="Lecture 2 Small World phenomenon"></a>Lecture 2 Small World phenomenon</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><ul><li>Isolation of nodes: node that is not connected to the rest of the graph.</li><li>To make the expectation $E(X_{v})$ is independent of n, we need to let $p = \frac{c}{n-1}$, c is a constant, so that $E = p*(n-1) = c$</li><li>No. of Isolated nodes in a RG:<ul><li>$P[v has degree 0] = (1 - p)^{n-1} = e^{-c}$ when n -&gt;$\iint$</li><li>we can obatin it by let $p = \frac{c}{n-1}$</li></ul></li><li>To have no islotated nodes<ul><li>To make $P(I) = ne^{-c} = 0$, we  can have<br><img src="/img/IsolatedNodes.png" alt="IsolatedNodes"><br><img src="/img/Graph structure.png" alt="Graph structure"></li></ul></li></ul><h2 id="Small-world-phenomena"><a href="#Small-world-phenomena" class="headerlink" title="Small world phenomena"></a>Small world phenomena</h2><ul><li>Def: Taking a connected graph and adding a very small number of edges randomly, the diameter tends to drop drastically.</li></ul><h2 id="Power-Law"><a href="#Power-Law" class="headerlink" title="Power Law"></a>Power Law</h2><ul><li>a functional relationship $p(k) = k^{-a}$ quantities, where one quantity varies as a power of another</li><li>与k负相关</li><li>Scale free network: Networks with a power law tail in their degree distribution<br><img src="/img/Scale-Free Nework.png" alt="Scale-Free Nework"></li></ul><h3 id="Mathematics-of-Power-Law"><a href="#Mathematics-of-Power-Law" class="headerlink" title="Mathematics of Power Law"></a>Mathematics of Power Law</h3><ul><li>Power law is heavy tail</li><li>$P(X&gt;x)$ is <strong>heavy tailed</strong> if </li></ul><script type="math/tex; mode=display">lim_{x\to \infty}\frac{P(X>x)}{e^{-\lambda x}}</script><ul><li><strong>Rich get richer:</strong> New nodes are more likely to link to nodes that already have high degree<h1 id="Lecture-3-amp-4-Probabilistic-models-of-Information-flow"><a href="#Lecture-3-amp-4-Probabilistic-models-of-Information-flow" class="headerlink" title="Lecture 3&amp;4 Probabilistic models of Information flow"></a>Lecture 3&amp;4 Probabilistic models of Information flow</h1></li><li>Information Cascade: When information nodes are connected by a network, it becomes possible to influence each other’s truth.</li></ul><h2 id="Diffusion"><a href="#Diffusion" class="headerlink" title="Diffusion"></a>Diffusion</h2><ul><li>Direct-benefit-effects<ul><li>simple self-interest will dictate that you should adopt the new behaviour o<strong>nce a sufficient proportion of the neighbours</strong> have done so</li></ul></li></ul><h2 id="Diffusion-Models"><a href="#Diffusion-Models" class="headerlink" title="Diffusion Models"></a>Diffusion Models</h2><h3 id="Decision-based-models"><a href="#Decision-based-models" class="headerlink" title="Decision based models"></a>Decision based models</h3><ul><li>Models of product adoption, decision making</li><li>A node observes decisions of its neighbours and makes its own decision</li><li>EG: You watch a movie if k of your friends told you about it<h3 id="Probabilistic-models"><a href="#Probabilistic-models" class="headerlink" title="Probabilistic models"></a>Probabilistic models</h3></li><li>Models of influence or disease spreading</li><li>eg: you got Covid with some probability from each active neighbour in the network</li></ul><h3 id="Cascades"><a href="#Cascades" class="headerlink" title="Cascades"></a>Cascades</h3><ul><li>limits: what causes stop<ul><li>structure</li><li>choice of initial adopters</li><li>value of the threshold<ul><li>1/2 is the golden choice: <strong>There is no (infinite) G where cascade capacity could exceed 1⁄2</strong> .</li></ul></li></ul></li><li>Capacity: largest q for which some finite set S can cause a cascade.</li></ul><h2 id="Connectedness"><a href="#Connectedness" class="headerlink" title="Connectedness"></a>Connectedness</h2><ul><li>at the level of <strong>structure</strong>: who is linked to whom  </li><li>at level of <strong>behaviour</strong>: the fact that each <strong>individual’s actions</strong> have implicit consequences for the <strong>outcomes</strong> of everyone in the system.</li></ul><h2 id="Information-cascade"><a href="#Information-cascade" class="headerlink" title="Information cascade"></a>Information cascade</h2><p>When people/objects are connected by a network, it becomes possible for them to influence each other’s behaviour and decisions.</p><h2 id="Diffusion-in-Networks"><a href="#Diffusion-in-Networks" class="headerlink" title="Diffusion in Networks"></a>Diffusion in Networks</h2><p><strong>direct-benefit effects</strong>: simple self-interest will dictate that you should adopt the new behaviour once a sufficient proportion of the neighbours have done so.<br>The diffusion model can be devided into <strong>Decision models</strong> and <strong>Probabilistic models</strong></p><ul><li>Decision based model<br>Models of product adoption, decision making<br>Eg: You watch a movie if k of your friends told you about it.</li><li>Probabilistic model<br>Models of influence or disease spreading<br>eg: You “catch” a disease <strong>with some probability</strong> from each active neighbour in the network</li></ul><h2 id="Decision-based-model"><a href="#Decision-based-model" class="headerlink" title="Decision based model"></a>Decision based model</h2><p><strong>What causes the spread stoping?  </strong></p><ol><li>network structure</li><li>choice of initial adopters</li><li>values of threshold<ol><li>the golden q = 0.5</li></ol></li></ol><p>Cascade capacity: largest q for which some finite set S can cause a cascade.<br><strong>There is no (infinite) G where cascade capacity could exceed 1⁄2 .</strong></p><h2 id="Probabilistic-models-1"><a href="#Probabilistic-models-1" class="headerlink" title="Probabilistic models"></a>Probabilistic models</h2><h3 id="SIR-Epidemic-Model"><a href="#SIR-Epidemic-Model" class="headerlink" title="SIR Epidemic Model"></a>SIR Epidemic Model</h3><ul><li><strong>S</strong>usceptible</li><li><strong>I</strong>nfectious</li><li><strong>R</strong>emoved: after the full infectious period, this node is removed from consideration and<br><img src="/public/img/SIRModel.png" alt="SIRModel"></li><li>In SIR model, once your are recovered you can never get infecte again<br><img src="/img/SIRModel2.png" alt="SIRModel2"></li></ul><h3 id="SIS-model"><a href="#SIS-model" class="headerlink" title="SIS model"></a>SIS model</h3><ul><li><strong>Recovered nodes immediately become susceptible</strong><br><img src="/img/SISModel.png" alt="SISModel"><br><img src="/img/SISModel2.png" alt="SISModel2"><br><strong>The SIS epidemic can then be represented as an SIR epidemic on this time-expanded network.</strong></li></ul><h3 id="Independent-Cascade-model"><a href="#Independent-Cascade-model" class="headerlink" title="Independent Cascade model"></a>Independent Cascade model</h3><ul><li>Init some nodes active and each aedge(u,v) has probability(weight)  </li><li>It is hard to estimate it, wo we can <ul><li>make all edges has same weight then back to SIR model</li><li></li></ul></li></ul><h3 id="Exposure-and-Adaptation"><a href="#Exposure-and-Adaptation" class="headerlink" title="Exposure and Adaptation"></a>Exposure and Adaptation</h3><ul><li>Exposure: Node’s neighbour exposes the node to the information <ul><li>Probability of adopting new behaviour depends on the number of connection/friends who have already adopted</li></ul></li><li>Adoption: The node acts on the information<br><img src="/img/ExposureCurve.png" alt="ExposureCurve">  </li></ul><h1 id="Lecture-5-Queueing-and-Modelling-Delay-in-the-Networks"><a href="#Lecture-5-Queueing-and-Modelling-Delay-in-the-Networks" class="headerlink" title="Lecture 5 Queueing and Modelling Delay in the Networks"></a>Lecture 5 Queueing and Modelling Delay in the Networks</h1><p>Queueing Systems: used for analysing network performance</p><ul><li>how long does a packet spend waiting inbuffers</li><li>how large are the buffers</li></ul><h2 id="When-using-queueing-analysis"><a href="#When-using-queueing-analysis" class="headerlink" title="When using queueing analysis?"></a>When using queueing analysis?</h2><p>When Customers get service s<strong>ome time</strong> faster <strong>some time</strong> slower than they arrive to the system</p><h2 id="delay-models"><a href="#delay-models" class="headerlink" title="delay models"></a>delay models</h2><p><img src="/img/DelayModel.png" alt="DelayModel"></p><ul><li>Quantities<ul><li>Arrival rate of customers ( λ)</li><li>Service rate (μ)</li><li>Queue Utilisation (ρ = λ/μ)</li></ul></li></ul><h3 id="Little’s-Theorem"><a href="#Little’s-Theorem" class="headerlink" title="Little’s Theorem"></a>Little’s Theorem</h3><p><img src="/img/Little&#39;s Theorem" alt="Little&#39;s Theorem"><br>Can be applied to entire system or part of it.</p><h2 id="Single-Server-Queues"><a href="#Single-Server-Queues" class="headerlink" title="Single Server Queues"></a>Single Server Queues</h2><ul><li><p>M/M/1</p><ul><li>Poisson arrivals, exponential service  times</li></ul></li><li><p>Poinsson Process</p></li></ul><script type="math/tex; mode=display">P(n arrivals in interval T) = \frac{(λT)^ne^{-λT}}{n!}</script><ul><li>$E[n] (first moment of arrival)= λT$</li><li>$E[n^2] (second moment of arrival)= λT +(λT)^2$</li><li>$σ^2= λT$</li></ul><h2 id="Markov-Chain"><a href="#Markov-Chain" class="headerlink" title="Markov Chain"></a>Markov Chain</h2><ul><li>a memory-less: predictions about its future state without consulting past states.</li><li>$\Pr(X<em>NaN=x\mid X</em>{1}=x<em>{1},X</em>{2}=x<em>{2},\ldots ,X</em>{n}=x<em>{n})=\Pr(X</em>NaN=x\mid X<em>{n}=x</em>{n})$</li></ul><h2 id="Markov-for-M-M-1"><a href="#Markov-for-M-M-1" class="headerlink" title="Markov for M/M/1"></a>Markov for M/M/1</h2><p><img src="/img/Markov for M/M/1" alt="Markov for M/M/1"></p><ul><li>The probability of being in each state<script type="math/tex; mode=display">P(n) = ρ^n(1-ρ)</script>when n = 0, it means idel state</li></ul><h3 id="Average-Queue-size"><a href="#Average-Queue-size" class="headerlink" title="Average Queue size"></a>Average Queue size</h3><p><img src="/img/Average Queue size.png" alt="Average Queue size"></p><ul><li>Example<br><img src="/img/Average Queue sizeeg.png" alt="Average Queue sizeeg"></li></ul><h2 id="M-server-systems-M-M-m"><a href="#M-server-systems-M-M-m" class="headerlink" title="M server systems: M/M/m"></a>M server systems: M/M/m</h2><p><img src="/img/mmm.png" alt="mmm"><br>utilization factor</p><script type="math/tex; mode=display">ρ= λ/mμ</script><ul><li>all idel:<script type="math/tex; mode=display">P(0) = (1+ρ+)</script><h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3>We can model the system as a Markov chain with three states:</li></ul><ol><li>State 0: Both servers are idle</li><li>State 1: One server is busy, one server is idle</li><li>State 2: Both servers are busy</li></ol>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 6 | KMP(complete later)</title>
    <link href="/2023/02/23/CarlDay9/"/>
    <url>/2023/02/23/CarlDay9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>Where F and b do not match, it will return to the place where it matched before</p><ul><li>prefix table<br>Prefix: all strings including the first letter but not the last letter<br>Suffix: Contains only the last letter and does not contain the initial letter<br>longest equal suffix</li></ul><p>During the matching process, record the longest equal suffix and suffix. When a conflict occurs, the index returned by the pointer is the position of the longest suffix and suffix</p><p>When there is a string mismatch, you can know a part of the text content that has been matched before, and you can use this information to avoid matching from scratch</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 8 | LC344 reverse String, LC541 Rever se String II, LC151 Reverse Words in a String, Offer58 Reverse Left Words</title>
    <link href="/2023/02/22/CarlDay8/"/>
    <url>/2023/02/22/CarlDay8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>When we want to solve string problems, we can think of it as some kind of linked list. The topic will be simpler<br><span id="more"></span></p><h1 id="LC344-reverse-String"><a href="#LC344-reverse-String" class="headerlink" title="LC344 reverse String"></a>LC344 reverse String</h1><p><a href="https://leetcode.cn/problems/reverse-string/">Question</a><br>Just like reverse a linked array, use two-pointer <em>left</em> and <em>right</em>, point to start and end of the char. Then swap them.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC541-Reverse-String-II"><a href="#LC541-Reverse-String-II" class="headerlink" title="LC541 Reverse String II"></a>LC541 Reverse String II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">Question</a><br>Unlike LC 344, this problem is to reversed in groups. Reverse the first k every 2k, and reverse all when the mantissa is not enough k<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">char</span> [] ch = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; ch.length; i +=<span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-keyword">if</span>(i + k &lt;= ch.length)&#123;<br>                reverse(ch, i, i + k - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            reverse(ch, i, ch.length - <span class="hljs-number">1</span>);            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span> [] ch, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">for</span>(;i &lt; j; i++,j--)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ch[i];<br>            ch[i] = ch[j];<br>            ch[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="offer05-Replace-Space"><a href="#offer05-Replace-Space" class="headerlink" title="offer05: Replace Space"></a>offer05: Replace Space</h1><p>The topic is very simple, you only need to traverse it once. If you encounter a space, append a <em>%20</em>. For this question, you need to learn how to use <strong>StringBuilder</strong> and <strong>charAt()</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sb.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h1 id="LC151-Reverse-Words-in-a-String"><a href="#LC151-Reverse-Words-in-a-String" class="headerlink" title="LC151 Reverse Words in a String"></a>LC151 Reverse Words in a String</h1><p>Remove extra spaces first. Then flip the entire string, and flip the letters in each word.<br>The idea of this question is not very difficult. The difficult part is that the details of the code need to be adjusted, especially when cleaning the data. The other is the start and end points when reversing words</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <br>    <span class="hljs-comment">// remove extra space</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br><br>            sb.append(c);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sb.isEmpty() &amp;&amp; sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// string after cleaning</span><br>    <span class="hljs-type">char</span>[] chars = sb.toString().toCharArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chars.length;<br>    <span class="hljs-comment">// reverse whole string </span><br>    reverse(chars, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// reverse each word</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> == n || chars[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <br>                reverse(chars, i, j);<br>               <br>                i = j + <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>        i++;<br>        j--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Offer58-Reverse-Left-Words"><a href="#Offer58-Reverse-Left-Words" class="headerlink" title="Offer58 Reverse Left Words"></a>Offer58 Reverse Left Words</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">Question</a><br>Reverse Left Words is to transfer several characters in front of the string to the end of the string.<br>The simplest way is use API <code>s.substring(n) + s.substring(0,n);</code><br>But it is not the aim of practicing programming. so the solution is<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>    StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<br>    reverseString(sb,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    reverseString(sb,n,len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> sb.charAt(start);<br>        sb.setCharAt(start, sb.charAt(end));<br>        sb.setCharAt(end, temp);<br>        start++;<br>        end--;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://programmercarl.com/0151.翻转字符串里的单词.html#其他语言版本">代码随想录</a></li><li><a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-wei-shu-150fb/">labuladong 的算法小抄</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nSum algorithm Problems</title>
    <link href="/2023/02/22/nsum/"/>
    <url>/2023/02/22/nsum/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>nSum problem is a type of very famous problem. On leetcode, we have <a href="https://leetcode.com/problems/two-sum/">two sum</a>, <a href="https://leetcode.com/problems/3sum/">3Sum</a>, <a href="https://leetcode.com/problems/4sum/">4Sum</a>. To solve these problems, we can use double-pointer method.<br>The basic way is <strong>Sort the array firstly, then double-pointer</strong>   </p><h2 id="two-sum"><a href="#two-sum" class="headerlink" title="two sum"></a>two sum</h2><p>The traditional method is using <strong>HashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Map&lt;Integer,Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(set1.containsKey(target-nums[i]))&#123;<br>                val = set1.get(target-nums[i]);<br>                res[<span class="hljs-number">0</span>] = val;<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            set1.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>But if we wanan return <strong>elements</strong> instead of <strong>index</strong>. Follow the main method, we should sort the array first and then use a <em>left</em> pointer and a <em>right</em> ponter to solve the problem.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[left], [right]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>To avoid the replicate elements like the input is <code>[1,1,1,2,2,3,3]</code>, we can jump the duplicate element when<code>sum == target</code><br>then we can have<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> nums[left], rValue = nums[right];<br><br>            <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == rValue)<br>                    right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                list.add(nums[left]);<br>                list.add(nums[right]);<br>                res.add(list);<br><br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == rValue)<br>                    right--;<br>               <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><p>After solving the generalization of two sum, we can easily extend the topic to 3 sum. The solution is to find the two sum of the remaining two numbers after the first number is determined.  As well, we generalize it into function with <em>int target</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>             List&lt;List&lt;Integer&gt;&gt; two = twoSum(nums, i+<span class="hljs-number">1</span>, target - nums[i]);<br>   <br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; x : two)&#123;<br>            x.add(nums[i]);<br>            res.add(x);<br>        &#125;<br>        <span class="hljs-comment">//To avoid the duplicate</span><br>        <span class="hljs-keyword">while</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i + <span class="hljs-number">1</span>]) <br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">// two sum</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start, right = nums.length - <span class="hljs-number">1</span>;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">lValue</span> <span class="hljs-operator">=</span> nums[left], rValue = nums[right];<br><br>            <span class="hljs-keyword">if</span>(sum &lt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == rValue)<br>                    right--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                list.add(nums[left]);<br>                list.add(nums[right]);<br>                res.add(list);<br><br>                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == lValue)<br>                    left++;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == rValue)<br>                    right--;<br>               <br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h2><p>Question: <a href="https://leetcode.com/problems/4sum/">4Sum</a><br>For 4 sum, we just need to calculate 3 sum first, and the left is like what 3sum does to 2 sum. But what has to be noticed is that we need to use <strong>long</strong>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/yi-ge-fang-894da/">labuladong的算法小抄</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 7 | LC454 4Sum II, LC383 Ransom Note, LC15 3sum, LC18 4sum</title>
    <link href="/2023/02/22/CarlDay7/"/>
    <url>/2023/02/22/CarlDay7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LC454 4Sum II, LC383 Ransom Note, LC15 3sum, LC18 4sum<br><span id="more"></span></p><h1 id="LC454-4Sum-II"><a href="#LC454-4Sum-II" class="headerlink" title="LC454 4Sum II"></a>LC454 4Sum II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">Question</a><br>In this question, the most important thing is to get familiar with the methdo in <em>HashMap</em>, we can visit the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Oracle java document</a> to find the methods needed. The most common methods are<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/* methods</span><br><span class="hljs-comment">*/</span><br>    put(K key, V value)<br>        <span class="hljs-comment">//Associates the specified value with the specified key in this map</span><br>        get(Object key)<br>        <span class="hljs-comment">//Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.</span><br>        remove(Object key)<br>        size()<br>        isEmpty()<br>    containsKey(Object key)<br>        <span class="hljs-comment">//Returns true if this map contains a mapping for the specified key.    </span><br>        containsValue(Object value)<br>        <span class="hljs-comment">//Returns true if this map maps one or more keys to the specified value</span><br>        <br><br>        <span class="hljs-comment">/* Methods inherited from class java.util.AbstractMap</span><br><span class="hljs-comment">        */</span><br>        equals, hashCode, toString<br>        <br></code></pre></td></tr></table></figure><br>The solution of this question is easy. Use a HashMap to store sums of the first two arrays, and then check whether the sums of last two arrays are contained. In HashMap, <em>key</em> is the sum of number, <em>value</em> is times they showed.<br>Solution:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;<br>        HashMap&lt;Integer, Integer&gt; sum1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">if</span>(sum1.containsKey(sum))&#123;<br>                    sum1.put(sum, sum1.get(sum) + <span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sum1.put(sum, <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums4)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> i + j;<br>                <span class="hljs-keyword">if</span>(sum1.containsKey(<span class="hljs-number">0</span> - sum))&#123;<br>                    res += sum1.get(<span class="hljs-number">0</span> - sum);<br>                   <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC383-Ransom-Note"><a href="#LC383-Ransom-Note" class="headerlink" title="LC383 Ransom Note"></a>LC383 Ransom Note</h1><p>Same as LC242 Valid Anagram, check <a href="CarlDay6.md">former notes</a>. Just notice the <code>str.toCharArray()</code> method.<br>Here is the solution<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> &#123;<br>        <span class="hljs-type">int</span> [] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : magazine.toCharArray())&#123;<br>            arr[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : ransomNote.toCharArray())&#123;<br>            arr[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : arr)&#123;<br>            <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC15-3sum-LC18-4sum"><a href="#LC15-3sum-LC18-4sum" class="headerlink" title="LC15 3sum LC18 4sum"></a>LC15 3sum LC18 4sum</h1><p>see the <a href="https://alcuinyang.github.io/2023/02/22/nsum/">nSum</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day 6 | LC242 Valid Anagram LC349 Intersection of Two Arrays LC202 Happy Number LC1 two sum</title>
    <link href="/2023/02/21/CarlDay6/"/>
    <url>/2023/02/21/CarlDay6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HashTable. Including: LC242 Valid Anagram LC349 Intersection of Two Arrays LC202 Happy Number LC1 two sum<br><span id="more"></span></p><h1 id="Hash-Table-Intro"><a href="#Hash-Table-Intro" class="headerlink" title="Hash Table Intro"></a>Hash Table Intro</h1><p>Hash table is a map with <strong>Key</strong> and <strong>Value</strong>. It is an one2one mapping by using <strong>Hash function</strong>. In this way we can access the element in <strong>O(1)</strong> time.<br>To implement hash table, we often use <strong>array, set, map</strong></p><h2 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h2><ul><li>def: two values mapping one key.<h3 id="solution"><a href="#solution" class="headerlink" title="solution:"></a>solution:</h3><h4 id="Separate-chaining"><a href="#Separate-chaining" class="headerlink" title="Separate chaining"></a>Separate chaining</h4>It is usually implemented using linked lists. If there is any collision (i.e. two different elements have same hash value) then store both the elements in the same linked list.<h4 id="Linear-probing"><a href="#Linear-probing" class="headerlink" title="Linear probing"></a>Linear probing</h4></li></ul><h1 id="LC242-Valid-Anagram"><a href="#LC242-Valid-Anagram" class="headerlink" title="LC242 Valid Anagram"></a>LC242 Valid Anagram</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">Question</a><br>Using an array to store 26 characters. In string <em>s</em>, if one characters shows, then the related position add 1. After this, check <em>t</em>, if character shows, postion minus 1. Finally, check the array, if all 0, then true. Else, false.  </p><p><strong>Notice:</strong></p><ol><li>to identify the position, we can use <code>int pos = c - &#39;a&#39;</code></li><li>String cant be process dirctly, we should use <code>s.toCharArray()</code> to transfer it into char.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> [] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: s.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            count[n]++;<br>        &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: t.toCharArray())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            count[n]--;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; count.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(count[i]!= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="LC349-Intersection-of-Two-Arrays"><a href="#LC349-Intersection-of-Two-Arrays" class="headerlink" title="LC349 Intersection of Two Arrays"></a>LC349 Intersection of Two Arrays</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">Question</a><br>For intersection, the result is an unordered set with no duplicate elements. So we use set to solve this problem. Use two sets. One to iterate over the first array. Then check whether the value of the second input is in this set, and if it exists, add it to the result set. Then convert the result set into an array<br><strong>Notice</strong>:</p><ul><li>we cant use set all the time because it needs more space to store and slower than array.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        Set&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Set&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)&#123;<br>            set1.add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j : nums2)&#123;<br>            <span class="hljs-keyword">if</span>(set1.contains(j))&#123;<br>                set2.add(j);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// resArray = set2.toArray();</span><br>        <span class="hljs-comment">// int[] ints = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();</span><br>        <span class="hljs-keyword">return</span> set2.stream().mapToInt(Integer::valueOf).toArray();<span class="hljs-comment">//transfer to array</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="LC202-Happy-Number"><a href="#LC202-Happy-Number" class="headerlink" title="LC202 Happy Number"></a>LC202 Happy Number</h1><a href="https://leetcode.cn/problems/happy-number/">Question</a><br><strong>Happy number is not happy</strong><br>It is an interesting question. We just need to remember one thing: as long as there are repeated numbers, there will be an infinite loop. So if there are repeated numbers, return flase. Note: Repeat numbers. Let us think of using hash set.<br>Notice:<br>The implementation of get next number is good. especially the <code>while(n&gt;0)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        Set&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span> &amp;&amp; !res.contains(n)) &#123;<br>            res.add(n);<br>            n = getNextNumber(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNextNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">10</span>;<br>            res += temp * temp;<br>            n = n / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="LC1-two-sum"><a href="#LC1-two-sum" class="headerlink" title="LC1 two sum"></a>LC1 two sum</h1><p><a href="https://leetcode.cn/problems/two-sum/">Question</a>  </p><p>Have done so many times bcs it is the first question of leetcode. It can be solved by <strong>two-pointer</strong> and <strong>HashMap</strong>. The solution of two-pointer is <a href="nsum.md">here</a>. Now is the <strong>HashMap</strong> solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Map&lt;Integer,Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(set1.containsKey(target-nums[i]))&#123;<br>                val = set1.get(target-nums[i]);<br>                res[<span class="hljs-number">0</span>] = val;<br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            set1.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/">Basics of Hash Tables</a></li><li><a href="https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">ProgrammerCarl</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CarlDay3,4 | LC203 Remove Nth Node From End of List, LC707Design Linked List, LC206 Reverse Linked List,</title>
    <link href="/2023/02/20/CarlDay3&amp;4/"/>
    <url>/2023/02/20/CarlDay3&amp;4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linked List related.<br><span id="more"></span></p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>LinkedList is a simple but important data structure. we usually use two-pointer, recursion to handle those problems. </p><h2 id="LC203-Remove-Linked-List-Elements"><a href="#LC203-Remove-Linked-List-Elements" class="headerlink" title="LC203 Remove Linked List Elements"></a>LC203 Remove Linked List Elements</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">Question</a><br>For a linklist, if we want to remove an element, we should use the code <code>node.next = node.next.next</code>. In this question, what we should notice is that, we need a <strong>dummy node</strong> to record the result, so that we can handle all the nodes in same way. If not, when we want to remove head node, there is no former nodes to execute <code>node.next = node.next.next</code><br>Here is the solution<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java">   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    dummy.next = head;<br>    <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(cur.next.val == val)&#123;<br>            cur.next = cur.next.next;<br>        &#125;<span class="hljs-keyword">else</span><br><br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC707-Design-Linked-List"><a href="#LC707-Design-Linked-List" class="headerlink" title="LC707 Design Linked List"></a>LC707 Design Linked List</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">Question</a><br>using dummy node to handle the head<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br>    <span class="hljs-type">int</span> size;<br>    ListNode head;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLinkedList</span><span class="hljs-params">()</span> &#123;<br>        size = <span class="hljs-number">0</span>;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(<span class="hljs-number">0</span>, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        addAtIndex(size, val);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        index = Math.max(<span class="hljs-number">0</span>, index);<br>        size++;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">toAdd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(val);<br>        toAdd.next = pred.next;<br>        pred.next = toAdd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        size--;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pred = pred.next;<br>        &#125;<br>        pred.next = pred.next.next;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="LC-206-Reverse-Linked-List"><a href="#LC-206-Reverse-Linked-List" class="headerlink" title="LC 206 Reverse Linked List"></a>LC 206 Reverse Linked List</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">Question</a><br>This is the most typical recursive topic, which can show the power of recursive methods. When we using recursive method, we should not be stunk by every recurve, we just need to know the result of the recur. Here is the solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>       head.next.next = head;<span class="hljs-comment">// Illustrate by later figure</span><br>       head.next = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">return</span> last;<br>   &#125;<br></code></pre></td></tr></table></figure><br><img src="/img/reverseLinkedList.jpeg" alt="figure"></p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="LC-24-Swap-Nodes-in-Pairs"><a href="#LC-24-Swap-Nodes-in-Pairs" class="headerlink" title="LC 24 Swap Nodes in Pairs"></a>LC 24 Swap Nodes in Pairs</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">Question</a><br>In this case we can consider the recursive method. Identify the base case and swap <code>head</code> and <code>head.next</code>. Then let <code>head</code> point to the result of <code>reverse(head.next.next)</code> .Plot the process for better understanding.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<span class="hljs-comment">//base case</span><br><br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> head.next.next;<br>    <br>    second.next = head;<br><br>    head.next = swapPairs(left);<br><br>    <span class="hljs-keyword">return</span> second;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><img src="/img/lc24.jpeg" alt="lc24"></p><h2 id="LC-19-Remove-Nth-Node-From-End-of-List"><a href="#LC-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="LC 19 Remove Nth Node From End of List"></a>LC 19 Remove Nth Node From End of List</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">Question</a><br>This is a two-pointer problem. After considering the base case, we can use a fast pointer and a slow pointer. After the fast pointer moves n times, the slow pointer starts to move. When the fast pointer points to the last position, the next node of the slow pointer is the node to be deleted.<br><strong>Remind, using dummy node to handle the list</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>           ListNode slow, fast;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>           dummy.next = head;<br><br>           slow = dummy;<br>           fast = dummy;<br><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n;i++)&#123;<br>               fast = fast.next;<br>           &#125;<span class="hljs-comment">//fast fowards n nodes</span><br><br>           <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span>)&#123;<br>               fast = fast.next;<br>               slow = slow.next;<br>           &#125;<span class="hljs-comment">// foward both pointers</span><br><br>            slow.next = slow.next.next;<span class="hljs-comment">//delete</span><br><br>            <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC-160-Intersection-of-Two-Linked-Lists-LCCI"><a href="#LC-160-Intersection-of-Two-Linked-Lists-LCCI" class="headerlink" title="LC 160  Intersection of Two Linked Lists LCCI"></a>LC 160  Intersection of Two Linked Lists LCCI</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">Question</a><br>Use two pointers to traverse from AB respectively, connect another linked list when the traversal is completed, and end when the two pointers meet, and it is an intersecting node<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>   <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-comment">// P1 takes steps, if it reaches the end of A linked list, go to B linked list</span><br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>           <br>         p1 = p1.next;<br>        <span class="hljs-comment">// so as p1</span><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            <br>        p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="LC-142-Linked-List-Cycle-II"><a href="#LC-142-Linked-List-Cycle-II" class="headerlink" title="LC 142 Linked List Cycle II"></a>LC 142 Linked List Cycle II</h2><p><a href="./linkedarray.md">Wrote before</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Carl Algorithm day1,2 | LC 704 Binary Search, LC27 Remove element, LC977 Squares of a Sorted Array, LC209 Minumum size subarray sum, LC59 Spiral Matrix II</title>
    <link href="/2023/02/16/CarlDay1&amp;2/"/>
    <url>/2023/02/16/CarlDay1&amp;2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1,2 day of Carl’s  Algorithm training. Array related<br><span id="more"></span></p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="BG"><a href="#BG" class="headerlink" title="BG"></a>BG</h2><ul><li>Arrary: a collection of elements, each identified by at least one array index or key. It is stored at continuous memory addresses.  </li><li>two dimension array<ul><li>first index is row, second is col</li><li>a[0][1] : 1st row, 2nd col</li></ul></li></ul><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>In fact, Binary search is one tye of two-pointer, what we should od it judge the end of while loop, it is important to handle the statement of while, &lt;= or &lt;. Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//prevent int from overflow</span><br><br>          <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>              <span class="hljs-comment">// here is what we will do to teh target</span><br>              <span class="hljs-keyword">return</span> mid;<br>          &#125;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>              right = mid - <span class="hljs-number">1</span>;<br>          &#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>              left = mid + <span class="hljs-number">1</span>;<br><br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></p><h2 id="Remove-element"><a href="#Remove-element" class="headerlink" title="Remove element"></a>Remove element</h2><p>Its a two pointers methods as will.  What we should focus on is <strong>in-place</strong> which means we can’t create a new array to store the  array. So, we can set a fast pointer and a slow pointer, if the fast one doesn’t meet the value, set slow to nums[fast], move slow, move fast.<br>Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast &lt; nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != val)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>            fast ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="LC977-Squares-of-a-Sorted-Array"><a href="#LC977-Squares-of-a-Sorted-Array" class="headerlink" title="LC977 Squares of a Sorted Array"></a>LC977 Squares of a Sorted Array</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">Question</a><br>Noticed  that it is a non-decreasing order array, so the absolute of the left and right are larger than the middle, so we can use the Math.abs() to judge which is larger. Then utilize two-pointer one is <em>left</em> and one is <em>right</em>, the create a result array to store the result.<br>Here is the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortedSquares(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> [] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-keyword">if</span>(Math.abs(nums[left]) &lt; Math.abs(nums[right]))&#123;<br>            res[p] = nums[right] * nums[right];<br>            right--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res[p] = nums[left] * nums[left];<br>            left++;<br>        &#125;<br>        p--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="LC209-Minumum-size-subarray-sum"><a href="#LC209-Minumum-size-subarray-sum" class="headerlink" title="LC209 Minumum size subarray sum"></a>LC209 Minumum size subarray sum</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">Question</a><br>Description: Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.  </p><p>In this question, it is a type of <strong>Sliding-window</strong> method. The most important thing in Sliding window is identifying the start position.<br>The main procedure of sliding windown is </p><ol><li>set the start position</li><li>enlarge the window size </li><li>according to the condition, judge whether should we shrink the window.</li><li>maintain the window and keep process</li></ol><p>In this question, what we should not is we need a variable <em>res</em> to store the result, we can set it as <em>Math.MAX_VALUE</em>, and in this way, we can update the <em>res</em> by compare the value of <em>res</em> and window size<br>Here is the code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++)&#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>                result = Integer.min(result,right-left+<span class="hljs-number">1</span>);<br>                <br>                sum -=nums[left];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result == Integer.MAX_VALUE? <span class="hljs-number">0</span>:result;<br>        &#125;<br></code></pre></td></tr></table></figure><p>For the retrun thing, we use the <code>result == Integer.MAX_VALUE? 0:result</code> to judge whether the sum of all values in nums is larger than target. if not, return 0</p><h2 id="LC59-Spiral-Matrix-II"><a href="#LC59-Spiral-Matrix-II" class="headerlink" title="LC59 Spiral Matrix II"></a>LC59 Spiral Matrix II</h2><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">Question</a><br>It is a design question, what we should do is simulating a clockwise cycle. It is not very difficult but the details are annoying. Here is the solution.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> [][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, down = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(num &lt;= n * n)&#123;<span class="hljs-comment">//end case is maximum value of loop</span><br>            <span class="hljs-keyword">if</span>(up &lt;= down)&#123;<span class="hljs-comment">// from left to right</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left;i &lt;= right;i++)&#123;<br>                    res[up][i] = num++;<br>                &#125;<br>                up++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<span class="hljs-comment">//right size, from top to down</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> up;i &lt;= down;i++)&#123;<br>                    res[i][right] = num++;<br>                &#125;<br>                right--;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(up &lt;= down)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--)&#123;<br>                    res[down][i] = num++;<br>                &#125;<br>                down--;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left &lt;= right)&#123;<span class="hljs-comment">// ri</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> down; i &gt;= up; i--)&#123;<br>                    res[i][left] = num++;<br>                &#125;<br>                left++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3rd lecture of 7CCEMMLE Machine Learning</title>
    <link href="/2022/10/08/MLLec2/"/>
    <url>/2022/10/08/MLLec2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><p><p>Chapter 3 of Machine Learning. This lecture discuss the loss function, population loss, optimal hard&#x2F; soft predictors, log-loss, cross-entropy loss and cross entropy, entropy and conditional entropy, KL divergence, and mutual information.</p><br><span id="more"></span></p><p><h1 id="Defining-Inference-推理"><a href="#Defining-Inference-推理" class="headerlink" title="Defining Inference(推理)"></a>Defining Inference(推理)</h1><ul></p><li>In inference problems we got two types variables: <ul><li>input</li><li>output, or target</li><li>A model is given by $p(x,t)$</li><p><h2 id="Two-kinds-of-inference"><a href="#Two-kinds-of-inference" class="headerlink" title="Two kinds of inference"></a>Two kinds of inference</h2><ul></p><li>detection problems:  takes value in a discrete and finite set</li><li>estimation problems: target is continuous</li><p><h3 id="predictor"><a href="#predictor" class="headerlink" title="predictor"></a>predictor</h3><p>two types:</p></p><ul><li>Hard predictor: specifies a single predicted value $\hat t$ of t for every value of x$&#x3D; x$<ul><li>$\hat t(x)$</li><li>x &#x3D; 0, $\hat{t}&#x3D;0$</li></ul></li><li>soft predictor：specifies a “score” for each possible value of $t$ given  $x&#x3D;x$<ul><li>$q(t|x)$</li><li>when x &#x3D; 0, output distribution (0.8,0.2) 分别为t&#x3D;0或者t&#x3D;1 –&gt; $q(1|0) &#x3D; 0.2$<br>Example:<br><img src="/./img/predictortype.png" srcset="/img/loading.gif" lazyload alt="eg"></li></ul></li></ul><h1 id="Optimal-soft-prediction-or-Bayesian-inference"><a href="#Optimal-soft-prediction-or-Bayesian-inference" class="headerlink" title="Optimal soft prediction, or Bayesian inference"></a>Optimal soft prediction, or Bayesian inference</h1><ul><li><p>A natural choice for the soft predictor $q(t|x)$ of t given $x &#x3D; x$ is the posterior distribution $p(t|x)$.</p></li><li><p>With this choice, the “score” q(t|x) assigned to each value of t is its posterior probability given x &#x3D; x.  </p><h2 id="calculation"><a href="#calculation" class="headerlink" title="calculation"></a>calculation</h2><p>  pmf:</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.45</td><td>0.05</td></tr><tr><td>1</td><td>0.1</td><td>0.4</td></tr></tbody></table></li><li><p>Given pmf $p(x,t)$</p></li><li><p>calculate the posterior $p(t|x)$</p><table><thead><tr><th>x\t</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.9</td><td>$\frac{0.05}{(0.45+0.05)&#x3D;0.1}$</td></tr><tr><td>1</td><td>0.2</td><td>0.8</td></tr></tbody></table></li><li><p>got the Bayesian soft predictor as<br>$$<br>(t|x&#x3D;0) ~ q(t|0) &#x3D; p(t|0) &#x3D; Bern(t|x)<br>$$<br>and<br>$$(t |x&#x3D;1)~q(t|1) &#x3D; p(t|1) &#x3D; Bern(t|0.8)<br>$$</p></li><li><p>conclusion<br>Ifx&#x3D;0,we can offer the hard prediction $\hat{t}(0) &#x3D; 0$ with associated probability of error of 0.1</p><h1 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h1></li><li><p>to measure the quality of hard prediction $\hat t$, we introduce the loss function $L(t,\hat{t})$</p></li><li><p>$L(t,\hat{t}) &#x3D; 0$ if $t &#x3D; \hat{t}$ </p></li><li><p>For estimation, </p><ul><li>we use $L_k$ loss for integer $k&gt;0$, def as<br>$$<br>L(t,\hat{t}) &#x3D; L_k(t,\hat{t}) &#x3D; |t-\hat{t}|^k<br>$$<ul><li>k &#x3D; 2 normally</li></ul></li></ul></li><li><p>for detection </p><ul><li>0-1 loss, indicator</li></ul></li></ul><p>$$<br>I(a) &#x3D; \begin{cases}<br>1&amp; \text{if a &#x3D; true }\<br>0&amp; \text{if a &#x3D; false}\<br>\end{cases}<br>$$</p><h1 id="Population-loss"><a href="#Population-loss" class="headerlink" title="Population loss"></a>Population loss</h1><ul><li>for given predictor $\hat{t}(·)$, we define population loss as<br>$$<br>L_p(\hat{t}(·)) :&#x3D; E_{(x,t)～p(x,t)}[L(t,\hat{t})]<br>$$</li><li>it is the average lose over the joint distribution of input and target  </li><li>对loss函数取个平均值</li><li>For detection-error loss</li></ul><p>(:&#x3D;的意思是，左边的东西被定义为右边)  </p><p>for a loss functiom, <strong>optimal hard predictor</strong> minimizes the <strong>population loss</strong>.<br>$$<br>\hat t^* (·) :&#x3D; arg min_{\hat t(·)}{L_p(\hat t(·))} &#x3D; E[l(t,\hat t(x))]<br>$$</p><h2 id="Population-detection-error-loss"><a href="#Population-detection-error-loss" class="headerlink" title="Population detection-error loss"></a>Population detection-error loss</h2><ul><li>def: the prob of detection error.<br>$$<br>Pr_{(x,t)<del>p(x,t)}[t\neq\hat t(x)]&#x3D;1-Pr_{(x,t)</del>p(x,t)}[t&#x3D;\hat t(x)]&#x3D;1-\sum_p(x,\hat t(x))<br>$$</li></ul><h1 id="Optimal-Hard-Predictor"><a href="#Optimal-Hard-Predictor" class="headerlink" title="Optimal Hard Predictor"></a>Optimal Hard Predictor</h1><ul><li><p>def: an optimal hard predictor minimizes the populationloss</p><p>$$<br>\hat{t^\star(·)} :&#x3D; arg\space min_{\hat{t}^(·)}{L_p(\hat t^*(·) )}&#x3D;E_{(x,t)\sim p(x,t)}[l(t,\hat t(x))]<br>$$</p></li></ul><p>means: the “argument” that <strong>minimizes</strong> the function in<br>the brackets, that is, the minimizer of this function.</p><ul><li>for any given loss function l, the optimal predictor can be directly computed from the <strong>posterior distribution</strong><br>$$<br>p(t|x)&#x3D;\frac{p(x,t)}{p(x)}<br>$$<br>也就是说能用optimal soft predictor来获得</li></ul><p>$$\hat{t^\star(·)}&#x3D;arg\space min_{\hat t \in{0,1}}E_{t\sim p(t|x)}[l(t,\hat t)]$$</p><h2 id="Optimal-Hard-Prediction-Under-Detection-Error-Loss"><a href="#Optimal-Hard-Prediction-Under-Detection-Error-Loss" class="headerlink" title="Optimal Hard Prediction Under Detection-Error Loss"></a>Optimal Hard Prediction Under Detection-Error Loss</h2><ul><li>the optimal predictor is the maximum of the posterior distribution, i.e.the posterior mode<br>$$<br>\hat{t^\star(x)} &#x3D; arg\space max_{t}p(t|x)<br>$$<br>it is maximum a posterior(MAP)<h2 id="Under-l-2-Loss"><a href="#Under-l-2-Loss" class="headerlink" title="Under $l_2$ Loss"></a>Under $l_2$ Loss</h2></li><li>the optimal hard predictor is the posterior mean, that is, the mean of the posterior distribution</li></ul><h1 id="Cross-Entropy-Loss"><a href="#Cross-Entropy-Loss" class="headerlink" title="Cross-Entropy Loss"></a>Cross-Entropy Loss</h1><p><strong>熵：用来衡量事物的不确定性</strong>，熵越大，信息量越大，是五月不确定，事物越复杂</p><ul><li>assign a loss to soft predictor –&gt; measure how good it is </li><li>To measure the loss of the soft predictor q(t|x) on a pair$(x,t)$<br>using<br> $$l&#x3D;-log q(t|x)$$</li></ul><p><img src="/./img/loglossplot.png" srcset="/img/loading.gif" lazyload alt="plot"></p><ul><li>large when predictor gives low probability to the correct output t given x, which measere the <strong>“superise”</strong></li><li>if t is discrete, the score is constrained in the itnerval[0,1]</li><li>can be negative when t is continuous</li><li>log-loss is used to compare different predictors<h2 id="Population-log-loss"><a href="#Population-log-loss" class="headerlink" title="Population log-loss"></a>Population log-loss</h2>an optimal soft predictor can then be obtained by minimizing the population log-loss<br>$$<br>min_{q(·|·)}{L_p(q(·|·))}&#x3D;E_{(x,t)\sim p(x,t)}[-log q(t|x)]<br>$$</li><li>it the cross entropy between $p(t)$ and $q(t)$</li><li>only for soft predictor and depends on the entire soft predictor q(t|x) obtained by considering all values of x and t<br>$$<br>L_p(q(·))&#x3D;H(p,q)<br>$$</li><li>这反映了 divergence between distribution p and q</li><li>if p &#x3D; q, minimizes the population log-loss</li></ul><h1 id="KL-divergence-kl散度，相对熵"><a href="#KL-divergence-kl散度，相对熵" class="headerlink" title="KL divergence (kl散度，相对熵)"></a>KL divergence (kl散度，相对熵)</h1><p><strong>一个用来衡量两个概率分布的相似性的一个度量指标</strong>，随机分布相同时，为0。<br>$$<br>KL(p||q) &#x3D; E_{t \sim p(t)}[log{\frac{p(t)}{q(t)}}]<br>$$<br><img src="/./img/LLR.png" srcset="/img/loading.gif" lazyload alt="LLR"></p><ul><li>The KL divergence is generally asymmetric<ul><li>$KL(p||q) \neq KL(q||p)$</li></ul></li><li>LLR 越大则分布越不同<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2></li><li>binomial distribution<br><img src="/./img/KLeg.png" srcset="/img/loading.gif" lazyload alt="KLeg"></li><li>normal distribution<br><img src="/./img/normeg.png" srcset="/img/loading.gif" lazyload alt="normeg"><h2 id="relationship-between-Cross-entropy-and-KL"><a href="#relationship-between-Cross-entropy-and-KL" class="headerlink" title="relationship between Cross entropy and KL"></a>relationship between Cross entropy and KL</h2>KL div can be expressed as<br>$$<br>H(p,q):&#x3D;E_{t\sim p(t)}[-log(t)]<br>$$<br>which can have the equality<br>$$<br>KL(p||q)&#x3D;H(p,q)-H(p,p)<br>$$<h1 id="Differential-Entropy"><a href="#Differential-Entropy" class="headerlink" title="Differential Entropy"></a>Differential Entropy</h1></li><li>For Gaussian rv $t\sim N(\mu,\sigma ^2)&#x3D;\frac{1}{2}log(2\pi e\sigma^2)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec4</title>
    <link href="/2022/10/05/TeleLec4/"/>
    <url>/2022/10/05/TeleLec4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><p><h1 id="LAN-Local-Area-Networks-局域网"><a href="#LAN-Local-Area-Networks-局域网" class="headerlink" title="LAN(Local Area Networks 局域网)"></a>LAN(Local Area Networks 局域网)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>LAN 里的每个成员都会收到任意一个成员发出的广播包，so如果想要通讯，必须获取对方的MAC地址（通过 ARP协议）。</p></p><p><ul></p><p><li><p>Characteristic </p></p><p><ul></p><p><li>scope small </li></p><p><li>high data rate</li></p><p><li>shared broadcast medium</li></p><p><li>under single management</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Facts </p></p><p><ul></p><p><li>protocol : MAC, LLC</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="IEEE-802-layers"><a href="#IEEE-802-layers" class="headerlink" title="IEEE 802 layers"></a>IEEE 802 layers</h2><p><img src="/./img/802.png" srcset="/img/loading.gif" lazyload alt="对比"><br>LLC 和MAC 对应了 OSI的data link, 也就是说只有下面三个parts和medium属于802可以约束的范围</p></p><p><h3 id="Physical-layer"><a href="#Physical-layer" class="headerlink" title="Physical layer"></a>Physical layer</h3><ul></p><p><li>Encoding&#x2F;Decoding of signals.</li></p><p><li>Preamble generation&#x2F;removal (synchronization).</li></p><p><li>Bit transmission&#x2F;reception.</li></p><p><li>Spec. of medium, topology<ul></p><p><li>topology: bus, ring, star<br><img src="/./img/LANTop.png" srcset="/img/loading.gif" lazyload alt="topologies"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="MAC-Medium-Access-Control-sublayer"><a href="#MAC-Medium-Access-Control-sublayer" class="headerlink" title="MAC(Medium Access Control sublayer)"></a>MAC(Medium Access Control sublayer)</h3><ul></p><p><li>framing, addressing, error detection</li></p><p><li>access to shared medium</li><br>&lt;/ul&gt;</p><p><h3 id="Logical-Link-Control-sublayer"><a href="#Logical-Link-Control-sublayer" class="headerlink" title="Logical Link Control sublayer"></a>Logical Link Control sublayer</h3><ul></p><p><li>interface to higher layers</li></p><p><li>flow and error control</li></p><p><li><h4 id="for-802-2"><a href="#for-802-2" class="headerlink" title="for 802.2"></a>for 802.2</h4></li></p><p><li>Provides a compatibility interface, irrespective of the MAC layer used.</li></p><p><li>Provides flow and error control services</li><br>&lt;/ul&gt;</p><p><h2 id="Multiple-access-protocols"><a href="#Multiple-access-protocols" class="headerlink" title="Multiple-access protocols"></a>Multiple-access protocols</h2><p><img src="/./img/MACprotocols.png" srcset="/img/loading.gif" lazyload alt="MACprotocols">  </p></p><p><h2 id="Random-access"><a href="#Random-access" class="headerlink" title="Random access"></a>Random access</h2><p>在随机接入协议中，一个传输节点总是以信道的全部速率（即Rbps)进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止  </p></p><p><p><em>这一部分要会计算</em>  </p></p><p><h3 id="aloha"><a href="#aloha" class="headerlink" title="aloha"></a>aloha</h3><p>Aloha 有两种，一个是纯aloha一个是slotted aloha，也就是时隙aloha  </p></p><p><ul></p><p><li><p>Pure aloha</p></p><p><ul></p><p><li>任何一个站在framing之后可以立即发送，但是看你会出现collision, 在监听时，等待ACK的时间等于round-trip传播时间。<br>最大利用率只有 $\frac{1}{2e}&#x3D;18%$,此时G&#x3D;1&#x2F;2</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>slotted aloha</p></p><p><ul></p><p><li>slot &#x3D; L&#x2F;R,一个时隙(时间片)等于传输一帧的时间</li></p><p><li>如果有frame要发<strong>it must wait for slot boundary</strong>, trans at the starting</li></p><p><li>如果有碰撞，<strong>该节点在时间片结束之前检测到这次碰撞</strong>。该节点<strong>以概率</strong>在后续的每个时间片中重传它的帧，直到该帧被无碰撞地传输出去。</li></p><p><li>一个给定节点成功传输的概率为$p(1-p)^{n-1}$。N个节点成功的概率为$Np(1-p)^{n-1}$</li></p><p><li>Maximum utilization&#x3D;1&#x2F;e&#x3D;37%</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p><img src="/./img/slottedAloha.png" srcset="/img/loading.gif" lazyload alt="slottedAloha"></p></p><p><h4 id="LAN-performance-计算"><a href="#LAN-performance-计算" class="headerlink" title="LAN performance 计算"></a>LAN performance 计算</h4><h3 id="CSMA-listen-before-talking"><a href="#CSMA-listen-before-talking" class="headerlink" title="CSMA (listen before talking)"></a>CSMA (listen before talking)</h3><p>cs的意思就是发送一个载波监听是否idle</p></p><p><ul></p><p><li><p>Non-persistent:<br><img src="/./img/CSMA.png" srcset="/img/loading.gif" lazyload alt="non"><br> but the capacity is wasted</p></li></p><p><li><p>1-persistent</p></p><p><ul></p><p><li>when medium is busy, **continue to listen **until channel is sensed idle</li></p><p><li></li></ul></li></p><p><li><p>p-persistent</p></p><p><ul></p><p><li>if idle-&gt;transmit with probability p and delay <strong>one time unit</strong> with (1-p)</li></p><p><li>when medium is busy, <strong>continue to listen</strong> until channel is idle</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><table></p><p><thead></p><p><tr></p><p><th></th></p><p><th>non-persistent</th></p><p><th>1-persistent</th></p><p><th>p-persistent</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p><p><tbody><tr></p><p><td>idle</td></p><p><td>asap</td></p><p><td>asap</td></p><p><td>p asap,(1-p) wait for next slot</td><br>&lt;/tr&gt;</p><p><tr></p><p><td>busy</td></p><p><td>stop listening, re-listen after a random time</td></p><p><td>keep listening</td></p><p><td>stop listening, re-listen after a random time</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;&lt;/table&gt;</p><p><h3 id="CSMA-x2F-CD-collision-detection"><a href="#CSMA-x2F-CD-collision-detection" class="headerlink" title="CSMA&#x2F;CD (collision detection)"></a>CSMA&#x2F;CD (collision detection)</h3><p>变发送边监听，半双工  </p></p><p><ul></p><p><li><p>process: </p></p><p><ul></p><p><li>1,2 和1-persistent一样</li></p><p><li>3.if collision detected<ul></p><p><li>Transmit a jam signal for one slot.</li></p><p><li>Wait for a random time and reattempt (up to 16 times).</li></p><p><li>Random time generated according to (exponential backoff algorithm):<ul></p><p><li>If a packet is collided n times, where n &lt; 16, then the node waits for $T &#x3D; x \times 512$ bit period. Where $K &#x3D; uniform[0, 2^m − 1]$ , and $m &#x3D; Min[10 , n]$ .</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><ol start="4"></p><p><li>Collision is detected by monitoring the voltage, high voltage</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li><p>Problems</p></p><p><ol></p><p><li>Collisions of frames leads to** unpredictable delays**.</li></p><p><li>Minimum packet size required (wasteful of BW in case of many short messages). </li></p><p><li>Poor performance under very heavy load.</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="IEEE-802-3-Frame-format"><a href="#IEEE-802-3-Frame-format" class="headerlink" title="IEEE 802.3 Frame format"></a>IEEE 802.3 Frame format</h3><p><img src="/./img/8023frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h2><p>Star, bus, ring</p></p><p><h3 id="Star-LANs"><a href="#Star-LANs" class="headerlink" title="Star LANs"></a>Star LANs</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><ul></p><p><li>Active central element referred to as hub.</li></p><p><li>Stations connects to the hub by <strong>two twisted pair wires</strong>.</li></p><p><li>Hub acts as a repeater, <strong>repeats signal from a station on outgoing links of all stations</strong>.</li></p><p><li>If two stations transmit at the same time -&gt; collision.</li></p><p><li>Physically a star, logically a bus connection</li></p><p><li>Multiple levels of hops can cascaded in a hierarchical configuration (can build very large networks).</li><br>&lt;/ul&gt;</p><p><p><img src="/./img/busvsstar.png" srcset="/img/loading.gif" lazyload alt="busvsstar"></p></p><p><h3 id="Ring-topology"><a href="#Ring-topology" class="headerlink" title="Ring topology"></a>Ring topology</h3><ul></p><p><li>Network consist of set of repeaters.</li></p><p><li>Repeaters are connected by point to point links.</li></p><p><li>Unidirectional link.</li></p><p><li>Data is transferred from one repeater to next.</li></p><p><li>Repeaters perform <strong>data insertion, reception, and removal.</strong></li></p><p><li>if not data removal <ul></p><p><li>by sender:<ul></p><p><li>used as an ack</li></p><p><li>enable multicasting</li></p><p><li>more fair transmission scenario<br><img src="/./img/star.png" srcset="/img/loading.gif" lazyload alt="star"></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Token-ring"><a href="#Token-ring" class="headerlink" title="Token ring"></a>Token ring</h3><p>很有趣的一个拓扑  </p></p><p><ul></p><p><li><p>会有一个token circulate around ring</p></li></p><p><li><p>all station idle-&gt;token is free</p></li></p><p><li><p>station只有检测到free token的时候才能传输，其他station必须等</p></li></p><p><li><p>The station then appends and transmits the remainder of the field to make a data frame.</p></li></p><p><li><p>station will insert a <strong>new free token</strong> after transmitting</p></li></p><p><li><p>什么时候release token</p></p><p><ul></p><p><li>You have to finish your transmission and the leading edge has to return</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><p>总的来说，token像一把钥匙，谁要发送msg就需要占用token，发送的信息会发往所有的station但是只会被 dest station <strong>复制</strong>，然后传回src station之后将其删除，然后重新生成一个新的token</p></p><p><h4 id="frame-format"><a href="#frame-format" class="headerlink" title="frame format"></a>frame format</h4><p><img src="/./img/8024frame.png" srcset="/img/loading.gif" lazyload alt="frame"></p></p><p><h2 id="LAN-performance"><a href="#LAN-performance" class="headerlink" title="LAN performance"></a>LAN performance</h2><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><ul></p><p><li>The probability that a station attempts to transmit in a slot is $P$</li></p><p><li>$A$ is the probability that some station can send a transmit in a slot successfully, and is given by:<br> $$<br>A &#x3D; NP(1-P)^{N-1}<br>$$</li><br>&lt;/ul&gt;</p><p><h3 id="Token-rings"><a href="#Token-rings" class="headerlink" title="Token rings"></a>Token rings</h3><ol></p><p><li><p>when$t_{tr} \geq t_{prop}$</p></p><p><p>  $S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{1+\frac{a}{N}}$<br>where $a &#x3D; \frac{t_{prop}}{t_{tr}}$  </p><br>&lt;/li&gt;</p><p><li><p>when $t_{tr} &lt;  t_{prop}$<br>$S&#x3D;\frac{t_{tr}}{t_{total}} &#x3D; \frac{1}{a+\frac{a}{N}}$</p></li><br>&lt;/ol&gt;</p><p><h3 id="LAN-address-MAC-address"><a href="#LAN-address-MAC-address" class="headerlink" title="LAN address(MAC address)"></a>LAN address(MAC address)</h3><ul></p><p><li>a bytes long, unique address, </li></p><p><li>won’t change when the adapter moves</li></p><p><li>Mapped to IP address using ARP</li><br>&lt;/ul&gt;</p><p><h3 id="repeaters-bridges-routers"><a href="#repeaters-bridges-routers" class="headerlink" title="repeaters,bridges, routers"></a>repeaters,bridges, routers</h3><ul></p><p><li>repeater<ul></p><p><li>physical layer</li></p><p><li>extend physical length</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>bridge<ul></p><p><li>connects similar LANs</li></p><p><li>identical physical and link layer protocols</li></p><p><li>why<ul></p><p><li>reliability: several self-contained units</li></p><p><li>performance </li></p><p><li>security: isolate info on separate LANs</li></p><p><li>geography: connect LANs at diff locations</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/li&gt;</p><p><li>router<ul></p><p><li>interconnect various LANs and WANs</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h3 id="Address-learning"><a href="#Address-learning" class="headerlink" title="Address learning"></a>Address learning</h3><p>会就行</p></p><p><h3 id="wireless-LANs"><a href="#wireless-LANs" class="headerlink" title="wireless LANs"></a>wireless LANs</h3><br>            &lt;/div&gt;</p>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TeleLec1&amp;2</title>
    <link href="/2022/09/28/TeleLec1/"/>
    <url>/2022/09/28/TeleLec1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本来以为这个课是小通原，还寻思又要被折磨了，结果发现是小计网，还是经典的不讲应用层的计网。  </p></p><p><h2 id="data-communications-vs-Network"><a href="#data-communications-vs-Network" class="headerlink" title="data communications vs Network"></a>data communications vs Network</h2><ul></p><p><li>communications: between 2 nodes. Only care the turnel</li></p><p><li>network: many nodes and links. No need link all nodes. take routing, addressing,congestion control into consideration.</li><br>&lt;/ul&gt;</p><p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><ul></p><p><li>def: millions of connected computing devices<ul></p><p><li>host: end systems</li></p><p><li>links:fiber,copper,ratio</li></p><p><li>packet switches: forward packets. <strong>routers and switches</strong></li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p><p><h2 id="type-of-networks"><a href="#type-of-networks" class="headerlink" title="type of networks"></a>type of networks</h2><h3 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast:"></a>broadcast:</h3><ul></p><p><li>eg. bus mode–&gt; one can c others information</li><br>&lt;/ul&gt;</p><p><h3 id="swtiched-Networks"><a href="#swtiched-Networks" class="headerlink" title="swtiched Networks"></a>swtiched Networks</h3><h4 id="circuit-switched-Networks"><a href="#circuit-switched-Networks" class="headerlink" title="circuit-switched Networks"></a>circuit-switched Networks</h4><ul></p><p><li>a blocked network.</li></p><p><li>eg. old wired telephone. *end-end resources reserved.</li></p><p><li>link bandwidth, switch capacity.</li></p><p><li>dedicated resources</li><br>&lt;/ul&gt;</p><p><h3 id="packet-switched-network-non-blocking-network"><a href="#packet-switched-network-non-blocking-network" class="headerlink" title="packet switched network (non blocking network)"></a>packet switched network (non blocking network)</h3><ul></p><p><li>Each end-end data stream divided into <em>packets</em></li></p><p><li>no block but will delay till overflow. packet wait at router for output link</li><br>&lt;/ul&gt;</p><p><h4 id="virtual-circuit-vs-datagram-networks"><a href="#virtual-circuit-vs-datagram-networks" class="headerlink" title="virtual circuit vs datagram networks"></a>virtual circuit vs datagram networks</h4><ul></p><p><li><p>same goal: move packets tamgoung routers from src to dest</p></li></p><p><li><p>datagram: </p></p><ul><li>destination address determines next hop.</li><li>坐车时告诉司机目的地但是不一定nevigate路线，asking directions 所以 routes may change during session (取决于router的算法)</li><li></li></ul></li><li><p>virtual circuit</p><ul><li>has the map. tag determines next hop</li><li>fixed path determined at <strong>setup time</strong></li></ul></li></ul><h2 id="Loss-and-delay"><a href="#Loss-and-delay" class="headerlink" title="Loss and delay"></a>Loss and delay</h2><ul><li>loss:packet arrival rate to link (temporarily) exceeds output link capacity</li></ul><h3 id="type-of-delay"><a href="#type-of-delay" class="headerlink" title="type of delay"></a>type of delay</h3><ul><li>processing delay: negletive</li><li>queuing delay：$La&#x2F;R$, R-&gt;link bandwidth, a-.average packet arrival rate</li><li>transmission delay: 收费站排队进站.$t &#x3D; \frac{L}{R}$, R&#x3D;link bandwidth(bps), L &#x3D; packets(bits)</li><li>propagation delay: 开车时间, $delay &#x3D; \frac{d}{s}$</li></ul><h2 id="Portocol"><a href="#Portocol" class="headerlink" title="Portocol"></a>Portocol</h2><ul><li>def:set of rules governing the exchange of data between two entities in a system</li><li>Entities: users app, email facilities</li><li>Systems: computers, terminals, remote sensors</li><li>Protocol architectures: communication task broken up into modules<h3 id="Layerd-Network-Architecture"><a href="#Layerd-Network-Architecture" class="headerlink" title="Layerd Network Architecture"></a>Layerd Network Architecture</h3></li><li>define the commmunications abstractions defined by <strong>standardization bodies</strong></li><li>Layer N uses only service of Layer N-1, and only provides services to N+1</li></ul><h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><ul><li>Control information is added to user data at each layer, add control inftomation(header) to data at each layer—&gt;封装</li><li>includ: destination SAP</li><li>Sequence number </li><li>Error detection code</li></ul><h3 id="TCP-x2F-IP-model-stack"><a href="#TCP-x2F-IP-model-stack" class="headerlink" title="TCP&#x2F;IP  model stack"></a>TCP&#x2F;IP  model stack</h3><p><img src="/img/teleTCPIPmodel.png" srcset="/img/loading.gif" lazyload alt="TCPIPmodel"></p><h2 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h2><p><img src="/img/teleEncap.png" srcset="/img/loading.gif" lazyload alt="encapsulation"></p><h1 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h1><h2 id="terminology"><a href="#terminology" class="headerlink" title="terminology"></a>terminology</h2><ul><li>Data transmission occurs between <strong>transmitter</strong> and <strong>receiver</strong> over some <strong>transmission medium</strong></li><li>Simplex: <strong>one direction</strong>,eg: TV</li><li>Half duplex: both transmit but not at a time. use full bandwidth</li><li>Full duplex: both dir, simultaneously</li></ul><h2 id="Analog-and-Digital-Data-Transmission"><a href="#Analog-and-Digital-Data-Transmission" class="headerlink" title="Analog and Digital Data Transmission"></a>Analog and Digital Data Transmission</h2><ul><li><p>advantages: cheaper and less susceptible to noise interference</p></li><li><p>Dis: suffer more from <strong>attenuation</strong>( the loss of signal strength in networking cables or connections)</p></li><li><p>signal has small band width. data is compressd to signal for trans<br><strong>analog signal</strong> is sampled to <strong>digital signal</strong></p></li></ul><h2 id="Transmission-Media"><a href="#Transmission-Media" class="headerlink" title="Transmission Media"></a>Transmission Media</h2><ul><li>guided - wire<ul><li>medium is more important</li></ul></li><li>unguided- wireless<ul><li>bandwidth produced by the antenna(天线) is more important</li></ul></li></ul><h3 id="Guided-transmission-media"><a href="#Guided-transmission-media" class="headerlink" title="Guided transmission media"></a>Guided transmission media</h3><h4 id="twisted-pair"><a href="#twisted-pair" class="headerlink" title="twisted pair"></a>twisted pair</h4><ul><li>application: Most common <ul><li>telephone, LANs,PBX</li></ul></li><li>pros:<ul><li>cheap</li><li>easy</li></ul></li><li>cons<ul><li>Low data rate</li><li>short range</li></ul></li><li>Unshield and shiled twisted pair<ul><li>STP: reduce interference</li></ul></li></ul><h4 id="coaxial-cable"><a href="#coaxial-cable" class="headerlink" title="coaxial cable"></a>coaxial cable</h4><ul><li>application:TV distribution, LANs. Long distance telephone transmission</li><li>pros: good noise immunity</li><li>cons:harder to install and repair, moderate cost</li></ul><h4 id="optical-fibers"><a href="#optical-fibers" class="headerlink" title="optical fibers"></a>optical fibers</h4><ul><li>application:Long-haul trunks, metropolitan trunks,LANs</li><li>pros:greater capacity, small size and weight, lower attenuation, reter repeater spacing </li><li>cons</li></ul><h3 id="wireless-communication"><a href="#wireless-communication" class="headerlink" title="wireless communication"></a>wireless communication</h3><ul><li>unguided, via antenna</li><li>Directional: focused beam and careful alignment required</li><li>Omnidirctional: spread in all directions, can be received by many antenna</li></ul><h2 id="Encoding-and-decoding"><a href="#Encoding-and-decoding" class="headerlink" title="Encoding and decoding"></a>Encoding and decoding</h2><h3 id="NRZ-amp-NRZI"><a href="#NRZ-amp-NRZI" class="headerlink" title="NRZ&amp;NRZI"></a>NRZ&amp;NRZI</h3><p>RZ: 一个周期内，用二进制传输数据位，在数据位脉冲结束后，需要维持一段时间的低电平。</p><ul><li>Non Return to Zero <ul><li>0 &#x3D;high level, 1&#x3D; low level   </li><li>一个周期可以全部用来传输数据</li></ul></li><li>Non Return to Zero, Invert on one<ul><li>如果有变化就是1，不变就保持</li></ul></li><li>Evaluation:<ul><li>+Efficiency use of bandwidth</li><li>+easy to implement</li><li>-DC component</li><li>-synchronization<ul><li>hard to determine begin and end of bits</li></ul></li></ul></li></ul><h3 id="Multilevel-binary"><a href="#Multilevel-binary" class="headerlink" title="Multilevel binary"></a>Multilevel binary</h3><p>三种电平：0,正,负</p><ul><li>Bipolar AMI(Alternate Inversion)   mark &#x3D;1<br>0 - no signal, 1 &#x3D; positive or neg but must alternate<br>anti DC </li><li>pseudoternary: 1 &#x3D; no signal, 0 &#x3D; positive neg (must alternate). 1编码成0电平，0编码成正负交替电平</li></ul><p><img src="/img/Bipolar-AMI.png" srcset="/img/loading.gif" lazyload alt="Bipolar-AMI"></p><ul><li>evaluation<ul><li>+no DC component  </li><li>+good synchronization</li><li>+error detection</li><li>-not efficient as NRZ</li></ul></li></ul><h3 id="Biphase"><a href="#Biphase" class="headerlink" title="Biphase"></a>Biphase</h3><h4 id="Manchester"><a href="#Manchester" class="headerlink" title="Manchester"></a>Manchester</h4><ul><li>transition in middle of every interval</li><li>0 &#x3D; transition from high to low in middle of interval</li><li>1&#x3D;transition from low to high in middle of interval 在</li></ul><h4 id="diff-Manchester"><a href="#diff-Manchester" class="headerlink" title="diff Manchester"></a>diff Manchester</h4><ul><li><p>0:在开头变</p></li><li><p>1:先保持在中间变</p></li><li><p>evaluation</p><ul><li>+Synchronization on mid bit transition</li><li>+no dc</li><li>+error detection</li><li>-need more bandwidth</li></ul></li></ul><p><img src="/img/manchester.png" srcset="/img/loading.gif" lazyload alt="Manchester"></p><h3 id="Digital-Data-Analog-Signals"><a href="#Digital-Data-Analog-Signals" class="headerlink" title="Digital Data Analog Signals"></a>Digital Data Analog Signals</h3><h4 id="Modulate"><a href="#Modulate" class="headerlink" title="Modulate"></a>Modulate</h4><ul><li>Amplitude Shift Keying (ASK)  </li><li>Frequency Shift Keying (FSK) </li><li>Phase shift Keying (PSK)</li></ul><h4 id="Digitization"><a href="#Digitization" class="headerlink" title="Digitization"></a>Digitization</h4><p>Def: analog data to digital data  </p><ul><li><p>Digital data can then be transmitted using code.</p></li><li><p>Digital data can then be converted to analog signal</p></li><li><p>Digital data can then be converted to <strong>analog signal</strong></p></li><li><p>Analog to digital conversion done using a code</p></li><li><p>Pulse code modulation</p></li><li><p>Delta modulation</p></li><li><p>why</p><ul><li>Higer f –&gt; more efficient</li><li>Permits frequency division multiplexing</li></ul></li><li><p>Type of modulation</p><ul><li>amplitude</li><li>phase</li><li>frequency</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1st lecture of 7CCEMMLE Machine Learning</title>
    <link href="/2022/09/18/MLLec1/"/>
    <url>/2022/09/18/MLLec1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><p><h1 id="First-Lec-of-Machine-Learning"><a href="#First-Lec-of-Machine-Learning" class="headerlink" title="First Lec of Machine Learning"></a>First Lec of Machine Learning</h1><h2 id="intro-of-Module"><a href="#intro-of-Module" class="headerlink" title="intro of Module"></a>intro of Module</h2><ul></p><p><li>basic of Linearg algebra, calculus, and probability</li></p><p><li>MATLAB</li><br>&lt;/ul&gt;</p><p><h2 id="what-is-ML"><a href="#what-is-ML" class="headerlink" title="what is ML"></a>what is ML</h2><ol></p><p><li>Induction bias selection: selection of a model<br>train process: optimise </li></p><p><li>Learning: based on data, collection typical data to opitimize algorism</li></p><p><li>Inference, control: use the trained machine(a black-box) then generalize<br><img src="/img/mllec1.png" srcset="/img/loading.gif" lazyload alt="ML approach"><br>Integrating domain knowledge into a machine learning approach<h2 id="ML-method"><a href="#ML-method" class="headerlink" title="ML method"></a>ML method</h2></li><br>&lt;/ol&gt;</p><p><ul></p><p><li>supervised learning </li></p><p><li>unsupervised learning </li></p><p><li>reinforcement(强化学习) learning</li><br>&lt;/ul&gt;</p><p><h3 id="supervised-vs-unsupervised-learing"><a href="#supervised-vs-unsupervised-learing" class="headerlink" title="supervised vs unsupervised learing"></a>supervised vs unsupervised learing</h3><p><img src="/img/mllec2.png" srcset="/img/loading.gif" lazyload alt="vs"><br>supervised: classification. Give data to train a model that generalized can give result about data not in dataset<br>unsuervised : cluster </p></p><p><h2 id="When-to-use"><a href="#When-to-use" class="headerlink" title="When to use"></a>When to use</h2><h3 id="Potential-advantages"><a href="#Potential-advantages" class="headerlink" title="Potential advantages"></a>Potential advantages</h3><ul></p><p><li>lower cost and faster development </li></p><p><li>reduced implementation complexity</li><br>&lt;/ul&gt;</p><p><h3 id="potential-disadvantages"><a href="#potential-disadvantages" class="headerlink" title="potential disadvantages"></a>potential disadvantages</h3><ul></p><p><li>suboptimal performance and limited perfomance guarantees</li></p><p><li>limited interpretability</li><br>&lt;/ul&gt;</p><p><h1 id="Basic-Background"><a href="#Basic-Background" class="headerlink" title="Basic Background"></a>Basic Background</h1><ul></p><p><li>refresher on probablity and linear algebra<h2 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h2></li>ML</p><p><li>def: a random numberical quantitiesthat takes values in a set </li></p><p><li>Bernoulli variable（二分步）: $x～Bern(q)$，set: $X &#x3D; {0,1}$</li><br>&lt;/ul&gt;</p><p>$p(1) &#x3D; Bern(1|q) &#x3D; Pr[x&#x3D;1] &#x3D; q$   </p><ul><li>Categorical variable:<ul><li>$x~Cat(q)$ take values in $X &#x3D; {0,1,2,3,\ddots,}$</li><li>$p(k) &#x3D; Cat(k|q) &#x3D; Pr[x&#x3D;k] &#x3D; q_k$</li></ul></li></ul><h3 id="decrete-RV"><a href="#decrete-RV" class="headerlink" title="decrete RV"></a>decrete RV</h3><p>categorical rvs are represented using one-hot verctor<br>$x^OH$ os dimension Cx1 with all zeros except for a one in the (k + 1)th position when x &#x3D; k<br>For C&#x3D;4, x &#x3D; 0:<br>$$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;1\ &amp;0\&amp;0\&amp;0\end{bmatrix}$$<br>  if x &#x3D;2<br>  $$x^{OH} &#x3D; \begin{bmatrix}<br>  &amp;0\ &amp;0\&amp;1\&amp;0\end{bmatrix}$$</p><h3 id="continuous-rv"><a href="#continuous-rv" class="headerlink" title="continuous rv"></a>continuous rv</h3><p>described by pdf. p(x): x~p(x)<br>$p(x)\geq0$and $\int ^{\infin}_{-\infty} p(x)dx &#x3D;1$  </p><p><strong>Gaussian is the most important</strong></p><h4 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h4><p>$$x \sim N(\mu,\sigma^2)&#x3D;\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(x-\mu)^2}{2\sigma^2}$$<br>$\mu$ is the Expection and $\sigma^2$ is Variance</p><h2 id="Expectation-and-variance"><a href="#Expectation-and-variance" class="headerlink" title="Expectation and variance"></a>Expectation and variance</h2><h3 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h3><ul><li>$$E_{x\sim p(x)} [x] &#x3D; \sum_{x \in X} {p(x) \cdot x}$$</li><li>the expectation of function of a dicrete rv is<br>$$E_{x\sim p(x)} [f(x)] &#x3D; \sum_{x \in X} {p(x) \cdot f(x)}$$</li><li>For Categorical<br>$$E_{x\sim Cat(q)} [f(x)] &#x3D; \sum_{x \in X} {q(x) \cdot f(x)}$$</li><li>For continuous rv:</li></ul><p>$$E_{x\sim p(x)} [f(x)] &#x3D; \int_{-\infin}^{\infty} {p(x) \cdot f(x)dx}$$</p><ul><li>For Gaussian</li></ul><p>$$E_{x \sim N(\mu,\sigma^2)} [x] &#x3D; \mu$$<br>$$E_{x \sim N(\mu,\sigma^2)} [x^2] &#x3D; \mu^2+\sigma^2$$</p><ul><li>It is linear</li></ul><h3 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h3><p>For Categorical rv $x\sim Cat(q)$:$$<br>$$Var(x) &#x3D; \sum^{C-1}<em>{x&#x3D;0} q_x(x-(\sum^{C-1}</em>{x&#x3D;0}q_x x))^2$$  </p><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><ul><li><p>vector is an ordered collection of scalars.</p></li><li><p>tanspose: $x^T$<br>,from row to column or from column2row.</p></li><li><p>inner pordx&#96;uct: a measure of <strong>similarity</strong></p></li><li><p>Inner product $x^Ty &#x3D; \sum^L_{i&#x3D;1}x_iy_i$</p></li><li><p><strong>Normalize</strong><br>$$||x||&#x3D;\sqrt{x^Tx}&#x3D;\sqrt{\sum_{i&#x3D;1}^L x_i^2}$$</p></li><li><p>unitary norm of vector $\tilde s&#x3D;\cfrac{x}{||x||}$, $||\tilde{x}||^2 &#x3D; 1$</p></li><li><p>orthogonal: $x^Ty &#x3D; 0$</p></li><li><p>Diagonal matrix: L x L, only diag is 1  </p></li><li><p>$Diag(a)&#x3D;\begin{bmatrix}<br>&amp;a_1 &amp;0 &amp;\cdots &amp;0\<br>&amp;0 &amp;a_2 &amp;\cdots &amp;0 \<br>&amp;\vdots &amp; &amp;\ddots&amp;\vdots\<br>&amp;0 &amp;0 &amp;\cdots &amp;a_L\end{bmatrix}$</p></li><li><p>Outer producet: 2 L x 1 vectors make LxL matrix</p></li><li><p>Symmetric matrix:对称矩阵。$A^T &#x3D; A$</p></li><li><p>Outer product. </p></li><li><p>vector-matrix multiplication: $x^TA &#x3D; (A^Tx)^T$</p><ul><li>positive simi-define:</li></ul></li><li><p>Eigenvector &amp; Eigenvalue</p><ul><li>in fact it the eigenvector is a base vector and the eigenvalue is a scaling factor so that we can simplify the calculation of a linear transformation on one vector.</li><li>def: if A is an $n \times n$ matrix,if there is an non-zero vector $x$ can let $Ax &#x3D; \lambda x$, then the $\lambda$ is the eigenvalue and the vector $x$ is the eigenvector belonging to $\lambda$.</li></ul></li><li><p>calculation of eigenvector</p></li></ul><p>$$(A-\lambda I)x&#x3D;0$$<br>which means<br>$$det(A-\lambda I)&#x3D;0$$  </p>]]></content>
    
    
    <categories>
      
      <category>Master Lecture notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
